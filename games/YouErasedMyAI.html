<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Tactical Grid Combat ‚Äî AI Opponent</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0a0e1a; --panel:#151b2e; --ink:#e8f0ff; --muted:#8b9dc3;
    --surv:#3b82f6; --ai:#22c55e; --bad:#ef4444; --ok:#22c55e;
    --grid:#1a2237; --cell:#0f1624; --cellH:#1a2540;
    --hit:#ef4444; --miss:#475569; --ship:#3b82f6;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:linear-gradient(135deg,#0a0e1a 0%,#151b2e 100%);color:var(--ink);font-family:Inter,system-ui,sans-serif;overflow:hidden}
  
  .app{height:100vh;width:100vw;display:flex;flex-direction:column}
  
  /* Top bar */
  .topbar{height:70px;background:rgba(15,20,35,.95);border-bottom:1px solid rgba(255,255,255,.08);display:flex;align-items:center;padding:0 24px;gap:20px}
  .logo{font-size:20px;font-weight:800;letter-spacing:.5px;color:var(--surv)}
  .faction-pick{display:flex;gap:8px}
  .faction-btn{padding:10px 18px;border-radius:8px;border:2px solid rgba(255,255,255,.15);background:rgba(255,255,255,.05);color:var(--ink);font-weight:700;cursor:pointer;transition:all .2s}
  .faction-btn:hover{background:rgba(255,255,255,.1);transform:translateY(-1px)}
  .faction-btn.active{border-color:var(--surv);background:rgba(59,130,246,.2);box-shadow:0 0 12px rgba(59,130,246,.4)}
  .spacer{flex:1}
  .score-panel{display:flex;gap:16px;align-items:center}
  .stat{background:rgba(255,255,255,.06);padding:8px 16px;border-radius:8px;border:1px solid rgba(255,255,255,.1);font-weight:700}
  .stat .label{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.5px}
  .stat .value{font-size:18px;margin-top:2px}
  .ap-display{display:flex;gap:6px}
  .ap-pip{width:24px;height:24px;border-radius:50%;background:rgba(255,255,255,.12);border:2px solid rgba(255,255,255,.2)}
  .ap-pip.active{background:var(--ok);border-color:var(--ok);box-shadow:0 0 8px var(--ok)}
  
  /* Main game area */
  .main{flex:1;display:grid;grid-template-columns:1fr 320px;gap:20px;padding:20px;overflow:hidden}
  
  /* Board container */
  .board-wrap{background:rgba(15,20,35,.7);border:1px solid rgba(255,255,255,.1);border-radius:12px;overflow:hidden;display:flex;flex-direction:column}
  .board-header{padding:14px 18px;background:rgba(59,130,246,.12);border-bottom:1px solid rgba(255,255,255,.08);font-weight:800;display:flex;justify-content:space-between;align-items:center}
  .phase-label{font-size:13px;color:var(--muted);font-weight:600}
  .grid-container{flex:1;padding:16px;position:relative}
  .grid{display:grid;grid-template-columns:repeat(10,1fr);gap:3px;height:100%;width:100%;max-width:600px;margin:0 auto}
  .cell{background:var(--cell);border:1px solid rgba(255,255,255,.06);border-radius:4px;cursor:pointer;transition:all .15s;position:relative;aspect-ratio:1}
  .cell:hover{background:var(--cellH);border-color:rgba(255,255,255,.15)}
  .cell.ship{background:linear-gradient(135deg,rgba(59,130,246,.25),rgba(59,130,246,.15));border-color:rgba(59,130,246,.4)}
  .cell.hit{background:linear-gradient(135deg,rgba(239,68,68,.35),rgba(239,68,68,.2));border-color:rgba(239,68,68,.6)}
  .cell.hit::after{content:'‚úï';position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:20px;color:var(--hit);font-weight:800}
  .cell.miss{background:rgba(71,85,105,.25);border-color:rgba(71,85,105,.4)}
  .cell.miss::after{content:'‚óã';position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:16px;color:var(--miss);font-weight:600}
  .cell.your-hit{background:linear-gradient(135deg,rgba(34,197,94,.35),rgba(34,197,94,.2));border-color:rgba(34,197,94,.6)}
  .cell.your-hit::after{content:'‚úì';color:var(--ok)}
  .cell.your-miss{background:rgba(100,116,139,.2);border-color:rgba(100,116,139,.35)}
  .cell.preview-ok{outline:2px dashed var(--ok);background:rgba(34,197,94,.1)}
  .cell.preview-bad{outline:2px dashed var(--bad);background:rgba(239,68,68,.1)}
  
  /* Sidebar */
  .sidebar{background:rgba(15,20,35,.7);border:1px solid rgba(255,255,255,.1);border-radius:12px;display:flex;flex-direction:column}
  .sidebar-header{padding:14px 18px;border-bottom:1px solid rgba(255,255,255,.08);font-weight:800;font-size:15px}
  .units-list{flex:1;padding:12px;overflow-y:auto;display:flex;flex-direction:column;gap:10px}
  .unit-card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.1);border-radius:8px;padding:12px;cursor:pointer;transition:all .2s}
  .unit-card:hover{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.2)}
  .unit-card.active{border-color:var(--surv);background:rgba(59,130,246,.15);box-shadow:0 0 8px rgba(59,130,246,.3)}
  .unit-card.placed{opacity:.5;cursor:not-allowed}
  .unit-name{font-weight:700;font-size:14px;margin-bottom:4px}
  .unit-meta{font-size:12px;color:var(--muted)}
  .unit-status{display:inline-block;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:700;margin-top:6px}
  .unit-status.ready{background:rgba(34,197,94,.2);color:var(--ok)}
  .unit-status.placed{background:rgba(100,116,139,.2);color:var(--muted)}
  
  /* Actions */
  .actions{padding:12px;border-top:1px solid rgba(255,255,255,.08);display:flex;flex-direction:column;gap:8px}
  .btn{padding:12px;border:none;border-radius:8px;font-weight:700;font-size:14px;cursor:pointer;transition:all .15s;color:white}
  .btn:disabled{opacity:.4;cursor:not-allowed}
  .btn-primary{background:linear-gradient(135deg,#3b82f6,#2563eb);box-shadow:0 4px 12px rgba(59,130,246,.3)}
  .btn-primary:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 16px rgba(59,130,246,.4)}
  .btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);box-shadow:0 4px 12px rgba(239,68,68,.3)}
  .btn-danger:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 16px rgba(239,68,68,.4)}
  .btn-ghost{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);color:var(--ink)}
  .btn-ghost:hover:not(:disabled){background:rgba(255,255,255,.12)}
  
  /* Bottom log */
  .log-area{height:80px;background:rgba(15,20,35,.95);border-top:1px solid rgba(255,255,255,.08);padding:12px 24px;overflow-y:auto;font-size:13px}
  .log-entry{padding:4px 0;color:var(--muted)}
  .log-entry.important{color:var(--ink);font-weight:600}
  
  /* AI thinking overlay */
  .ai-overlay{position:absolute;inset:0;background:rgba(10,14,26,.95);display:flex;align-items:center;justify-content:center;flex-direction:column;gap:16px;opacity:0;pointer-events:none;transition:opacity .3s;z-index:100}
  .ai-overlay.show{opacity:1}
  .ai-spinner{width:48px;height:48px;border:4px solid rgba(34,197,94,.2);border-top-color:var(--ai);border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  .ai-label{font-size:18px;font-weight:700;color:var(--ai)}
  
  /* Game over modal */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.8);display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .3s;z-index:200}
  .modal.show{opacity:1;pointer-events:all}
  .modal-content{background:var(--panel);border:1px solid rgba(255,255,255,.2);border-radius:16px;padding:32px;text-align:center;max-width:400px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
  .modal-title{font-size:32px;font-weight:800;margin-bottom:12px}
  .modal-message{font-size:16px;color:var(--muted);margin-bottom:24px}
  .modal-score{font-size:48px;font-weight:800;color:var(--surv);margin-bottom:24px}
</style>
</head>
<body>
<div class="app">
  <!-- Top Bar -->
  <div class="topbar">
    <div class="logo">‚ö° TACTICAL GRID COMBAT</div>
    <div class="faction-pick">
      <button class="faction-btn active" data-faction="survivors">üõ°Ô∏è Survivors</button>
      <button class="faction-btn" data-faction="ai">ü§ñ AI Forces</button>
    </div>
    <div class="spacer"></div>
    <div class="score-panel">
      <div class="stat">
        <div class="label">Your Score</div>
        <div class="value" id="playerScore">0</div>
      </div>
      <div class="stat">
        <div class="label">Enemy Score</div>
        <div class="value" id="enemyScore">0</div>
      </div>
      <div class="stat">
        <div class="label">Action Points</div>
        <div class="ap-display">
          <div class="ap-pip" id="ap1"></div>
          <div class="ap-pip" id="ap2"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Game Area -->
  <div class="main">
    <div class="board-wrap">
      <div class="board-header">
        <span id="boardTitle">YOUR GRID</span>
        <span class="phase-label" id="phaseLabel">Place your units</span>
      </div>
      <div class="grid-container">
        <div class="grid" id="grid"></div>
        <div class="ai-overlay" id="aiOverlay">
          <div class="ai-spinner"></div>
          <div class="ai-label">AI COMPUTING...</div>
        </div>
      </div>
    </div>

    <div class="sidebar">
      <div class="sidebar-header">UNITS & ACTIONS</div>
      <div class="units-list" id="unitsList"></div>
      <div class="actions">
        <button class="btn btn-danger" id="attackBtn" disabled>üéØ Attack</button>
        <button class="btn btn-primary" id="scanBtn" disabled>üì° Scan Area (1 AP)</button>
        <button class="btn btn-ghost" id="endTurnBtn" disabled>‚è≠Ô∏è End Turn</button>
        <button class="btn btn-ghost" id="resetBtn">üîÑ New Game</button>
      </div>
    </div>
  </div>

  <!-- Log Area -->
  <div class="log-area" id="log"></div>

  <!-- Game Over Modal -->
  <div class="modal" id="gameOverModal">
    <div class="modal-content">
      <div class="modal-title" id="modalTitle">VICTORY!</div>
      <div class="modal-message" id="modalMessage">You destroyed the enemy fleet!</div>
      <div class="modal-score" id="modalScore">750</div>
      <button class="btn btn-primary" onclick="resetGame()">Play Again</button>
    </div>
  </div>
</div>

<script>
// ============ CONFIG ============
const CFG = {
  BOARD_SIZE: 10,
  AP_PER_TURN: 2,
  AI_THINK_TIME: 1200,
  ANIMATION_TIME: 600,
  POINTS: { HIT: 10, SINK: 50, WIN: 200 },
  POLLINATIONS_URL: "https://text.pollinations.ai/openai"
};

// ============ UNIT DEFINITIONS ============
const UNITS = {
  DESTROYER: { id: 'destroyer', size: 2, count: 2, name: 'Destroyer' },
  CRUISER: { id: 'cruiser', size: 3, count: 2, name: 'Cruiser' },
  BATTLESHIP: { id: 'battleship', size: 4, count: 1, name: 'Battleship' },
  CARRIER: { id: 'carrier', size: 5, count: 1, name: 'Carrier' }
};

// ============ GAME STATE ============
const state = {
  phase: 'faction_select', // faction_select, placement, battle, game_over
  playerFaction: 'survivors',
  currentTurn: 'player',
  ap: CFG.AP_PER_TURN,
  playerScore: 0,
  enemyScore: 0,
  selectedAction: 'attack',
  placingUnit: null,
  placingRotation: false,
  
  playerBoard: createBoard(),
  enemyBoard: createBoard(),
  playerKnowledge: createBoard(), // What player knows about enemy
  
  playerUnits: [],
  enemyUnits: [],
  
  playerUnitsToPlace: [],
  placedCount: 0
};

// ============ HELPERS ============
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

function createBoard() {
  const board = [];
  for (let y = 0; y < CFG.BOARD_SIZE; y++) {
    board[y] = [];
    for (let x = 0; x < CFG.BOARD_SIZE; x++) {
      board[y][x] = { ship: null, hit: false, miss: false };
    }
  }
  return board;
}

function log(message, important = false) {
  const entry = document.createElement('div');
  entry.className = 'log-entry' + (important ? ' important' : '');
  entry.textContent = '‚Ä¢ ' + message;
  $('#log').prepend(entry);
}

function cellIndex(x, y) {
  return y * CFG.BOARD_SIZE + x;
}

function updateUI() {
  $('#playerScore').textContent = state.playerScore;
  $('#enemyScore').textContent = state.enemyScore;
  
  $('#ap1').classList.toggle('active', state.ap >= 1);
  $('#ap2').classList.toggle('active', state.ap >= 2);
  
  const inBattle = state.phase === 'battle';
  const playerTurn = state.currentTurn === 'player';
  
  $('#attackBtn').disabled = !inBattle || !playerTurn || state.ap < 1;
  $('#scanBtn').disabled = !inBattle || !playerTurn || state.ap < 1;
  $('#endTurnBtn').disabled = !inBattle || !playerTurn;
  
  if (state.phase === 'placement') {
    $('#phaseLabel').textContent = `Place units (${state.placedCount}/${state.playerUnitsToPlace.length})`;
    $('#boardTitle').textContent = 'YOUR GRID - PLACEMENT';
  } else if (state.phase === 'battle') {
    $('#phaseLabel').textContent = playerTurn ? 'Your turn' : 'Enemy turn';
    $('#boardTitle').textContent = playerTurn ? 'YOUR GRID - BATTLE' : 'ENEMY ATTACKING...';
  }
}

// ============ BOARD RENDERING ============
function renderGrid() {
  const grid = $('#grid');
  grid.innerHTML = '';
  
  for (let y = 0; y < CFG.BOARD_SIZE; y++) {
    for (let x = 0; x < CFG.BOARD_SIZE; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x;
      cell.dataset.y = y;
      
      const playerCell = state.playerBoard[y][x];
      const knowledgeCell = state.playerKnowledge[y][x];
      
      // Show player's own ships during placement and battle
      if (playerCell.ship) {
        cell.classList.add('ship');
      }
      
      // Show hits/misses on player's board (enemy attacks)
      if (playerCell.hit) {
        cell.classList.add('hit');
      } else if (playerCell.miss) {
        cell.classList.add('miss');
      }
      
      // Show player's attacks on enemy board (via knowledge board)
      if (knowledgeCell.hit) {
        cell.classList.add('your-hit');
      } else if (knowledgeCell.miss) {
        cell.classList.add('your-miss');
      }
      
      grid.appendChild(cell);
    }
  }
}

function renderUnits() {
  const list = $('#unitsList');
  list.innerHTML = '';
  
  if (state.phase === 'placement') {
    state.playerUnitsToPlace.forEach((unit, idx) => {
      const card = document.createElement('div');
      card.className = 'unit-card';
      if (unit.placed) card.classList.add('placed');
      if (state.placingUnit === idx) card.classList.add('active');
      
      card.innerHTML = `
        <div class="unit-name">${unit.name}</div>
        <div class="unit-meta">Size: ${unit.size} cells</div>
        <div class="unit-status ${unit.placed ? 'placed' : 'ready'}">${unit.placed ? 'PLACED' : 'READY'}</div>
      `;
      
      if (!unit.placed) {
        card.onclick = () => {
          state.placingUnit = idx;
          renderUnits();
          log(`Selected ${unit.name}. Click grid to place. Press R to rotate.`);
        };
      }
      
      list.appendChild(card);
    });
  } else if (state.phase === 'battle') {
    const alive = state.playerUnits.filter(u => u.hp > 0);
    alive.forEach(unit => {
      const card = document.createElement('div');
      card.className = 'unit-card placed';
      card.innerHTML = `
        <div class="unit-name">${unit.name}</div>
        <div class="unit-meta">HP: ${unit.hp}/${unit.size}</div>
        <div class="unit-status ready">ACTIVE</div>
      `;
      list.appendChild(card);
    });
  }
}

// ============ PLACEMENT LOGIC ============
function canPlaceUnit(board, unit, x, y, rotation) {
  const size = unit.size;
  for (let i = 0; i < size; i++) {
    const cx = rotation ? x : x + i;
    const cy = rotation ? y + i : y;
    
    if (cx < 0 || cy < 0 || cx >= CFG.BOARD_SIZE || cy >= CFG.BOARD_SIZE) return false;
    if (board[cy][cx].ship) return false;
  }
  return true;
}

function placeUnit(board, units, unit, x, y, rotation) {
  const size = unit.size;
  const coords = [];
  
  for (let i = 0; i < size; i++) {
    const cx = rotation ? x : x + i;
    const cy = rotation ? y + i : y;
    board[cy][cx].ship = unit.id;
    coords.push({ x: cx, y: cy });
  }
  
  units.push({
    id: unit.id,
    name: unit.name,
    size: unit.size,
    hp: unit.size,
    coords: coords
  });
}

// ============ COMBAT LOGIC ============
function attack(board, units, x, y) {
  const cell = board[y][x];
  
  if (cell.hit || cell.miss) {
    return { valid: false, reason: 'Already attacked' };
  }
  
  if (cell.ship) {
    cell.hit = true;
    const unit = units.find(u => u.id === cell.ship);
    unit.hp--;
    
    const sunk = unit.hp <= 0;
    return { valid: true, hit: true, sunk, unitName: unit.name };
  } else {
    cell.miss = true;
    return { valid: true, hit: false };
  }
}

function scan(board, x, y) {
  let count = 0;
  const cells = [];
  
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const cx = x + dx;
      const cy = y + dy;
      if (cx >= 0 && cy >= 0 && cx < CFG.BOARD_SIZE && cy < CFG.BOARD_SIZE) {
        cells.push({ x: cx, y: cy });
        if (board[cy][cx].ship && !board[cy][cx].hit) count++;
      }
    }
  }
  
  return { count, cells };
}

// ============ AI LOGIC ============
async function getAITargets() {
  // Build simple target options for AI
  const options = [];
  
  // Find untargeted cells
  const untargeted = [];
  for (let y = 0; y < CFG.BOARD_SIZE; y++) {
    for (let x = 0; x < CFG.BOARD_SIZE; x++) {
      const cell = state.playerBoard[y][x];
      if (!cell.hit && !cell.miss) {
        untargeted.push({ x, y, hasShip: !!cell.ship });
      }
    }
  }
  
  if (untargeted.length === 0) return [];
  
  // Recent hits to follow up on
  const recentHits = [];
  for (let y = 0; y < CFG.BOARD_SIZE; y++) {
    for (let x = 0; x < CFG.BOARD_SIZE; x++) {
      const cell = state.playerBoard[y][x];
      if (cell.hit && cell.ship) {
        // Check adjacent cells
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < CFG.BOARD_SIZE && ny < CFG.BOARD_SIZE) {
            const nc = state.playerBoard[ny][nx];
            if (!nc.hit && !nc.miss) {
              recentHits.push({ x: nx, y: ny });
            }
          }
        });
      }
    }
  }
  
  // Priority targets (near hits)
  const priority = recentHits.length > 0 ? recentHits.slice(0, 3) : 
                   untargeted.sort(() => Math.random() - 0.5).slice(0, 3);
  
  // Build simple decision prompt
  const prompt = `You are playing battleship. Pick 2 actions from these options:

TARGET OPTIONS (coordinates):
${priority.map((t, i) => `${i+1}. Attack (${t.x},${t.y})`).join('\n')}

${recentHits.length > 0 ? 'STRATEGY: Recent hits detected - follow up on damaged ships!' : 'STRATEGY: Hunt for enemy ships across the grid.'}

Respond with JSON array of 2 actions, like:
[{"action":"attack","target":1},{"action":"attack","target":2}]

Or include a scan:
[{"action":"scan","target":1},{"action":"attack","target":2}]`;

  try {
    const response = await fetch(CFG.POLLINATIONS_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: "openai",
        messages: [
          { role: "system", content: "You are a tactical AI playing battleship. Respond only with valid JSON." },
          { role: "user", content: prompt }
        ]
      })
    });
    
    if (!response.ok) throw new Error('API failed');
    
    const data = await response.json();
    const text = data.choices[0].message.content.trim();
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    if (!jsonMatch) throw new Error('No JSON found');
    
    const actions = JSON.parse(jsonMatch[0]);
    
    // Convert actions to actual coordinates
    return actions.slice(0, CFG.AP_PER_TURN).map(action => ({
      type: action.action,
      x: priority[action.target - 1]?.x ?? priority[0].x,
      y: priority[action.target - 1]?.y ?? priority[0].y
    }));
    
  } catch (err) {
    console.error('AI error:', err);
    // Fallback: just pick random untargeted cells
    return untargeted.sort(() => Math.random() - 0.5).slice(0, CFG.AP_PER_TURN).map(t => ({
      type: 'attack',
      x: t.x,
      y: t.y
    }));
  }
}

async function executeAITurn() {
  state.currentTurn = 'enemy';
  $('#aiOverlay').classList.add('show');
  updateUI();
  
  await new Promise(r => setTimeout(r, CFG.AI_THINK_TIME));
  
  const actions = await getAITargets();
  
  for (const action of actions) {
    await new Promise(r => setTimeout(r, CFG.ANIMATION_TIME));
    
    if (action.type === 'attack') {
      const result = attack(state.playerBoard, state.playerUnits, action.x, action.y);
      
      if (result.valid) {
        if (result.hit) {
          state.enemyScore += CFG.POINTS.HIT;
          log(`Enemy hit your ship at (${action.x},${action.y})!`, true);
          if (result.sunk) {
            state.enemyScore += CFG.POINTS.SINK;
            log(`Enemy sunk your ${result.unitName}!`, true);
          }
        } else {
          log(`Enemy missed at (${action.x},${action.y})`);
        }
      }
    } else if (action.type === 'scan') {
      log(`Enemy scanned area around (${action.x},${action.y})`);
    }
    
    renderGrid();
    updateUI();
  }
  
  $('#aiOverlay').classList.remove('show');
  
  if (checkGameOver()) return;
  
  state.currentTurn = 'player';
  state.ap = CFG.AP_PER_TURN;
  updateUI();
  log('Your turn!', true);
}

// ============ GAME FLOW ============
function checkGameOver() {
  const playerAlive = state.playerUnits.filter(u => u.hp > 0).length;
  const enemyAlive = state.enemyUnits.filter(u => u.hp > 0).length;
  
  if (playerAlive === 0) {
    endGame(false, 'Enemy destroyed your fleet!');
    return true;
  }
  
  if (enemyAlive === 0) {
    endGame(true, 'You destroyed the enemy fleet!');
    return true;
  }
  
  return false;
}

function endGame(playerWon, message) {
  state.phase = 'game_over';
  
  if (playerWon) {
    state.playerScore += CFG.POINTS.WIN;
  } else {
    state.enemyScore += CFG.POINTS.WIN;
  }
  
  $('#modalTitle').textContent = playerWon ? 'VICTORY!' : 'DEFEAT';
  $('#modalMessage').textContent = message;
  $('#modalScore').textContent = state.playerScore;
  $('#gameOverModal').classList.add('show');
  
  updateUI();
}

// ============ EVENT HANDLERS ============
$('#grid').addEventListener('click', async (e) => {
  const cell = e.target.closest('.cell');
  if (!cell) return;
  
  const x = parseInt(cell.dataset.x);
  const y = parseInt(cell.dataset.y);
  
  // PLACEMENT PHASE
  if (state.phase === 'placement') {
    if (state.placingUnit === null) {
      log('Select a unit from the sidebar first!');
      return;
    }
    
    const unit = state.playerUnitsToPlace[state.placingUnit];
    if (unit.placed) return;
    
    if (canPlaceUnit(state.playerBoard, unit, x, y, state.placingRotation)) {
      placeUnit(state.playerBoard, state.playerUnits, unit, x, y, state.placingRotation);
      unit.placed = true;
      state.placedCount++;
      state.placingUnit = null;
      
      renderGrid();
      renderUnits();
      
      if (state.placedCount === state.playerUnitsToPlace.length) {
        log('All units placed! Starting battle...', true);
        await new Promise(r => setTimeout(r, 1000));
        state.phase = 'battle';
        updateUI();
      } else {
        log(`${unit.name} placed! Select next unit.`);
      }
    } else {
      log('Cannot place unit there!');
    }
    return;
  }
  
  // BATTLE PHASE
  if (state.phase === 'battle' && state.currentTurn === 'player' && state.ap > 0) {
    if (state.selectedAction === 'attack') {
      const result = attack(state.enemyBoard, state.enemyUnits, x, y);
      
      if (!result.valid) {
        log(result.reason);
        return;
      }
      
      state.ap--;
      state.playerKnowledge[y][x].hit = result.hit;
      state.playerKnowledge[y][x].miss = !result.hit;
      
      if (result.hit) {
        state.playerScore += CFG.POINTS.HIT;
        log(`Direct hit at (${x},${y})!`, true);
        if (result.sunk) {
          state.playerScore += CFG.POINTS.SINK;
          log(`You sunk enemy ${result.unitName}!`, true);
        }
      } else {
        log(`Miss at (${x},${y})`);
      }
      
      renderGrid();
      updateUI();
      
      if (checkGameOver()) return;
      
      if (state.ap === 0) {
        log('Out of AP. End your turn!', true);
      }
    } else if (state.selectedAction === 'scan') {
      const result = scan(state.enemyBoard, x, y);
      state.ap--;
      log(`Scan detected ${result.count} ship(s) in the area!`, true);
      updateUI();
    }
  }
});

$('#grid').addEventListener('mousemove', (e) => {
  if (state.phase !== 'placement' || state.placingUnit === null) return;
  
  const cell = e.target.closest('.cell');
  if (!cell) return;
  
  const x = parseInt(cell.dataset.x);
  const y = parseInt(cell.dataset.y);
  
  $$('.cell').forEach(c => c.classList.remove('preview-ok', 'preview-bad'));
  
  const unit = state.playerUnitsToPlace[state.placingUnit];
  if (unit.placed) return;
  
  const canPlace = canPlaceUnit(state.playerBoard, unit, x, y, state.placingRotation);
  
  for (let i = 0; i < unit.size; i++) {
    const cx = state.placingRotation ? x : x + i;
    const cy = state.placingRotation ? y + i : y;
    if (cx >= 0 && cy >= 0 && cx < CFG.BOARD_SIZE && cy < CFG.BOARD_SIZE) {
      const idx = cellIndex(cx, cy);
      $('#grid').children[idx]?.classList.add(canPlace ? 'preview-ok' : 'preview-bad');
    }
  }
});

$('#grid').addEventListener('mouseleave', () => {
  $$('.cell').forEach(c => c.classList.remove('preview-ok', 'preview-bad'));
});

$('#attackBtn').onclick = () => {
  state.selectedAction = 'attack';
  log('Attack mode: Click enemy grid to fire!');
};

$('#scanBtn').onclick = () => {
  state.selectedAction = 'scan';
  log('Scan mode: Click to scan 3x3 area for ships!');
};

$('#endTurnBtn').onclick = () => {
  if (state.phase === 'battle' && state.currentTurn === 'player') {
    log('Ending turn...', true);
    executeAITurn();
  }
};

$('#resetBtn').onclick = resetGame;

document.addEventListener('keydown', (e) => {
  if (e.key === 'r' || e.key === 'R') {
    if (state.phase === 'placement') {
      state.placingRotation = !state.placingRotation;
      log(`Rotation: ${state.placingRotation ? 'Vertical' : 'Horizontal'}`);
    }
  }
});

// Faction selection
$$('.faction-btn').forEach(btn => {
  btn.onclick = () => {
    if (state.phase !== 'faction_select') return;
    
    $$('.faction-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.playerFaction = btn.dataset.faction;
    
    log(`You selected ${state.playerFaction === 'survivors' ? 'üõ°Ô∏è Survivors' : 'ü§ñ AI Forces'}!`, true);
    
    setTimeout(() => {
      startPlacement();
    }, 800);
  };
});

// ============ GAME INITIALIZATION ============
function startPlacement() {
  state.phase = 'placement';
  state.placedCount = 0;
  state.placingUnit = null;
  
  // Create units to place
  state.playerUnitsToPlace = [];
  Object.values(UNITS).forEach(def => {
    for (let i = 0; i < def.count; i++) {
      state.playerUnitsToPlace.push({
        ...def,
        id: `${def.id}_${i}`,
        placed: false
      });
    }
  });
  
  // Place enemy units randomly
  Object.values(UNITS).forEach(def => {
    for (let i = 0; i < def.count; i++) {
      let placed = false;
      let attempts = 0;
      while (!placed && attempts < 100) {
        const x = Math.floor(Math.random() * CFG.BOARD_SIZE);
        const y = Math.floor(Math.random() * CFG.BOARD_SIZE);
        const rot = Math.random() < 0.5;
        
        if (canPlaceUnit(state.enemyBoard, def, x, y, rot)) {
          placeUnit(state.enemyBoard, state.enemyUnits, {
            ...def,
            id: `${def.id}_enemy_${i}`
          }, x, y, rot);
          placed = true;
        }
        attempts++;
      }
    }
  });
  
  renderGrid();
  renderUnits();
  updateUI();
  log('Place your fleet on the grid!', true);
}

function resetGame() {
  // Reset state
  state.phase = 'faction_select';
  state.playerFaction = 'survivors';
  state.currentTurn = 'player';
  state.ap = CFG.AP_PER_TURN;
  state.playerScore = 0;
  state.enemyScore = 0;
  state.selectedAction = 'attack';
  state.placingUnit = null;
  state.placingRotation = false;
  
  state.playerBoard = createBoard();
  state.enemyBoard = createBoard();
  state.playerKnowledge = createBoard();
  
  state.playerUnits = [];
  state.enemyUnits = [];
  state.playerUnitsToPlace = [];
  state.placedCount = 0;
  
  $('#gameOverModal').classList.remove('show');
  $('#log').innerHTML = '';
  
  renderGrid();
  renderUnits();
  updateUI();
  
  log('Select your faction to begin!', true);
}

// ============ START ============
resetGame();
</script>
</body>
</html>
