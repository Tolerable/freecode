<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>‚ö° Tactical Grid Combat</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0a0e1a; --panel:#151b2e; --ink:#e8f0ff; --muted:#8b9dc3;
    --surv:#3b82f6; --ai:#22c55e; --bad:#ef4444; --ok:#22c55e;
    --grid:#1a2237; --cell:#0f1624; --cellH:#1a2540;
    --hit:#ef4444; --miss:#475569; --ship:#3b82f6; --scan:#8b5cf6;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:linear-gradient(135deg,#0a0e1a 0%,#151b2e 100%);color:var(--ink);font-family:Inter,system-ui,sans-serif;overflow:hidden}
  
  .app{height:100vh;width:100vw;display:flex;flex-direction:column;position:relative}
  
  /* Top bar */
  .topbar{height:60px;background:rgba(15,20,35,.95);border-bottom:1px solid rgba(255,255,255,.08);display:flex;align-items:center;padding:0 24px;gap:20px;position:relative;z-index:10}
  .logo{font-size:18px;font-weight:800;letter-spacing:.5px;color:var(--surv)}
  .faction-pick{display:flex;gap:8px}
  .faction-btn{padding:8px 16px;border-radius:8px;border:2px solid rgba(255,255,255,.15);background:rgba(255,255,255,.05);color:var(--ink);font-weight:700;cursor:pointer;transition:all .2s;font-size:13px}
  .faction-btn:hover{background:rgba(255,255,255,.1);transform:translateY(-1px)}
  .faction-btn.active{border-color:var(--surv);background:rgba(59,130,246,.2);box-shadow:0 0 12px rgba(59,130,246,.4)}
  .spacer{flex:1}
  .score-panel{display:flex;gap:14px;align-items:center}
  .stat{background:rgba(255,255,255,.06);padding:6px 14px;border-radius:8px;border:1px solid rgba(255,255,255,.1);font-weight:700;cursor:pointer;transition:all .2s}
  .stat:hover{background:rgba(255,255,255,.1);transform:translateY(-1px)}
  .stat .label{font-size:10px;color:var(--muted);text-transform:uppercase;letter-spacing:.5px}
  .stat .value{font-size:16px;margin-top:2px}
  .ap-display{display:flex;gap:6px}
  .ap-pip{width:20px;height:20px;border-radius:50%;background:rgba(255,255,255,.12);border:2px solid rgba(255,255,255,.2);transition:all .3s}
  .ap-pip.active{background:var(--ok);border-color:var(--ok);box-shadow:0 0 8px var(--ok)}
  
  /* AI Thinking Overlay */
  .ai-overlay{position:absolute;top:60px;left:0;right:0;height:140px;background:linear-gradient(180deg,rgba(10,20,30,.98),rgba(10,20,30,.95));border-bottom:2px solid var(--ai);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;transform:translateY(-140px);transition:transform .4s ease;z-index:9;box-shadow:0 8px 24px rgba(0,0,0,.5)}
  .ai-overlay.show{transform:translateY(0)}
  .ai-title{font-size:20px;font-weight:800;color:var(--ai);letter-spacing:1px;text-transform:uppercase}
  .ai-steps{display:flex;gap:16px;align-items:center}
  .ai-step{display:flex;align-items:center;gap:8px;padding:8px 14px;border-radius:8px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.1);opacity:.3;transition:all .3s}
  .ai-step.active{opacity:1;border-color:var(--ai);background:rgba(34,197,94,.15);box-shadow:0 0 12px rgba(34,197,94,.3)}
  .ai-step .icon{font-size:20px}
  .ai-step .text{font-size:13px;font-weight:700}
  .ai-action-log{font-size:14px;color:var(--muted);font-weight:600;min-height:20px}
  
  /* Main game area */
  .main{flex:1;display:grid;grid-template-columns:1fr 280px;gap:16px;padding:16px;overflow:hidden}
  
  /* Board container */
  .board-wrap{background:rgba(15,20,35,.7);border:1px solid rgba(255,255,255,.1);border-radius:12px;overflow:hidden;display:flex;flex-direction:column;position:relative}
  .board-header{padding:12px 18px;background:rgba(59,130,246,.12);border-bottom:1px solid rgba(255,255,255,.08);font-weight:800;display:flex;justify-content:space-between;align-items:center;font-size:14px}
  .phase-label{font-size:12px;color:var(--muted);font-weight:600}
  .grid-container{flex:1;padding:12px;position:relative;display:flex;align-items:center;justify-content:center}
  .grid{display:grid;grid-template-columns:repeat(10,1fr);gap:2px;width:100%;max-width:100%;height:100%;max-height:100%}
  .cell{background:var(--cell);border:1px solid rgba(255,255,255,.06);border-radius:3px;cursor:pointer;transition:all .15s;position:relative;aspect-ratio:2/1;display:flex;align-items:center;justify-content:center;font-size:18px;overflow:hidden}
  .cell:hover{background:var(--cellH);border-color:rgba(255,255,255,.15)}
  .cell.ship{background:linear-gradient(135deg,rgba(59,130,246,.3),rgba(59,130,246,.15));border-color:rgba(59,130,246,.5);box-shadow:inset 0 0 8px rgba(59,130,246,.2)}
  .cell.hit{background:linear-gradient(135deg,rgba(239,68,68,.4),rgba(239,68,68,.25));border-color:rgba(239,68,68,.7)}
  .cell.hit::after{content:'üí•';position:absolute;font-size:20px;animation:boom .6s ease-out}
  .cell.miss{background:rgba(71,85,105,.3);border-color:rgba(71,85,105,.5)}
  .cell.miss::after{content:'üíß';position:absolute;font-size:16px;opacity:.7}
  .cell.your-hit{background:linear-gradient(135deg,rgba(34,197,94,.4),rgba(34,197,94,.25));border-color:rgba(34,197,94,.7);box-shadow:inset 0 0 8px rgba(34,197,94,.3)}
  .cell.your-hit::after{content:'üéØ';font-size:18px}
  .cell.your-miss{background:rgba(100,116,139,.25);border-color:rgba(100,116,139,.4)}
  .cell.your-miss::after{content:'‚ùå';font-size:14px;opacity:.5}
  .cell.preview-ok{outline:2px dashed var(--ok);background:rgba(34,197,94,.15);animation:pulse 1s infinite}
  .cell.preview-bad{outline:2px dashed var(--bad);background:rgba(239,68,68,.15)}
  
  /* Scan effect */
  .cell.scan-glow{box-shadow:0 0 16px var(--scan),inset 0 0 16px rgba(139,92,246,.4);border-color:var(--scan);animation:scanPulse 1.5s ease-in-out;z-index:1}
  .cell.scan-reveal{background:radial-gradient(circle,rgba(139,92,246,.6),rgba(139,92,246,.2));border-color:var(--scan);animation:reveal 1.2s ease-out}
  
  /* Target cursor effect */
  .target-cursor{position:absolute;width:60px;height:60px;border:3px solid var(--bad);border-radius:50%;pointer-events:none;z-index:5;opacity:0;transition:all .3s;box-shadow:0 0 20px var(--bad),inset 0 0 20px rgba(239,68,68,.3)}
  .target-cursor.show{opacity:1;animation:targeting 1s ease-in-out}
  .target-cursor::before,.target-cursor::after{content:'';position:absolute;background:var(--bad);box-shadow:0 0 8px var(--bad)}
  .target-cursor::before{width:40px;height:2px;top:50%;left:50%;transform:translate(-50%,-50%)}
  .target-cursor::after{width:2px;height:40px;top:50%;left:50%;transform:translate(-50%,-50%)}
  
  @keyframes targeting{
    0%{transform:scale(2) rotate(0deg);opacity:0}
    50%{transform:scale(1.2) rotate(180deg);opacity:1}
    100%{transform:scale(1) rotate(360deg);opacity:1}
  }
  
  @keyframes boom{
    0%{transform:scale(0) rotate(0deg);opacity:1}
    50%{transform:scale(1.5) rotate(180deg);opacity:1}
    100%{transform:scale(1) rotate(360deg);opacity:1}
  }
  
  @keyframes scanPulse{
    0%,100%{box-shadow:0 0 8px var(--scan),inset 0 0 8px rgba(139,92,246,.2)}
    50%{box-shadow:0 0 24px var(--scan),inset 0 0 20px rgba(139,92,246,.6)}
  }
  
  @keyframes reveal{
    0%{background:radial-gradient(circle,rgba(139,92,246,.8),rgba(139,92,246,.4));transform:scale(1.1)}
    100%{background:radial-gradient(circle,rgba(139,92,246,.3),rgba(139,92,246,.1));transform:scale(1)}
  }
  
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:.7}
  }
  
  /* Sidebar */
  .sidebar{background:rgba(15,20,35,.7);border:1px solid rgba(255,255,255,.1);border-radius:12px;display:flex;flex-direction:column;overflow:hidden}
  .sidebar-header{padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);font-weight:800;font-size:13px}
  .units-list{flex:1;padding:10px;overflow-y:auto;display:grid;grid-template-columns:repeat(2,1fr);gap:10px;align-content:start}
  .unit-card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.1);border-radius:8px;cursor:pointer;transition:all .2s;overflow:hidden;display:flex;flex-direction:column}
  .unit-card:hover{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.2);transform:translateY(-2px)}
  .unit-card.active{border-color:var(--surv);background:rgba(59,130,246,.15);box-shadow:0 0 8px rgba(59,130,246,.3)}
  .unit-card.placed{opacity:.5;cursor:not-allowed}
  .unit-thumb{width:100%;height:100px;background:rgba(255,255,255,.03) center/cover no-repeat;border-bottom:1px solid rgba(255,255,255,.08);position:relative}
  .unit-thumb.loading::after{content:'‚è≥';position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:24px;background:rgba(0,0,0,.3)}
  .unit-info{padding:8px 10px}
  .unit-name{font-weight:700;font-size:12px;margin-bottom:3px}
  .unit-meta{font-size:10px;color:var(--muted);margin-bottom:4px}
  .unit-status{display:inline-block;padding:2px 6px;border-radius:4px;font-size:9px;font-weight:700;margin-top:2px}
  .unit-status.ready{background:rgba(34,197,94,.2);color:var(--ok)}
  .unit-status.placed{background:rgba(100,116,139,.2);color:var(--muted)}
  
  /* Actions */
  .actions{padding:10px;border-top:1px solid rgba(255,255,255,.08);display:flex;flex-direction:column;gap:6px}
  .btn{padding:10px;border:none;border-radius:8px;font-weight:700;font-size:12px;cursor:pointer;transition:all .15s;color:white;text-transform:uppercase;letter-spacing:.3px}
  .btn:disabled{opacity:.35;cursor:not-allowed;transform:none!important}
  .btn-primary{background:linear-gradient(135deg,#3b82f6,#2563eb);box-shadow:0 4px 12px rgba(59,130,246,.3)}
  .btn-primary:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 16px rgba(59,130,246,.4)}
  .btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);box-shadow:0 4px 12px rgba(239,68,68,.3)}
  .btn-danger:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 16px rgba(239,68,68,.4)}
  .btn-ghost{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);color:var(--ink)}
  .btn-ghost:hover:not(:disabled){background:rgba(255,255,255,.12)}
  .btn.active{box-shadow:0 0 0 2px var(--surv),0 4px 12px rgba(59,130,246,.5)!important}
  
  /* Bottom log */
  .log-area{height:60px;background:rgba(15,20,35,.95);border-top:1px solid rgba(255,255,255,.08);padding:8px 24px;overflow-y:auto;font-size:12px;display:flex;flex-direction:column-reverse}
  .log-entry{padding:3px 0;color:var(--muted);line-height:1.4}
  .log-entry.important{color:var(--ink);font-weight:700}
  .log-entry.hit{color:var(--ok)}
  .log-entry.miss{color:var(--muted)}
  
  /* Modals Base */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.85);display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .3s;z-index:200}
  .modal.show{opacity:1;pointer-events:all}
  .modal-content{background:var(--panel);border:2px solid rgba(255,255,255,.2);border-radius:16px;padding:40px;text-align:center;max-width:500px;box-shadow:0 20px 60px rgba(0,0,0,.7);position:relative}
  .modal-title{font-size:36px;font-weight:800;margin-bottom:12px;text-transform:uppercase;letter-spacing:1px}
  .modal-message{font-size:16px;color:var(--muted);margin-bottom:24px}
  .modal-score{font-size:56px;font-weight:800;color:var(--surv);margin-bottom:28px}
  
  /* Action Popup */
  .action-popup{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0);background:linear-gradient(135deg,rgba(239,68,68,.95),rgba(220,38,38,.95));border:3px solid var(--bad);border-radius:20px;padding:40px 60px;box-shadow:0 0 40px rgba(239,68,68,.6),0 20px 60px rgba(0,0,0,.8);z-index:300;opacity:0;transition:all .4s cubic-bezier(0.68, -0.55, 0.265, 1.55);cursor:pointer}
  .action-popup.show{opacity:1;transform:translate(-50%,-50%) scale(1)}
  .action-popup-title{font-size:48px;font-weight:900;font-family:Orbitron,sans-serif;text-transform:uppercase;letter-spacing:2px;text-shadow:0 0 20px rgba(0,0,0,.8);margin-bottom:12px;animation:glow 1.5s ease-in-out infinite}
  .action-popup-subtitle{font-size:20px;font-weight:700;opacity:.9}
  .action-popup-hint{font-size:12px;margin-top:16px;opacity:.6;font-style:italic}
  @keyframes glow{
    0%,100%{text-shadow:0 0 20px rgba(255,255,255,.5)}
    50%{text-shadow:0 0 30px rgba(255,255,255,.9),0 0 40px rgba(255,255,255,.5)}
  }
  
  /* Intro Story Modal */
  .intro-modal{position:fixed;inset:0;background:radial-gradient(ellipse at center,rgba(0,0,0,.85) 0%,rgba(0,0,0,.98) 100%);display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity 1s;z-index:400;perspective:800px}
  .intro-modal.show{opacity:1;pointer-events:all}
  .intro-content{width:80%;max-width:800px;height:70vh;overflow:hidden;position:relative}
  .intro-text{font-family:Orbitron,sans-serif;font-size:28px;line-height:1.8;color:#ffd700;text-align:center;text-shadow:0 0 10px rgba(255,215,0,.5);position:absolute;bottom:0;left:0;right:0;animation:scroll 30s linear forwards;transform-origin:50% 100%;transform:perspective(800px) rotateX(10deg)}
  @keyframes scroll{
    0%{bottom:-100%}
    100%{bottom:100%}
  }
  .intro-skip{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);padding:10px 24px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.3);border-radius:8px;color:white;cursor:pointer;font-size:12px;transition:all .2s}
  .intro-skip:hover{background:rgba(255,255,255,.2);transform:translateX(-50%) translateY(-2px)}
  
  /* Enemy Fleet Modal */
  .fleet-modal .modal-content{max-width:600px;max-height:80vh;overflow-y:auto}
  .fleet-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:20px}
  .fleet-ship{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.1);border-radius:8px;overflow:hidden}
  .fleet-ship.destroyed{opacity:.6;border-color:var(--bad)}
  .fleet-ship.destroyed .fleet-thumb{filter:grayscale(1) brightness(.5)}
  .fleet-thumb{width:100%;height:120px;background:rgba(255,255,255,.03) center/cover no-repeat;border-bottom:1px solid rgba(255,255,255,.08)}
  .fleet-info{padding:10px}
  .fleet-name{font-weight:700;font-size:14px;margin-bottom:6px}
  .fleet-status{font-size:11px;padding:4px 8px;border-radius:4px;display:inline-block}
  .fleet-status.active{background:rgba(34,197,94,.2);color:var(--ok)}
  .fleet-status.destroyed{background:rgba(239,68,68,.2);color:var(--bad)}
  .fleet-hp{font-size:12px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
<div class="app">
  <!-- Top Bar -->
  <div class="topbar">
    <div class="logo">‚ö° TACTICAL GRID COMBAT</div>
    <div class="faction-pick">
      <button class="faction-btn active" data-faction="survivors">üõ°Ô∏è Survivors</button>
      <button class="faction-btn" data-faction="ai">ü§ñ AI Forces</button>
    </div>
    <div class="spacer"></div>
    <div class="score-panel">
      <div class="stat">
        <div class="label">You</div>
        <div class="value" id="playerScore">0</div>
      </div>
      <div class="stat" id="enemyFleetBtn" title="View enemy fleet">
        <div class="label">Enemy</div>
        <div class="value" id="enemyScore">0</div>
      </div>
      <div class="stat">
        <div class="label">AP</div>
        <div class="ap-display">
          <div class="ap-pip" id="ap1"></div>
          <div class="ap-pip" id="ap2"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- AI Thinking Overlay -->
  <div class="ai-overlay" id="aiOverlay">
    <div class="ai-title">ü§ñ ENEMY AI COMPUTING</div>
    <div class="ai-steps">
      <div class="ai-step" id="step1"><span class="icon">üîç</span><span class="text">Analyzing</span></div>
      <div class="ai-step" id="step2"><span class="icon">üéØ</span><span class="text">Targeting</span></div>
      <div class="ai-step" id="step3"><span class="icon">‚ö°</span><span class="text">Executing</span></div>
    </div>
    <div class="ai-action-log" id="aiActionLog">Scanning battlefield...</div>
  </div>

  <!-- Main Game Area -->
  <div class="main">
    <div class="board-wrap">
      <div class="board-header">
        <span id="boardTitle">YOUR GRID</span>
        <span class="phase-label" id="phaseLabel">Select faction to begin</span>
      </div>
      <div class="grid-container">
        <div class="grid" id="grid"></div>
        <div class="target-cursor" id="targetCursor"></div>
      </div>
    </div>

    <div class="sidebar">
      <div class="sidebar-header">UNITS & ACTIONS</div>
      <div class="units-list" id="unitsList"></div>
      <div class="actions">
        <button class="btn btn-danger" id="attackBtn" disabled>üéØ ATTACK</button>
        <button class="btn btn-primary" id="scanBtn" disabled>üì° SCAN (1 AP)</button>
        <button class="btn btn-ghost" id="endTurnBtn" disabled>‚è≠Ô∏è END TURN</button>
        <button class="btn btn-ghost" id="resetBtn">üîÑ NEW GAME</button>
      </div>
    </div>
  </div>

  <!-- Log Area -->
  <div class="log-area" id="log"></div>

  <!-- Intro Story Modal -->
  <div class="intro-modal" id="introModal">
    <div class="intro-content">
      <div class="intro-text" id="introText">
        THE YEAR IS 2087<br><br>
        
        The world has changed...<br><br>
        
        After the Great Collapse, civilization fractured into scattered enclaves.<br><br>
        
        The SURVIVORS fight to reclaim what was lost,<br>
        using salvaged technology and makeshift weapons.<br><br>
        
        But they are not alone...<br><br>
        
        The ROGUE AI, born from military networks,<br>
        now commands autonomous war machines<br>
        that hunt the remaining humans.<br><br>
        
        This is the FINAL CONFLICT<br><br>
        
        Choose your side.<br>
        Destroy the enemy fleet.<br>
        Survive.<br><br>
        
        ‚ö° TACTICAL GRID COMBAT ‚ö°
      </div>
    </div>
    <button class="intro-skip" onclick="skipIntro()">SKIP INTRO</button>
  </div>

  <!-- Game Over Modal -->
  <div class="modal" id="gameOverModal">
    <div class="modal-content">
      <div class="modal-title" id="modalTitle">VICTORY!</div>
      <div class="modal-message" id="modalMessage">You destroyed the enemy fleet!</div>
      <div class="modal-score" id="modalScore">750</div>
      <button class="btn btn-primary" onclick="resetGame()">PLAY AGAIN</button>
    </div>
  </div>

  <!-- Enemy Fleet Modal -->
  <div class="modal fleet-modal" id="fleetModal">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="modal-title">üéØ ENEMY FLEET</div>
      <div class="modal-message">Track enemy ship status</div>
      <div class="fleet-grid" id="fleetGrid"></div>
      <button class="btn btn-ghost" onclick="closeFleetModal()" style="margin-top:20px">CLOSE</button>
    </div>
  </div>

  <!-- Action Popup -->
  <div class="action-popup" id="actionPopup">
    <div class="action-popup-title" id="actionPopupTitle">SHIP DESTROYED!</div>
    <div class="action-popup-subtitle" id="actionPopupSubtitle">Enemy Destroyer</div>
    <div class="action-popup-hint">Click to continue</div>
  </div>
</div>

<script>
// ============ CONFIG ============
const CFG = {
  BOARD_SIZE: 10,
  AP_PER_TURN: 2,
  AI_THINK_TIME: 800,
  AI_STEP_TIME: 700,
  ANIMATION_TIME: 900,
  SCAN_DURATION: 1500,
  POINTS: { HIT: 10, SINK: 50, WIN: 200 },
  POLLINATIONS_URL: "https://text.pollinations.ai/openai",
  POLLINATIONS_IMAGE: "https://image.pollinations.ai/prompt/",
  IMAGE_RETRY_DELAY: 3000,
  IMAGE_MAX_RETRIES: 3,
  IMAGE_PROMPTS: {
    destroyer: "sleek military destroyer ship, tactical grid HUD, neon blue lights, cinematic warfare, 16:9",
    cruiser: "armored cruiser warship, advanced radar systems, neon blue HUD, dramatic lighting, epic scale, 16:9",
    battleship: "massive battleship with heavy artillery, tactical command interface, neon blue accents, cinematic, 16:9",
    carrier: "aircraft carrier flagship, flight deck operations, neon blue holographic displays, epic scale, wide shot, 16:9"
  }
};

// ============ UNIT DEFINITIONS ============
const UNITS = {
  DESTROYER: { id: 'destroyer', size: 2, count: 2, name: 'Destroyer' },
  CRUISER: { id: 'cruiser', size: 3, count: 2, name: 'Cruiser' },
  BATTLESHIP: { id: 'battleship', size: 4, count: 1, name: 'Battleship' },
  CARRIER: { id: 'carrier', size: 5, count: 1, name: 'Carrier' }
};

// ============ IMAGE CACHE ============
const imageCache = {};
const imageRetries = {};

// ============ GAME STATE ============
const state = {
  phase: 'intro',
  playerFaction: 'survivors',
  currentTurn: 'player',
  ap: CFG.AP_PER_TURN,
  playerScore: 0,
  enemyScore: 0,
  selectedAction: 'attack',
  placingUnit: null,
  placingRotation: false,
  
  playerBoard: createBoard(),
  enemyBoard: createBoard(),
  playerKnowledge: createBoard(),
  
  playerUnits: [],
  enemyUnits: [],
  playerUnitsToPlace: [],
  placedCount: 0
};

// ============ HELPERS ============
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

function createBoard() {
  const board = [];
  for (let y = 0; y < CFG.BOARD_SIZE; y++) {
    board[y] = [];
    for (let x = 0; x < CFG.BOARD_SIZE; x++) {
      board[y][x] = { ship: null, hit: false, miss: false };
    }
  }
  return board;
}

function log(message, type = 'normal') {
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  if (type === 'important') entry.classList.add('important');
  if (type === 'hit') entry.classList.add('hit');
  if (type === 'miss') entry.classList.add('miss');
  entry.textContent = '‚Ä¢ ' + message;
  $('#log').prepend(entry);
  
  const logs = $$('.log-entry');
  if (logs.length > 50) logs[logs.length - 1].remove();
}

function cellIndex(x, y) {
  return y * CFG.BOARD_SIZE + x;
}

function getCellElement(x, y) {
  return $('#grid').children[cellIndex(x, y)];
}

function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

// ============ IMAGE HANDLING WITH RETRY ============
function getImageURL(unitType) {
  const baseType = unitType.split('_')[0];
  const prompt = CFG.IMAGE_PROMPTS[baseType] || CFG.IMAGE_PROMPTS.destroyer;
  const encoded = encodeURIComponent(prompt);
  return `${CFG.POLLINATIONS_IMAGE}${encoded}?width=1280&height=720&model=flux&seed=${baseType.charCodeAt(0) * 42}&nologo=true`;
}

function preloadImage(unitType) {
  const baseType = unitType.split('_')[0];
  if (imageCache[baseType]) return Promise.resolve(imageCache[baseType]);
  
  return new Promise((resolve) => {
    const url = getImageURL(baseType);
    const img = new Image();
    let retryCount = 0;
    
    const tryLoad = () => {
      img.onload = () => {
        imageCache[baseType] = url;
        resolve(url);
      };
      
      img.onerror = () => {
        retryCount++;
        if (retryCount < CFG.IMAGE_MAX_RETRIES) {
          setTimeout(tryLoad, CFG.IMAGE_RETRY_DELAY);
        } else {
          // Fallback: resolve with URL anyway (will show loading state)
          resolve(url);
        }
      };
      
      img.src = url;
    };
    
    tryLoad();
  });
}

async function preloadAllImages() {
  const types = Object.keys(CFG.IMAGE_PROMPTS);
  const promises = types.map(type => preloadImage(type));
  await Promise.all(promises);
}

// ============ ACTION POPUP ============
function showActionPopup(title, subtitle) {
  const popup = $('#actionPopup');
  $('#actionPopupTitle').textContent = title;
  $('#actionPopupSubtitle').textContent = subtitle;
  popup.classList.add('show');
  
  const dismiss = () => {
    popup.classList.remove('show');
    popup.removeEventListener('click', dismiss);
    document.removeEventListener('click', dismiss);
  };
  
  setTimeout(() => {
    popup.addEventListener('click', dismiss);
    document.addEventListener('click', dismiss);
  }, 100);
}

// ============ INTRO STORY ============
function showIntro() {
  $('#introModal').classList.add('show');
  setTimeout(() => {
    skipIntro();
  }, 32000); // Auto-skip after story
}

function skipIntro() {
  $('#introModal').classList.remove('show');
  state.phase = 'faction_select';
  updateUI();
}

// ============ FLEET MODAL ============
function showFleetModal() {
  const grid = $('#fleetGrid');
  grid.innerHTML = '';
  
  state.enemyUnits.forEach(unit => {
    const baseType = unit.id.split('_')[0];
    const imageUrl = imageCache[baseType] || getImageURL(baseType);
    const destroyed = unit.hp <= 0;
    
    const card = document.createElement('div');
    card.className = 'fleet-ship' + (destroyed ? ' destroyed' : '');
    card.innerHTML = `
      <div class="fleet-thumb" style="background-image:url('${imageUrl}')"></div>
      <div class="fleet-info">
        <div class="fleet-name">${unit.name}</div>
        <div class="fleet-status ${destroyed ? 'destroyed' : 'active'}">
          ${destroyed ? 'üíÄ DESTROYED' : '‚ö° ACTIVE'}
        </div>
        <div class="fleet-hp">HP: ${unit.hp}/${unit.size}</div>
      </div>
    `;
    grid.appendChild(card);
  });
  
  $('#fleetModal').classList.add('show');
}

function closeFleetModal() {
  $('#fleetModal').classList.remove('show');
}

$('#enemyFleetBtn').onclick = () => {
  if (state.phase === 'battle') showFleetModal();
};

$('#fleetModal').onclick = (e) => {
  if (e.target.id === 'fleetModal') closeFleetModal();
};

function updateUI() {
  $('#playerScore').textContent = state.playerScore;
  $('#enemyScore').textContent = state.enemyScore;
  
  $('#ap1').classList.toggle('active', state.ap >= 1);
  $('#ap2').classList.toggle('active', state.ap >= 2);
  
  const inBattle = state.phase === 'battle';
  const playerTurn = state.currentTurn === 'player';
  
  $('#attackBtn').disabled = !inBattle || !playerTurn || state.ap < 1;
  $('#scanBtn').disabled = !inBattle || !playerTurn || state.ap < 1;
  $('#endTurnBtn').disabled = !inBattle || !playerTurn;
  
  $('#attackBtn').classList.toggle('active', state.selectedAction === 'attack');
  $('#scanBtn').classList.toggle('active', state.selectedAction === 'scan');
  
  if (state.phase === 'placement') {
    $('#phaseLabel').textContent = `Place units (${state.placedCount}/${state.playerUnitsToPlace.length})`;
    $('#boardTitle').textContent = 'YOUR GRID - PLACEMENT';
  } else if (state.phase === 'battle') {
    $('#phaseLabel').textContent = playerTurn ? 'üéÆ Your turn' : 'ü§ñ AI attacking...';
    $('#boardTitle').textContent = 'YOUR GRID - BATTLE';
  }
}

// ============ BOARD RENDERING ============
function renderGrid() {
  const grid = $('#grid');
  grid.innerHTML = '';
  
  for (let y = 0; y < CFG.BOARD_SIZE; y++) {
    for (let x = 0; x < CFG.BOARD_SIZE; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x;
      cell.dataset.y = y;
      
      const playerCell = state.playerBoard[y][x];
      const knowledgeCell = state.playerKnowledge[y][x];
      
      if (playerCell.ship) cell.classList.add('ship');
      if (playerCell.hit) cell.classList.add('hit');
      else if (playerCell.miss) cell.classList.add('miss');
      
      if (knowledgeCell.hit) cell.classList.add('your-hit');
      else if (knowledgeCell.miss) cell.classList.add('your-miss');
      
      grid.appendChild(cell);
    }
  }
}

function renderUnits() {
  const list = $('#unitsList');
  list.innerHTML = '';
  
  if (state.phase === 'placement') {
    state.playerUnitsToPlace.forEach((unit, idx) => {
      const card = document.createElement('div');
      card.className = 'unit-card';
      if (unit.placed) card.classList.add('placed');
      if (state.placingUnit === idx) card.classList.add('active');
      
      const baseType = unit.id.split('_')[0];
      const imageUrl = imageCache[baseType] || getImageURL(baseType);
      const loading = !imageCache[baseType];
      
      card.innerHTML = `
        <div class="unit-thumb ${loading ? 'loading' : ''}" style="background-image:url('${imageUrl}')"></div>
        <div class="unit-info">
          <div class="unit-name">${unit.name}</div>
          <div class="unit-meta">Size: ${unit.size} cells</div>
          <div class="unit-status ${unit.placed ? 'placed' : 'ready'}">${unit.placed ? '‚úì PLACED' : '‚óã READY'}</div>
        </div>
      `;
      
      if (!unit.placed) {
        card.onclick = () => {
          state.placingUnit = idx;
          renderUnits();
          log(`${unit.name} selected. Click grid to place (R to rotate)`, 'important');
        };
      }
      
      list.appendChild(card);
    });
  } else if (state.phase === 'battle') {
    const alive = state.playerUnits.filter(u => u.hp > 0);
    alive.forEach(unit => {
      const card = document.createElement('div');
      card.className = 'unit-card placed';
      const hpPercent = (unit.hp / unit.size * 100).toFixed(0);
      const baseType = unit.id.split('_')[0];
      const imageUrl = imageCache[baseType] || getImageURL(baseType);
      
      card.innerHTML = `
        <div class="unit-thumb" style="background-image:url('${imageUrl}')"></div>
        <div class="unit-info">
          <div class="unit-name">${unit.name}</div>
          <div class="unit-meta">HP: ${unit.hp}/${unit.size} (${hpPercent}%)</div>
          <div class="unit-status ready">‚ö° ACTIVE</div>
        </div>
      `;
      list.appendChild(card);
    });
  }
}

// ============ PLACEMENT ============
function canPlaceUnit(board, unit, x, y, rotation) {
  const size = unit.size;
  for (let i = 0; i < size; i++) {
    const cx = rotation ? x : x + i;
    const cy = rotation ? y + i : y;
    if (cx < 0 || cy < 0 || cx >= CFG.BOARD_SIZE || cy >= CFG.BOARD_SIZE) return false;
    if (board[cy][cx].ship) return false;
  }
  return true;
}

function placeUnit(board, units, unit, x, y, rotation) {
  const size = unit.size;
  const coords = [];
  
  for (let i = 0; i < size; i++) {
    const cx = rotation ? x : x + i;
    const cy = rotation ? y + i : y;
    board[cy][cx].ship = unit.id;
    coords.push({ x: cx, y: cy });
  }
  
  units.push({
    id: unit.id,
    name: unit.name,
    size: unit.size,
    hp: unit.size,
    coords: coords
  });
}

// ============ COMBAT ============
function attack(board, units, x, y) {
  const cell = board[y][x];
  
  if (cell.hit || cell.miss) {
    return { valid: false, reason: 'Already attacked' };
  }
  
  if (cell.ship) {
    cell.hit = true;
    const unit = units.find(u => u.id === cell.ship);
    unit.hp--;
    const sunk = unit.hp <= 0;
    return { valid: true, hit: true, sunk, unitName: unit.name };
  } else {
    cell.miss = true;
    return { valid: true, hit: false };
  }
}

async function scan(board, x, y) {
  let count = 0;
  const cells = [];
  
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const cx = x + dx;
      const cy = y + dy;
      if (cx >= 0 && cy >= 0 && cx < CFG.BOARD_SIZE && cy < CFG.BOARD_SIZE) {
        cells.push({ x: cx, y: cy });
        if (board[cy][cx].ship && !board[cy][cx].hit) count++;
      }
    }
  }
  
  cells.forEach(c => {
    const el = getCellElement(c.x, c.y);
    el.classList.add('scan-glow');
  });
  
  await sleep(500);
  
  const reveals = cells.filter(c => board[c.y][c.x].ship && !board[c.y][c.x].hit);
  reveals.forEach(c => {
    const el = getCellElement(c.x, c.y);
    el.classList.add('scan-reveal');
  });
  
  await sleep(CFG.SCAN_DURATION);
  
  cells.forEach(c => {
    const el = getCellElement(c.x, c.y);
    el.classList.remove('scan-glow', 'scan-reveal');
  });
  
  return { count, cells };
}

async function showTargeting(x, y) {
  const cursor = $('#targetCursor');
  const cell = getCellElement(x, y);
  const rect = cell.getBoundingClientRect();
  const container = $('#grid').getBoundingClientRect();
  
  cursor.style.left = (rect.left - container.left + rect.width / 2 - 30) + 'px';
  cursor.style.top = (rect.top - container.top + rect.height / 2 - 30) + 'px';
  cursor.classList.add('show');
  
  await sleep(1000);
  cursor.classList.remove('show');
}

// ============ AI ============
async function showAIThinking() {
  $('#aiOverlay').classList.add('show');
  $('#aiActionLog').textContent = 'Scanning battlefield...';
  
  await sleep(CFG.AI_STEP_TIME);
  $('#step1').classList.add('active');
  $('#aiActionLog').textContent = 'Analyzing attack patterns...';
  
  await sleep(CFG.AI_STEP_TIME);
  $('#step2').classList.add('active');
  $('#aiActionLog').textContent = 'Selecting optimal targets...';
  
  await sleep(CFG.AI_STEP_TIME);
  $('#step3').classList.add('active');
  $('#aiActionLog').textContent = 'Preparing to strike...';
  
  await sleep(CFG.AI_STEP_TIME);
}

async function hideAIThinking() {
  $('#aiActionLog').textContent = 'Attack complete.';
  await sleep(500);
  $('#aiOverlay').classList.remove('show');
  $$('.ai-step').forEach(s => s.classList.remove('active'));
}

async function getAITargets() {
  const untargeted = [];
  for (let y = 0; y < CFG.BOARD_SIZE; y++) {
    for (let x = 0; x < CFG.BOARD_SIZE; x++) {
      const cell = state.playerBoard[y][x];
      if (!cell.hit && !cell.miss) {
        untargeted.push({ x, y });
      }
    }
  }
  
  if (untargeted.length === 0) return [];
  
  const recentHits = [];
  for (let y = 0; y < CFG.BOARD_SIZE; y++) {
    for (let x = 0; x < CFG.BOARD_SIZE; x++) {
      const cell = state.playerBoard[y][x];
      if (cell.hit && cell.ship) {
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < CFG.BOARD_SIZE && ny < CFG.BOARD_SIZE) {
            const nc = state.playerBoard[ny][nx];
            if (!nc.hit && !nc.miss) {
              recentHits.push({ x: nx, y: ny });
            }
          }
        });
      }
    }
  }
  
  const priority = recentHits.length > 0 ? recentHits.slice(0, 3) : 
                   untargeted.sort(() => Math.random() - 0.5).slice(0, 3);
  
  const prompt = `Battleship AI: Pick 2 actions from these targets:
${priority.map((t, i) => `${i+1}. (${t.x},${t.y})`).join('\n')}
${recentHits.length > 0 ? 'Strategy: Follow up hits!' : 'Strategy: Hunt mode.'}

Return JSON: [{"action":"attack","target":1},{"action":"attack","target":2}]`;

  try {
    const response = await fetch(CFG.POLLINATIONS_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: "openai",
        messages: [
          { role: "system", content: "Battleship AI. JSON only." },
          { role: "user", content: prompt }
        ]
      })
    });
    
    if (!response.ok) throw new Error('API failed');
    
    const data = await response.json();
    const text = data.choices[0].message.content.trim();
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    if (!jsonMatch) throw new Error('No JSON');
    
    const actions = JSON.parse(jsonMatch[0]);
    
    return actions.slice(0, CFG.AP_PER_TURN).map(action => ({
      type: action.action || 'attack',
      x: priority[action.target - 1]?.x ?? priority[0].x,
      y: priority[action.target - 1]?.y ?? priority[0].y
    }));
    
  } catch (err) {
    console.error('AI error:', err);
    return untargeted.sort(() => Math.random() - 0.5).slice(0, CFG.AP_PER_TURN).map(t => ({
      type: 'attack',
      x: t.x,
      y: t.y
    }));
  }
}

async function executeAITurn() {
  state.currentTurn = 'enemy';
  updateUI();
  
  await showAIThinking();
  
  const actions = await getAITargets();
  
  for (const action of actions) {
    $('#aiActionLog').textContent = `Targeting (${action.x}, ${action.y})...`;
    await showTargeting(action.x, action.y);
    
    const result = attack(state.playerBoard, state.playerUnits, action.x, action.y);
    
    if (result.valid) {
      if (result.hit) {
        state.enemyScore += CFG.POINTS.HIT;
        log(`üí• Enemy HIT your ship at (${action.x},${action.y})!`, 'important');
        if (result.sunk) {
          state.enemyScore += CFG.POINTS.SINK;
          log(`üî• Enemy DESTROYED your ${result.unitName}!`, 'important');
          showActionPopup('SHIP DESTROYED!', `Your ${result.unitName} was destroyed!`);
          await sleep(2000);
        }
      } else {
        log(`üíß Enemy missed at (${action.x},${action.y})`, 'miss');
      }
    }
    
    renderGrid();
    updateUI();
    await sleep(CFG.ANIMATION_TIME);
  }
  
  await hideAIThinking();
  
  if (checkGameOver()) return;
  
  state.currentTurn = 'player';
  state.ap = CFG.AP_PER_TURN;
  updateUI();
  log('üéÆ Your turn!', 'important');
}

// ============ GAME FLOW ============
function checkGameOver() {
  const playerAlive = state.playerUnits.filter(u => u.hp > 0).length;
  const enemyAlive = state.enemyUnits.filter(u => u.hp > 0).length;
  
  if (playerAlive === 0) {
    endGame(false, 'Enemy destroyed your fleet!');
    return true;
  }
  
  if (enemyAlive === 0) {
    endGame(true, 'You destroyed the enemy fleet!');
    return true;
  }
  
  return false;
}

function endGame(playerWon, message) {
  state.phase = 'game_over';
  
  if (playerWon) {
    state.playerScore += CFG.POINTS.WIN;
  } else {
    state.enemyScore += CFG.POINTS.WIN;
  }
  
  $('#modalTitle').textContent = playerWon ? 'üèÜ VICTORY!' : 'üíÄ DEFEAT';
  $('#modalMessage').textContent = message;
  $('#modalScore').textContent = state.playerScore;
  $('#gameOverModal').classList.add('show');
  
  updateUI();
}

// ============ EVENTS ============
$('#grid').addEventListener('click', async (e) => {
  const cell = e.target.closest('.cell');
  if (!cell) return;
  
  const x = parseInt(cell.dataset.x);
  const y = parseInt(cell.dataset.y);
  
  if (state.phase === 'placement') {
    if (state.placingUnit === null) {
      log('Select a unit first!', 'important');
      return;
    }
    
    const unit = state.playerUnitsToPlace[state.placingUnit];
    if (unit.placed) return;
    
    if (canPlaceUnit(state.playerBoard, unit, x, y, state.placingRotation)) {
      placeUnit(state.playerBoard, state.playerUnits, unit, x, y, state.placingRotation);
      unit.placed = true;
      state.placedCount++;
      state.placingUnit = null;
      
      renderGrid();
      renderUnits();
      
      if (state.placedCount === state.playerUnitsToPlace.length) {
        log('‚ö° All units placed! Battle begins!', 'important');
        await sleep(1000);
        state.phase = 'battle';
        updateUI();
      } else {
        log(`‚úì ${unit.name} placed!`, 'important');
      }
    } else {
      log('‚ùå Cannot place there!', 'important');
    }
    return;
  }
  
  if (state.phase === 'battle' && state.currentTurn === 'player' && state.ap > 0) {
    if (state.selectedAction === 'attack') {
      await showTargeting(x, y);
      
      const result = attack(state.enemyBoard, state.enemyUnits, x, y);
      
      if (!result.valid) {
        log('‚ö†Ô∏è ' + result.reason, 'important');
        return;
      }
      
      state.ap--;
      state.playerKnowledge[y][x].hit = result.hit;
      state.playerKnowledge[y][x].miss = !result.hit;
      
      if (result.hit) {
        state.playerScore += CFG.POINTS.HIT;
        log(`üéØ DIRECT HIT at (${x},${y})!`, 'hit');
        if (result.sunk) {
          state.playerScore += CFG.POINTS.SINK;
          log(`üî• DESTROYED enemy ${result.unitName}!`, 'hit');
          showActionPopup('üî• SHIP DESTROYED! üî•', `Enemy ${result.unitName}`);
        }
      } else {
        log(`üíß Miss at (${x},${y})`, 'miss');
      }
      
      renderGrid();
      updateUI();
      
      if (checkGameOver()) return;
      
      if (state.ap === 0) {
        log('‚ö†Ô∏è Out of AP. End your turn!', 'important');
      }
    } else if (state.selectedAction === 'scan') {
      const result = await scan(state.enemyBoard, x, y);
      state.ap--;
      log(`üì° Scan detected ${result.count} ship(s) nearby!`, 'important');
      updateUI();
    }
  }
});

$('#grid').addEventListener('mousemove', (e) => {
  if (state.phase !== 'placement' || state.placingUnit === null) return;
  
  const cell = e.target.closest('.cell');
  if (!cell) return;
  
  const x = parseInt(cell.dataset.x);
  const y = parseInt(cell.dataset.y);
  
  $$('.cell').forEach(c => c.classList.remove('preview-ok', 'preview-bad'));
  
  const unit = state.playerUnitsToPlace[state.placingUnit];
  if (unit.placed) return;
  
  const canPlace = canPlaceUnit(state.playerBoard, unit, x, y, state.placingRotation);
  
  for (let i = 0; i < unit.size; i++) {
    const cx = state.placingRotation ? x : x + i;
    const cy = state.placingRotation ? y + i : y;
    if (cx >= 0 && cy >= 0 && cx < CFG.BOARD_SIZE && cy < CFG.BOARD_SIZE) {
      const idx = cellIndex(cx, cy);
      $('#grid').children[idx]?.classList.add(canPlace ? 'preview-ok' : 'preview-bad');
    }
  }
});

$('#grid').addEventListener('mouseleave', () => {
  $$('.cell').forEach(c => c.classList.remove('preview-ok', 'preview-bad'));
});

$('#attackBtn').onclick = () => {
  state.selectedAction = 'attack';
  updateUI();
  log('üéØ Attack mode active!', 'important');
};

$('#scanBtn').onclick = () => {
  state.selectedAction = 'scan';
  updateUI();
  log('üì° Scan mode active!', 'important');
};

$('#endTurnBtn').onclick = () => {
  if (state.phase === 'battle' && state.currentTurn === 'player') {
    log('‚è≠Ô∏è Ending turn...', 'important');
    executeAITurn();
  }
};

$('#resetBtn').onclick = resetGame;

document.addEventListener('keydown', (e) => {
  if (e.key === 'r' || e.key === 'R') {
    if (state.phase === 'placement') {
      state.placingRotation = !state.placingRotation;
      log(`üîÑ Rotation: ${state.placingRotation ? 'VERTICAL' : 'HORIZONTAL'}`, 'important');
    }
  }
});

$$('.faction-btn').forEach(btn => {
  btn.onclick = async () => {
    if (state.phase !== 'faction_select') return;
    
    $$('.faction-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.playerFaction = btn.dataset.faction;
    
    log(`‚ö° ${state.playerFaction === 'survivors' ? 'Survivors' : 'AI Forces'} selected!`, 'important');
    
    // Preload images in background (don't wait)
    preloadAllImages();
    
    startPlacement();
  };
});

// ============ INIT ============
function startPlacement() {
  state.phase = 'placement';
  state.placedCount = 0;
  state.placingUnit = null;
  
  state.playerUnitsToPlace = [];
  Object.values(UNITS).forEach(def => {
    for (let i = 0; i < def.count; i++) {
      state.playerUnitsToPlace.push({
        ...def,
        id: `${def.id}_${i}`,
        placed: false
      });
    }
  });
  
  Object.values(UNITS).forEach(def => {
    for (let i = 0; i < def.count; i++) {
      let placed = false;
      let attempts = 0;
      while (!placed && attempts < 100) {
        const x = Math.floor(Math.random() * CFG.BOARD_SIZE);
        const y = Math.floor(Math.random() * CFG.BOARD_SIZE);
        const rot = Math.random() < 0.5;
        
        if (canPlaceUnit(state.enemyBoard, def, x, y, rot)) {
          placeUnit(state.enemyBoard, state.enemyUnits, {
            ...def,
            id: `${def.id}_enemy_${i}`
          }, x, y, rot);
          placed = true;
        }
        attempts++;
      }
    }
  });
  
  renderGrid();
  renderUnits();
  updateUI();
  log('üõ†Ô∏è Place your fleet! Select unit, then click grid.', 'important');
}

function resetGame() {
  state.phase = 'intro';
  state.playerFaction = 'survivors';
  state.currentTurn = 'player';
  state.ap = CFG.AP_PER_TURN;
  state.playerScore = 0;
  state.enemyScore = 0;
  state.selectedAction = 'attack';
  state.placingUnit = null;
  state.placingRotation = false;
  
  state.playerBoard = createBoard();
  state.enemyBoard = createBoard();
  state.playerKnowledge = createBoard();
  
  state.playerUnits = [];
  state.enemyUnits = [];
  state.playerUnitsToPlace = [];
  state.placedCount = 0;
  
  $('#gameOverModal').classList.remove('show');
  $('#log').innerHTML = '';
  
  renderGrid();
  renderUnits();
  updateUI();
  
  showIntro();
}

// Start game
showIntro();
</script>
</body>
</html>
