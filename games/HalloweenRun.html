<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Halloween Run - Side-Scroller</title>
<style>
  :root{
    --ink:#e5e7eb; --muted:#9aa3b2;
    --bg:#0b0f1a; --panel:#0f1626; --card:#141c2a;
    --h1:#f97316; --acc:#22c55e; --warn:#f59e0b; --bad:#ef4444; --lock:#64748b;
    --glow: 0 0 24px rgba(249,115,22,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background: radial-gradient(1200px 800px at 50% 20%,#121831 0%,#0b0f1a 60%,#070b14 100%); color:var(--ink); font-family: system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif; overflow:hidden}
  header{
    position:fixed; inset:16px 16px auto 16px; display:flex; align-items:center; gap:16px; z-index:2;
    background:linear-gradient(180deg, rgba(20,28,42,.9), rgba(20,28,42,.6)); padding:10px 14px; border:1px solid #1f2a44; border-radius:14px; box-shadow: var(--glow);
  }
  .title{font-weight:800; letter-spacing:.5px; display:flex; align-items:center; gap:10px}
  .title span.pump{filter:drop-shadow(0 0 8px rgba(249,115,22,.4))}
  .sub{font-size:.9rem; color:var(--muted)}
  .btn{
    background:#1a243b; border:1px solid #263150; color:var(--ink);
    padding:8px 12px; border-radius:10px; cursor:pointer; transition:.2s transform,.2s background;
  }
  .btn:hover{background:#1d2947; transform:translateY(-1px)}
  #canvas-wrap{
    position:fixed; inset:0; display:grid; place-items:center;
  }
  canvas{
    width: 100vw; height: 56.25vw; /* 16:9 */
    max-height: 100vh; max-width: 177.78vh; /* keep 16:9 */
    image-rendering: pixelated; border-radius:18px; border:1px solid #1b2744;
    background: #0b0f1a;
    box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 80px rgba(16,23,45,.6);
  }
  footer{
    position:fixed; inset:auto 16px 16px 16px; display:flex; justify-content:space-between; align-items:center; gap:12px; z-index:2;
    background:linear-gradient(0deg, rgba(20,28,42,.9), rgba(20,28,42,.6)); padding:8px 12px; border:1px solid #1f2a44; border-radius:12px;
  }
  .hint{font-size:.9rem; color:var(--muted)}
  .pill{padding:4px 8px; border-radius:999px; border:1px solid #28365c; background:#111a31; color:#c7d2fe}
  .stat{display:inline-flex; align-items:center; gap:6px; margin-right:8px}
  .stat i{font-style:normal; font-weight:700}
</style>
</head>
<body>
  <header>
    <div class="title">
      <span class="pump">üéÉ</span>
      <span>Halloween Run</span>
    </div>
    <div class="sub">Map ‚Üí Encounter ‚Üí Unlock the route. Win treats, dodge tricks.</div>
    <button id="btnReset" class="btn" title="Reset progress">Reset Progress</button>
    <button id="btnMap" class="btn" title="Back to map">Map</button>
  </header>

  <div id="canvas-wrap">
    <canvas id="game" width="1280" height="720" aria-label="Halloween Run Game Area"></canvas>
  </div>

  <footer>
    <div class="hint">
      <span class="pill">A / D or ‚óÄ ‚ñ∂ move</span>
      <span class="pill">Space jump</span>
      <span class="pill">F throw</span>
      <span class="pill">Click node to start</span>
    </div>
    <div id="hud">
      <span class="stat">‚ù§Ô∏è <i id="hp">100</i></span>
      <span class="stat">üç¨ <i id="candy">0</i></span>
      <span class="stat">üó∫Ô∏è <i id="route">0/0</i></span>
    </div>
  </footer>

<script>
(() => {
  "use strict";

  // --- Persistent progress ---
  const SAVE_KEY = "halloween_run_progress_v1";
  const defaultProgress = () => ({
    completed: [false,false,false,false,false],
    unlocked: 1, // first node unlocked
    candy: 0
  });
  let progress = loadProgress();

  function saveProgress(){ localStorage.setItem(SAVE_KEY, JSON.stringify(progress)); }
  function loadProgress(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return defaultProgress();
      const p = JSON.parse(raw);
      if(!p.completed || !Array.isArray(p.completed) || typeof p.unlocked!=="number") return defaultProgress();
      return p;
    }catch(e){ return defaultProgress(); }
  }

  // --- Canvas & context ---
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // --- HUD elements ---
  const hudHP = document.getElementById("hp");
  const hudCandy = document.getElementById("candy");
  const hudRoute = document.getElementById("route");

  document.getElementById("btnReset").addEventListener("click", () => {
    progress = defaultProgress();
    saveProgress();
    state = "map";
  });
  document.getElementById("btnMap").addEventListener("click", () => {
    state = "map";
  });

  // --- Game State ---
  let state = "map"; // 'map' | 'level' | 'win' | 'lose'
  let currentLevelIndex = -1;

  // --- Input ---
  const keys = {left:false, right:false, jump:false, throw:false};
  addEventListener("keydown", e=>{
    if(e.repeat) return;
    if(e.code==="ArrowLeft" || e.code==="KeyA") keys.left=true;
    if(e.code==="ArrowRight"|| e.code==="KeyD") keys.right=true;
    if(e.code==="Space") { keys.jump=true; e.preventDefault(); }
    if(e.code==="KeyF") keys.throw=true;
  });
  addEventListener("keyup", e=>{
    if(e.code==="ArrowLeft" || e.code==="KeyA") keys.left=false;
    if(e.code==="ArrowRight"|| e.code==="KeyD") keys.right=false;
    if(e.code==="Space") keys.jump=false;
    if(e.code==="KeyF") keys.throw=false;
  });

  // --- Utility ---
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a + Math.random()*(b-a);
  const irand = (a,b)=> (a + Math.floor(Math.random()*(b-a+1)));
  const now = ()=> performance.now();

  // --- Map definition (positions in 1280x720 coords) ---
  const mapNodes = [
    { x:220, y:420, name:"Pumpkin Patch", hint:"Learn to move, avoid a scarecrow.", color:"#f97316" },
    { x:430, y:300, name:"Whispering Woods", hint:"More platforms, a bat patrol.", color:"#fb923c" },
    { x:650, y:380, name:"Haunted Bridge", hint:"Long gap, time the jumps.", color:"#f59e0b" },
    { x:880, y:320, name:"Graveyard", hint:"Two foes. Use throws.", color:"#eab308" },
    { x:1080,y:430, name:"Witch‚Äôs Manor", hint:"Final run. Don‚Äôt get hexed.", color:"#d97706" },
  ];

  // --- Level generator parameters per node ---
  function levelParams(index){
    const base = {
      width: 2000 + index*150,
      platforms: 8 + index*2,
      enemyCount: 1 + (index>1?1:0) + (index>2?1:0),
      gravity: 2200,
      runSpeed: 240 + index*20,
      jumpVel: 650 + index*20,
      candyCount: 4 + index*2
    };
    return base;
  }

  // --- Map interaction ---
  canvas.addEventListener("click", (e)=>{
    if(state!=="map") return;
    const rect = canvas.getBoundingClientRect();
    const scale = canvas.width / rect.width;
    const mx = (e.clientX - rect.left) * scale;
    const my = (e.clientY - rect.top) * scale;
    for(let i=0;i<mapNodes.length;i++){
      const n = mapNodes[i];
      const r = 28;
      const dx = mx - n.x, dy = my - n.y;
      if(dx*dx+dy*dy <= r*r){
        if(i < progress.unlocked){
          startLevel(i);
        }
        break;
      }
    }
  });

  // --- Level state ---
  let level = null;

  function startLevel(index){
    currentLevelIndex = index;
    level = createLevel(index);
    state = "level";
    // init HUD
    hudHP.textContent = level.player.hp|0;
    hudCandy.textContent = progress.candy|0;
    hudRoute.textContent = `${progress.completed.filter(Boolean).length}/${mapNodes.length}`;
  }

  function createLevel(index){
    const p = levelParams(index);
    const groundY = 620;
    const platforms = [];

    // base ground segments
    for(let i=0;i<6;i++){
      const w = 260 + irand(-40, 40);
      const x = 100 + i* (w+irand(60,120));
      const y = groundY - irand(0, 120) - (index*6);
      platforms.push({x, y, w, h:16, type:"platform"});
    }

    // ensure finish platform near end
    platforms.push({x:p.width-240, y: groundY - 80 - index*10, w:240, h:16, type:"goal"});

    // sprinkle extra platforms
    const extra = p.platforms;
    for(let i=0;i<extra;i++){
      const w = irand(140, 280);
      const x = irand(220, p.width-400);
      const y = irand(240, groundY-80);
      platforms.push({x, y, w, h:14, type:"platform"});
    }

    // enemies patrol on random platforms
    const enemies = [];
    for(let i=0;i<p.enemyCount;i++){
      const plat = platforms[irand(0, platforms.length-2)];
      const span = Math.max(80, Math.min(plat.w-40, 340));
      enemies.push({
        x: plat.x + 20 + irand(0, Math.max(0, plat.w - span - 40)),
        y: plat.y - 26,
        w: 26, h: 26,
        dir: Math.random()<.5? -1:1,
        left: plat.x+10,
        right: plat.x+plat.w-span,
        speed: 60 + index*20,
        type: (index>=3 && i%2===0) ? "ghost" : "bat",
        hp: 2 + (index>=3?1:0)
      });
    }

    // candies
    const candies = [];
    for(let i=0;i<p.candyCount;i++){
      const plat = platforms[irand(0, platforms.length-1)];
      candies.push({x: plat.x + irand(20, Math.max(30, plat.w-30)), y: plat.y-12, r: 8, taken:false});
    }

    // player
    const player = {
      x: 60, y: groundY-50, w:24, h:36,
      vx:0, vy:0,
      onGround:false, facing:1,
      hp: 100,
      canThrow: true,
      throwCooldown: 0
    };

    // projectiles
    const shots = [];

    // camera
    const cam = { x:0 };

    return {
      index,
      p,
      groundY,
      platforms,
      enemies,
      candies,
      player,
      shots,
      cam,
      finished: false,
      finishX: p.width - 160
    };
  }

  // --- Physics & collision ---
  function rectsOverlap(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function updateLevel(dt){
    const L = level; if(!L) return;

    // player control
    const P = L.player;
    const speed = L.p.runSpeed;
    const maxVX = speed;
    const accel = 1800;
    const fric = 1200;

    // horizontal control
    if(keys.left){ P.vx -= accel*dt; P.facing = -1; }
    if(keys.right){ P.vx += accel*dt; P.facing = 1; }
    if(!keys.left && !keys.right){
      // friction
      if(P.vx>0){ P.vx = Math.max(0, P.vx - fric*dt); }
      if(P.vx<0){ P.vx = Math.min(0, P.vx + fric*dt); }
    }
    P.vx = clamp(P.vx, -maxVX, maxVX);

    // jump
    if(keys.jump && P.onGround){
      P.vy = -L.p.jumpVel;
      P.onGround = false;
    }

    // gravity
    P.vy += L.p.gravity * dt;

    // apply movement with simple collision against platforms
    let nextX = P.x + P.vx*dt;
    let nextY = P.y + P.vy*dt;

    // vertical collisions
    const playerBox = {x: nextX, y: nextY, w:P.w, h:P.h};
    P.onGround = false;

    // collide with every platform (cheap but fine here)
    for(const plat of L.platforms){
      const b = {x: plat.x, y: plat.y, w: plat.w, h: plat.h};
      // Check vertical collision by testing current x and projected y
      const testBox = {x: nextX, y: nextY, w:P.w, h:P.h};
      if(rectsOverlap(testBox,b)){
        if(P.vy > 0 && P.y + P.h <= b.y + 6){ // falling onto platform
          nextY = b.y - P.h; P.vy = 0; P.onGround = true;
        }else if(P.vy < 0 && P.y >= b.y + b.h - 6){ // hitting from below
          nextY = b.y + b.h; P.vy = 50;
        }
      }
    }

    // horizontal collisions (basic: keep within bounds)
    if(nextX < 0){ nextX = 0; P.vx = 0; }
    if(nextX + P.w > L.p.width){ nextX = L.p.width - P.w; P.vx = 0; }

    P.x = nextX; P.y = nextY;

    // camera follows player
    const margin = 380;
    const targetCam = clamp(P.x - margin, 0, L.p.width - canvas.width);
    L.cam.x += (targetCam - L.cam.x) * Math.min(1, dt*4);

    // enemies move
    for(const E of L.enemies){
      if(E.type==="bat"){
        E.x += E.dir * E.speed * dt;
        if(E.x < E.left || E.x > E.right) E.dir *= -1;
      }else{ // ghost floats and bobbles
        E.x += E.dir * (E.speed*.75) * dt;
        if(E.x < E.left || E.x > E.right) E.dir *= -1;
        E.y += Math.sin(now()/400 + E.x*.01) * .2;
      }
    }

    // shots update
    for(const S of L.shots){
      S.x += S.vx * dt;
      S.y += S.vy * dt;
      S.life -= dt;
      // hit enemies
      for(const E of L.enemies){
        if(!E.dead && S.x > E.x-6 && S.x < E.x+E.w+6 && S.y > E.y-6 && S.y < E.y+E.h+6){
          E.hp -= 1; S.life = 0;
          if(E.hp<=0){ E.dead = true; }
        }
      }
    }
    // remove expired shots & dead enemies
    L.shots = L.shots.filter(s=>s.life>0);
    L.enemies = L.enemies.filter(e=>!e.dead);

    // player throw
    if(keys.throw && P.canThrow){
      P.canThrow = false;
      P.throwCooldown = 0.35;
      // candy-corn projectile
      L.shots.push({
        x: P.x + P.w/2,
        y: P.y + P.h/2,
        vx: 520 * P.facing,
        vy: -40 + rand(-30,30),
        life: 1.2
      });
    }
    if(!keys.throw && P.throwCooldown<=0) P.canThrow = true;
    if(P.throwCooldown>0){
      P.throwCooldown -= dt;
      if(P.throwCooldown<0) P.throwCooldown=0;
    }

    // enemy touch damage (small grace by checking overlap bbox)
    for(const E of L.enemies){
      const ebox = {x:E.x, y:E.y, w:E.w, h:E.h};
      const pbox = {x:P.x, y:P.y, w:P.w, h:P.h};
      if(rectsOverlap(pbox, ebox)){
        P.hp -= 20*dt; // damage over time while touching
      }
    }
    if(P.hp<=0){
      state = "lose";
      return;
    }

    // candy pickup
    for(const c of L.candies){
      if(!c.taken){
        const dx = (P.x+P.w/2) - c.x;
        const dy = (P.y+P.h/2) - (c.y);
        if(dx*dx+dy*dy < 22*22){
          c.taken = true;
          progress.candy += 1;
          saveProgress();
        }
      }
    }

    // reach finish
    if(P.x > L.finishX){
      L.finished = true;
      state = "win";
      return;
    }

    // update HUD
    hudHP.textContent = P.hp.toFixed(0);
    hudCandy.textContent = progress.candy|0;
    hudRoute.textContent = `${progress.completed.filter(Boolean).length}/${mapNodes.length}`;
  }

  // --- Rendering helpers ---
  function drawBackground(camx){
    // parallax gradient sky
    const w=canvas.width,h=canvas.height;
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,"#0a1023");
    g.addColorStop(.6,"#0b132b");
    g.addColorStop(1,"#0a0f1d");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // moon
    ctx.save();
    ctx.globalAlpha = .95;
    ctx.fillStyle = "#e2e8f0";
    ctx.beginPath();
    ctx.arc(1060 - (camx*0.1)%1600, 120, 48, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // far silhouettes (parallax)
    ctx.save();
    ctx.translate(-camx*0.25, 0);
    ctx.fillStyle="#0f1a31";
    for(let i=0;i<14;i++){
      const x=i*220, h2= irand(60,140);
      ctx.fillRect(x, canvas.height-180-h2, 120, h2);
    }
    ctx.restore();
  }

  function drawPlatform(p, camx){
    ctx.fillStyle = p.type==="goal" ? "#94a3b8" : "#1f2a44";
    ctx.fillRect(Math.floor(p.x - camx), Math.floor(p.y), Math.floor(p.w), Math.floor(p.h));
    if(p.type==="goal"){
      // little lanterns
      for(let i=0;i<3;i++){
        const lx = Math.floor(p.x - camx + 20 + i*80);
        ctx.fillStyle="#1f2937";
        ctx.fillRect(lx, p.y-34, 4, 34);
        ctx.beginPath(); ctx.fillStyle="#f59e0b"; ctx.globalAlpha=.9;
        ctx.arc(lx+2, p.y-40, 8, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
      }
    }
  }

  function drawPlayer(P, camx){
    const x = Math.floor(P.x - camx), y = Math.floor(P.y);
    // body
    ctx.fillStyle="#f97316";
    ctx.fillRect(x, y, P.w, P.h);
    // eyes
    ctx.fillStyle="#111827";
    ctx.fillRect(x+5, y+10, 6, 6);
    ctx.fillRect(x+P.w-11, y+10, 6, 6);
    // hat
    ctx.fillStyle="#1e293b";
    ctx.fillRect(x-2, y-6, P.w+4, 6);
  }

  function drawEnemy(E, camx){
    const x = Math.floor(E.x - camx), y = Math.floor(E.y);
    if(E.type==="bat"){
      // bat: body + wings
      ctx.fillStyle="#6b7280";
      ctx.fillRect(x, y, E.w, E.h);
      ctx.beginPath();
      ctx.moveTo(x, y+13); ctx.lineTo(x-16, y+6); ctx.lineTo(x, y+4); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(x+E.w, y+13); ctx.lineTo(x+E.w+16, y+6); ctx.lineTo(x+E.w, y+4); ctx.fill();
      ctx.fillStyle="#111827"; ctx.fillRect(x+6, y+8, 4, 4); ctx.fillRect(x+E.w-10, y+8, 4, 4);
    }else{
      // ghost: rounded blob
      ctx.fillStyle="rgba(226,232,240,.9)";
      ctx.beginPath();
      ctx.roundRect(x, y, E.w, E.h, 8);
      ctx.fill();
      // eyes
      ctx.fillStyle="#0f172a";
      ctx.fillRect(x+6, y+10, 4, 6);
      ctx.fillRect(x+E.w-10, y+10, 4, 6);
    }
  }

  function drawCandy(C, camx){
    if(C.taken) return;
    const x = Math.floor(C.x - camx), y = Math.floor(C.y);
    // candy corn triangle
    ctx.beginPath();
    ctx.moveTo(x, y); ctx.lineTo(x+C.r, y+C.r); ctx.lineTo(x-C.r, y+C.r); ctx.closePath();
    ctx.fillStyle="#f59e0b"; ctx.fill();
    ctx.fillStyle="#fde68a"; ctx.fillRect(x-3, y+3, 6, 3);
  }

  function drawShot(S, camx){
    const x = Math.floor(S.x - camx), y = Math.floor(S.y);
    ctx.fillStyle="#f97316";
    ctx.fillRect(x-3, y-3, 6, 6);
  }

  // --- Map rendering ---
  function drawMap(){
    // background with a big web & house
    drawBackground(0);

    // title
    ctx.fillStyle="#f97316";
    ctx.font="36px system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif";
    ctx.fillText("üéÉ Halloween Map", 40, 70);

    // draw curved path
    ctx.strokeStyle="#293453";
    ctx.lineWidth=4; ctx.beginPath();
    for(let i=0;i<mapNodes.length;i++){
      const n = mapNodes[i];
      if(i===0) ctx.moveTo(n.x, n.y);
      else ctx.lineTo(n.x, n.y);
    }
    ctx.stroke();

    // nodes
    for(let i=0;i<mapNodes.length;i++){
      const n = mapNodes[i];
      const completed = !!progress.completed[i];
      const unlocked = i < progress.unlocked;

      // halo
      ctx.beginPath();
      ctx.arc(n.x, n.y, 30, 0, Math.PI*2);
      ctx.fillStyle = completed ? "rgba(34,197,94,.2)" : unlocked ? "rgba(249,115,22,.18)" : "rgba(100,116,139,.18)";
      ctx.fill();

      // node circle
      ctx.beginPath();
      ctx.arc(n.x, n.y, 20, 0, Math.PI*2);
      ctx.fillStyle = completed ? "#22c55e" : unlocked ? n.color : "#64748b";
      ctx.fill();
      ctx.lineWidth=2; ctx.strokeStyle="#0b1020"; ctx.stroke();

      // label
      ctx.fillStyle="#e5e7eb";
      ctx.font="18px system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif";
      ctx.fillText(n.name, n.x+28, n.y-6);
      ctx.fillStyle="#9aa3b2";
      ctx.font="14px system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif";
      ctx.fillText(unlocked ? n.hint : "Locked‚Ä¶ win previous", n.x+28, n.y+14);

      if(!unlocked){
        // lock icon
        ctx.fillStyle="#94a3b8";
        ctx.fillRect(n.x-6, n.y-14, 12, 10);
        ctx.fillRect(n.x-3, n.y-18, 6, 6);
      } else if(!completed){
        // subtle pulsate ring
        const t = Math.sin(performance.now()/400)*3+22;
        ctx.beginPath(); ctx.arc(n.x,n.y,t,0,Math.PI*2);
        ctx.strokeStyle="rgba(249,115,22,.35)"; ctx.lineWidth=2; ctx.stroke();
      }
    }

    // footer stats (synced)
    hudCandy.textContent = progress.candy|0;
    hudRoute.textContent = `${progress.completed.filter(Boolean).length}/${mapNodes.length}`;
  }

  // --- Win/Lose screens ---
  function drawBanner(text, sub, color){
    ctx.save();
    ctx.globalAlpha=.95;
    ctx.fillStyle="rgba(10,15,28,.9)"; ctx.fillRect(240, 240, 800, 200);
    ctx.strokeStyle="#1f2a44"; ctx.lineWidth=2; ctx.strokeRect(240,240,800,200);
    ctx.restore();

    ctx.fillStyle=color;
    ctx.font="48px system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif";
    ctx.fillText(text, 280, 320);
    ctx.fillStyle="#cbd5e1";
    ctx.font="22px system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif";
    ctx.fillText(sub, 280, 360);
    ctx.fillStyle="#94a3b8";
    ctx.fillText("Click to return to map", 280, 400);
  }

  canvas.addEventListener("mousedown", ()=>{
    if(state==="win" || state==="lose"){
      state = "map";
    }
  });

  // --- Main loop ---
  let last = now();
  function loop(){
    const t = now();
    const dt = Math.min(1/30, (t - last)/1000);
    last = t;

    if(state==="map"){
      drawMap();
    }
    else if(state==="level"){
      updateLevel(dt);
      // render level
      const L = level;
      drawBackground(L.cam.x);

      // spooky foreground fog
      ctx.save(); ctx.globalAlpha=.08;
      ctx.fillStyle="#94a3b8"; for(let i=0;i<6;i++){
        const fx = ((i*240 - (L.cam.x*.6)) % (canvas.width+260)) - 130;
        ctx.beginPath(); ctx.ellipse(fx, 560 + Math.sin(t/600 + i)*6, 220, 40, 0, 0, Math.PI*2); ctx.fill();
      } ctx.restore();

      // platforms
      for(const p of L.platforms) drawPlatform(p, L.cam.x);

      // candies
      for(const c of L.candies) drawCandy(c, L.cam.x);

      // enemies
      for(const e of L.enemies) drawEnemy(e, L.cam.x);

      // shots
      for(const s of L.shots) drawShot(s, L.cam.x);

      // finish sign
      ctx.fillStyle="#e2e8f0";
      ctx.fillRect(Math.floor(L.finishX - L.cam.x), 520, 8, 80);
      ctx.fillStyle="#f59e0b"; ctx.fillRect(Math.floor(L.finishX - L.cam.x)-18, 524, 36, 20);

      // player
      drawPlayer(L.player, L.cam.x);
    }
    else if(state==="win"){
      drawMap();
      drawBanner("You Won!", "Route unlocked. Candy +1 üéâ", "#22c55e");
    }
    else if(state==="lose"){
      drawMap();
      drawBanner("You Lost‚Ä¶", "Keep practicing your jumps.", "#ef4444");
    }

    requestAnimationFrame(loop);
  }
  loop();

  // --- Handle win/lose transitions ---
  const afterFrame = () => setTimeout(()=>{
    if(state==="win"){
      // grant candy bonus, unlock next, mark completed
      if(!progress.completed[currentLevelIndex]){
        progress.candy += 1;
        progress.completed[currentLevelIndex] = true;
        if(progress.unlocked < mapNodes.length && currentLevelIndex+1 >= progress.unlocked){
          progress.unlocked = currentLevelIndex + 2;
        }
        saveProgress();
        hudCandy.textContent = progress.candy|0;
        hudRoute.textContent = `${progress.completed.filter(Boolean).length}/${mapNodes.length}`;
      }
    }
  }, 100);

  // watch state changes to trigger rewards
  let _state = state;
  setInterval(()=>{
    if(_state!==state){
      _state = state;
      if(state==="win") afterFrame();
    }
  }, 60);

  // Accessibility: prevent space scroll on some browsers
  window.onkeydown = (e)=>{ if(e.code==="Space" && e.target===document.body) e.preventDefault(); };

})();
</script>
</body>
</html>
