<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitten Voxel</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #87CEEB;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            pointer-events: none;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.5);
        }
        
        #colorPalette {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .colorSwatch {
            width: 40px;
            height: 40px;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .colorSwatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        
        .colorSwatch.selected {
            border-color: #fff;
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #jumpHint {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div><strong>üê± Kitten Voxel</strong></div>
            <div>WASD: Move kitten</div>
            <div>Mouse: Look around</div>
            <div>SPACE: Jump</div>
            <div>Left Click: Place block</div>
            <div>Right Click: Remove block</div>
            <div>Mouse Wheel: Zoom in/out</div>
            <div>Numbers 1-6: Select color</div>
        </div>
        
        <div id="crosshair"></div>
        
        <div id="jumpHint">Press SPACE to jump! üêæ</div>
        
        <div id="colorPalette">
            <div class="colorSwatch selected" data-color="0xff4444" style="background: #ff4444;" title="Red (1)"></div>
            <div class="colorSwatch" data-color="0x44ff44" style="background: #44ff44;" title="Green (2)"></div>
            <div class="colorSwatch" data-color="0x4444ff" style="background: #4444ff;" title="Blue (3)"></div>
            <div class="colorSwatch" data-color="0xffff44" style="background: #ffff44;" title="Yellow (4)"></div>
            <div class="colorSwatch" data-color="0xff44ff" style="background: #ff44ff;" title="Magenta (5)"></div>
            <div class="colorSwatch" data-color="0x44ffff" style="background: #44ffff;" title="Cyan (6)"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class KittenVoxel {
            constructor() {
                // Initialize Three.js
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // World data
                this.worldSize = 32;
                this.world = {};
                
                // Player (kitten) properties - adjust starting height for proper feet positioning
                this.player = {
                    position: new THREE.Vector3(0, 3.3, 0), // Higher to account for feet offset
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotation: 0,
                    isGrounded: false,
                    mesh: null
                };
                
                // Camera follows player
                this.cameraOffset = new THREE.Vector3(0, 5, 8);
                this.cameraTarget = new THREE.Vector3();
                
                // Controls
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                this.isPointerLocked = false;
                this.cameraRotationY = 0;
                this.cameraRotationX = -0.3;
                
                // Selected color
                this.selectedColor = 0xff4444;
                
                // Raycaster for block selection
                this.raycaster = new THREE.Raycaster();
                this.raycaster.far = 8;
                
                // Block highlight
                this.highlightMesh = null;
                
                // Initialize everything
                this.setupLighting();
                this.createHighlightMesh();
                this.createKitten();
                this.generateTerrain();
                this.setupControls();
                this.setupColorPalette();
                this.animate();
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
            }
            
            createHighlightMesh() {
                const geometry = new THREE.BoxGeometry(1.02, 1.02, 1.02);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4,
                    wireframe: true
                });
                this.highlightMesh = new THREE.Mesh(geometry, material);
                this.highlightMesh.visible = false;
                this.scene.add(this.highlightMesh);
            }
            
            createKitten() {
                const kittenGroup = new THREE.Group();
                
                // Body (main cube)
                const bodyGeometry = new THREE.BoxGeometry(1.2, 0.8, 2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xffaa55 }); // Orange
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                body.castShadow = true;
                kittenGroup.add(body);
                
                // Head
                const headGeometry = new THREE.BoxGeometry(1, 1, 1);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffaa55 }); // Orange
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(0, 0.9, -0.8);
                head.castShadow = true;
                kittenGroup.add(head);
                
                // Ears
                const earGeometry = new THREE.ConeGeometry(0.2, 0.4, 4);
                const earMaterial = new THREE.MeshLambertMaterial({ color: 0xffaa55 });
                
                const leftEar = new THREE.Mesh(earGeometry, earMaterial);
                leftEar.position.set(-0.3, 1.4, -0.8);
                leftEar.castShadow = true;
                kittenGroup.add(leftEar);
                
                const rightEar = new THREE.Mesh(earGeometry, earMaterial);
                rightEar.position.set(0.3, 1.4, -0.8);
                rightEar.castShadow = true;
                kittenGroup.add(rightEar);
                
                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 1, -1.2);
                kittenGroup.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 1, -1.2);
                kittenGroup.add(rightEye);
                
                // Nose
                const noseGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                const noseMaterial = new THREE.MeshLambertMaterial({ color: 0xff6699 });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(0, 0.85, -1.3);
                kittenGroup.add(nose);
                
                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.6);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0xffaa55 });
                
                const positions = [
                    [-0.4, -0.7, -0.6], // Front left
                    [0.4, -0.7, -0.6],  // Front right
                    [-0.4, -0.7, 0.6],  // Back left
                    [0.4, -0.7, 0.6]    // Back right
                ];
                
                positions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.castShadow = true;
                    kittenGroup.add(leg);
                });
                
                // Tail
                const tailGeometry = new THREE.CylinderGeometry(0.1, 0.05, 1.5);
                const tailMaterial = new THREE.MeshLambertMaterial({ color: 0xffaa55 });
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.set(0, 0.5, 1.2);
                tail.rotation.x = Math.PI / 6; // Curve upward
                tail.castShadow = true;
                kittenGroup.add(tail);
                
                // Position the kitten properly - legs should touch the ground
                kittenGroup.position.copy(this.player.position);
                // Offset so the feet (bottom of legs) touch the ground, not the body center
                kittenGroup.position.y -= 0.3; // Move down so feet touch surface
                this.scene.add(kittenGroup);
                this.player.mesh = kittenGroup;
            }
            
            generateTerrain() {
                // Create a simple flat dirt world - completely empty except for a few dirt blocks
                for (let x = -5; x <= 5; x++) {
                    for (let z = -5; z <= 5; z++) {
                        this.setBlock(x, 0, z, 0x8B4513); // Brown dirt base
                    }
                }
                
                // Add just one example structure to show it's working
                this.setBlock(2, 1, 2, 0x90EE90); // One grass block to test climbing
                this.setBlock(3, 1, 2, 0x90EE90);
                this.setBlock(4, 2, 2, 0x90EE90); // Higher block to climb
            }
            
            createPyramid(centerX, baseY, centerZ, color) {
                const size = 3;
                for (let level = 0; level < size; level++) {
                    const y = baseY + level;
                    const extent = size - level - 1;
                    for (let x = -extent; x <= extent; x++) {
                        for (let z = -extent; z <= extent; z++) {
                            this.setBlock(centerX + x, y, centerZ + z, color);
                        }
                    }
                }
            }
            
            createTower(centerX, baseY, centerZ, color) {
                for (let y = baseY; y < baseY + 5; y++) {
                    this.setBlock(centerX, y, centerZ, color);
                }
            }
            
            getGroundHeight(x, z) {
                // Find the highest solid block at this x,z position
                for (let y = 20; y >= -5; y--) {
                    if (this.getBlock(x, y, z)) {
                        return y;
                    }
                }
                return -1; // No ground found
            }
            
            canStandAt(x, y, z) {
                // Check if there's a solid block to stand on and no block where the player would be
                const groundBlock = this.getBlock(Math.floor(x), Math.floor(y - 1), Math.floor(z));
                const playerBlock = this.getBlock(Math.floor(x), Math.floor(y), Math.floor(z));
                const playerHeadBlock = this.getBlock(Math.floor(x), Math.floor(y + 1), Math.floor(z));
                
                return groundBlock && !playerBlock && !playerHeadBlock;
            }
            
            isPositionInsidePlayer(x, y, z) {
                const playerPos = this.player.position;
                const dx = Math.abs(x - playerPos.x);
                const dy = Math.abs(y - playerPos.y);
                const dz = Math.abs(z - playerPos.z);
                
                // More forgiving - only block placement if block would be right inside the kitten's core
                return dx < 0.6 && dy < 1.0 && dz < 0.6;
            }
            
            getBlockKey(x, y, z) {
                return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            }
            
            setBlock(x, y, z, color) {
                const key = this.getBlockKey(x, y, z);
                
                // Remove existing block if present
                if (this.world[key]) {
                    this.scene.remove(this.world[key]);
                }
                
                if (color !== null) {
                    // Create new block
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshLambertMaterial({ color: color });
                    const cube = new THREE.Mesh(geometry, material);
                    
                    cube.position.set(x, y, z);
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                    
                    this.scene.add(cube);
                    this.world[key] = cube;
                } else {
                    // Remove block
                    delete this.world[key];
                }
            }
            
            getBlock(x, y, z) {
                const key = this.getBlockKey(x, y, z);
                return this.world[key] || null;
            }
            
            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // Number keys for color selection
                    if (e.code >= 'Digit1' && e.code <= 'Digit6') {
                        const colorIndex = parseInt(e.code.slice(-1)) - 1;
                        this.selectColor(colorIndex);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse controls - request pointer lock on click
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        const sensitivity = 0.003;
                        this.cameraRotationY -= e.movementX * sensitivity;
                        this.cameraRotationX -= e.movementY * sensitivity;
                        this.cameraRotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3, this.cameraRotationX));
                    }
                });
                
                // Mouse wheel for zoom
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    if (this.isPointerLocked) {
                        e.preventDefault();
                        const zoomSpeed = 0.5;
                        const minDistance = 3;
                        const maxDistance = 15;
                        
                        if (e.deltaY > 0) {
                            // Zoom out
                            this.cameraOffset.multiplyScalar(1 + zoomSpeed * 0.1);
                        } else {
                            // Zoom in
                            this.cameraOffset.multiplyScalar(1 - zoomSpeed * 0.1);
                        }
                        
                        // Clamp zoom distance
                        const distance = this.cameraOffset.length();
                        if (distance < minDistance) {
                            this.cameraOffset.normalize().multiplyScalar(minDistance);
                        } else if (distance > maxDistance) {
                            this.cameraOffset.normalize().multiplyScalar(maxDistance);
                        }
                    }
                });
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    if (this.isPointerLocked) {
                        e.preventDefault();
                        this.handleBlockInteraction(e.button === 0); // 0 = left, 2 = right
                    }
                });
                
                // Prevent context menu
                this.renderer.domElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupColorPalette() {
                const swatches = document.querySelectorAll('.colorSwatch');
                swatches.forEach((swatch, index) => {
                    swatch.addEventListener('click', () => {
                        this.selectColor(index);
                    });
                });
            }
            
            selectColor(index) {
                const swatches = document.querySelectorAll('.colorSwatch');
                swatches.forEach(s => s.classList.remove('selected'));
                if (swatches[index]) {
                    swatches[index].classList.add('selected');
                    this.selectedColor = parseInt(swatches[index].dataset.color);
                }
            }
            
            getTargetBlockPosition() {
                // Cast ray from camera center
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                
                // Get all block objects
                const objects = Object.values(this.world);
                const intersects = this.raycaster.intersectObjects(objects);
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const blockPos = intersect.object.position;
                    const normal = intersect.face.normal;
                    
                    // Position to place new block (adjacent to clicked face)
                    const placePos = blockPos.clone().add(normal);
                    
                    return {
                        remove: blockPos.clone(),
                        place: placePos,
                        normal: normal
                    };
                }
                return null;
            }
            
            updateBlockHighlight() {
                const targetPos = this.getTargetBlockPosition();
                
                if (targetPos) {
                    // Show highlight on the position where a new block would be placed
                    this.highlightMesh.position.copy(targetPos.place);
                    this.highlightMesh.visible = true;
                } else {
                    this.highlightMesh.visible = false;
                }
            }
            
            handleBlockInteraction(isLeftClick) {
                const targetPos = this.getTargetBlockPosition();
                if (!targetPos) return;
                
                if (isLeftClick) {
                    // Left click: Place block where highlight shows
                    const placePos = targetPos.place;
                    if (!this.getBlock(placePos.x, placePos.y, placePos.z)) {
                        // Much more forgiving placement - only prevent if block would be right inside kitten
                        if (!this.isPositionInsidePlayer(placePos.x, placePos.y, placePos.z)) {
                            this.setBlock(placePos.x, placePos.y, placePos.z, this.selectedColor);
                        }
                    }
                } else {
                    // Right click: Remove the block we're looking at
                    const removePos = targetPos.remove;
                    if (this.getBlock(removePos.x, removePos.y, removePos.z)) {
                        // Don't remove blocks directly supporting the player
                        const playerFloor = Math.floor(this.player.position.y - 1);
                        const playerX = Math.floor(this.player.position.x);
                        const playerZ = Math.floor(this.player.position.z);
                        
                        // Only prevent removal if it's the exact block the player is standing on
                        if (!(removePos.x === playerX && 
                              removePos.z === playerZ &&
                              removePos.y === playerFloor)) {
                            this.setBlock(removePos.x, removePos.y, removePos.z, null);
                        }
                    }
                }
            }
            
            updatePlayer() {
                const speed = 0.12;
                const jumpStrength = 0.35;
                const gravity = -0.015;
                const stepHeight = 1.2; // How high the kitten can step up
                
                // Apply gravity
                this.player.velocity.y += gravity;
                
                // Movement input
                const direction = new THREE.Vector3();
                if (this.keys['KeyW']) direction.z -= 1;
                if (this.keys['KeyS']) direction.z += 1;
                if (this.keys['KeyA']) direction.x -= 1;
                if (this.keys['KeyD']) direction.x += 1;
                
                // Apply camera rotation to movement direction (only Y rotation)
                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraRotationY);
                    direction.multiplyScalar(speed);
                    
                    // Rotate player to face movement direction
                    this.player.rotation = Math.atan2(direction.x, direction.z);
                }
                
                // Jumping
                if (this.keys['Space'] && this.player.isGrounded) {
                    this.player.velocity.y = jumpStrength;
                    this.player.isGrounded = false;
                }
                
                // Calculate new position
                const currentPos = this.player.position.clone();
                const newPosition = currentPos.clone();
                
                // Apply horizontal movement
                newPosition.x += direction.x;
                newPosition.z += direction.z;
                
                // Apply vertical movement (gravity/jumping)
                newPosition.y += this.player.velocity.y;
                
                // Advanced collision detection - adjust for kitten feet position
                const groundHeight = this.getGroundHeight(newPosition.x, newPosition.z);
                const targetY = groundHeight + 1.3; // Height where kitten center should be (feet on ground + body height)
                
                // Check if we can step up to a higher block
                if (direction.length() > 0) { // Only when moving horizontally
                    const currentGroundHeight = this.getGroundHeight(currentPos.x, currentPos.z);
                    
                    if (groundHeight > currentGroundHeight && 
                        groundHeight <= currentGroundHeight + stepHeight &&
                        this.canStandAt(newPosition.x, targetY, newPosition.z)) {
                        // Step up onto the block
                        newPosition.y = Math.max(newPosition.y, targetY);
                        this.player.velocity.y = 0;
                        this.player.isGrounded = true;
                    } else if (groundHeight >= 0) {
                        // Normal ground collision
                        if (newPosition.y <= targetY) {
                            newPosition.y = targetY;
                            this.player.velocity.y = 0;
                            this.player.isGrounded = true;
                        } else {
                            this.player.isGrounded = false;
                        }
                    } else {
                        // No ground found - falling into void
                        this.player.isGrounded = false;
                        if (newPosition.y < -10) {
                            // Reset to spawn if falling too far
                            newPosition.set(0, 3, 0);
                            this.player.velocity.y = 0;
                        }
                    }
                } else {
                    // Not moving horizontally, just apply gravity
                    if (groundHeight >= 0 && newPosition.y <= targetY) {
                        newPosition.y = targetY;
                        this.player.velocity.y = 0;
                        this.player.isGrounded = true;
                    } else {
                        this.player.isGrounded = false;
                    }
                }
                
                this.player.position.copy(newPosition);
                
                // Update player mesh with consistent positioning
                if (this.player.mesh) {
                    // Always position the visual mesh so feet touch the ground
                    this.player.mesh.position.copy(this.player.position);
                    this.player.mesh.position.y -= 0.3; // Consistent offset so feet always touch surface
                    this.player.mesh.rotation.y = this.player.rotation;
                    
                    // Add subtle bounce when walking (but maintain proper ground contact)
                    if (direction.length() > 0 && this.player.isGrounded) {
                        const bounce = Math.sin(Date.now() * 0.015) * 0.06; // Reduced bounce to prevent clipping
                        this.player.mesh.position.y += Math.max(0, bounce); // Only bounce upward
                    }
                }
                
                // Update camera to follow player
                this.updateCamera();
            }
            
            updateCamera() {
                // Third-person camera that follows the kitten
                const offset = this.cameraOffset.clone();
                
                // Apply camera rotations
                offset.applyAxisAngle(new THREE.Vector3(1, 0, 0), this.cameraRotationX);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraRotationY);
                
                this.camera.position.copy(this.player.position).add(offset);
                
                // Look at point slightly ahead of player
                this.cameraTarget.copy(this.player.position);
                this.cameraTarget.y += 1;
                this.camera.lookAt(this.cameraTarget);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updatePlayer();
                this.updateBlockHighlight();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the game when page loads
        window.addEventListener('load', () => {
            new KittenVoxel();
        });
    </script>
</body>
</html>