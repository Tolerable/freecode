<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Keyboard Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #1e1e1e;
            color: #f0f0f0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

		.context-menu {
			background-color: #333;
			border: 1px solid #555;
			border-radius: 4px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
			z-index: 1000;
		}

		.context-menu div {
			padding: 8px 15px;
			cursor: pointer;
		}

		.context-menu div:hover {
			background-color: #444;
		}

        /* Toolbar styles */
        .toolbar {
            background-color: #2c2c2c;
            padding: 10px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #444;
        }

        .toolbar button {
            background-color: #3c3c3c;
            color: #f0f0f0;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .toolbar button:hover {
            background-color: #4c4c4c;
        }

		.instrument-control {
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.instrument-control select {
			background-color: #3c3c3c;
			color: #f0f0f0;
			border: none;
			padding: 8px;
			border-radius: 4px;
		}

		.instrument-toolbar {
			display: flex;
			background-color: #2c2c2c;
			padding: 8px;
			gap: 8px;
			border-bottom: 1px solid #444;
		}

		.instrument-selector {
			padding: 8px 12px;
			border-radius: 4px;
			cursor: pointer;
			color: white;
			font-weight: bold;
			text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
			transition: all 0.2s ease;
			min-width: 80px;
			text-align: center;
		}

		.instrument-selector:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
		}

		.instrument-selector.active {
			outline: 2px solid white;
			box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
		}

        /* Left sidebar styles */
        .sidebar {
            width: 200px;
            background-color: #252525;
            padding: 10px;
            border-right: 1px solid #444;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 10px;
            color: #b0b0b0;
        }

        .session-item {
            padding: 8px;
            margin-bottom: 5px;
            background-color: #333;
            border-radius: 4px;
            cursor: pointer;
        }

        .session-item:hover {
            background-color: #444;
        }

		#sessions-list {
			max-height: 300px;
			overflow-y: auto;
		}

		.session-item {
			padding: 8px;
			margin: 5px;
			background-color: #333;
			border-radius: 4px;
			cursor: pointer;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.session-item:hover {
			background-color: #444;
		}

        /* Main sequencer area */
        .sequencer-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Piano keyboard styles */
        .piano-container {
            width: 80px;
            background-color: #222;
            overflow-y: auto;
            position: relative;
        }

        .piano-key {
            height: 30px;
            margin: 1px 0;
            display: flex;
            align-items: center;
            padding-left: 10px;
            position: relative;
            cursor: pointer;
        }

        .white-key {
            background-color: #f0f0f0;
            color: #222;
            border-radius: 0 4px 4px 0;
        }

        .black-key {
            background-color: #222;
            color: #f0f0f0;
            border-radius: 0 4px 4px 0;
            border: 1px solid #444;
        }

        .piano-key:hover {
            opacity: 0.8;
        }

		.sample-module {
			position: absolute;
			bottom: 50px;
			left: 50%;
			transform: translateX(-50%);
			width: 80%;
			max-width: 800px;
			background-color: #252525;
			border: 1px solid #444;
			border-radius: 8px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
			z-index: 100;
		}
		
		.sample-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 10px 15px;
			background-color: #333;
			border-bottom: 1px solid #444;
			border-radius: 8px 8px 0 0;
		}
		
		.sample-header h3 {
			margin: 0;
			color: #f0f0f0;
		}
		
		#close-samples-btn {
			background: none;
			border: none;
			color: #f0f0f0;
			font-size: 24px;
			cursor: pointer;
		}
		
		.sample-controls {
			display: flex;
			justify-content: space-between;
			padding: 10px 15px;
			background-color: #2a2a2a;
			border-bottom: 1px solid #444;
		}
		
		.sample-category select,
		.effects-panel input[type="range"] {
			background-color: #3c3c3c;
			color: #f0f0f0;
			border: none;
			padding: 5px;
			border-radius: 4px;
		}
		
		.effects-panel {
			display: flex;
			gap: 15px;
		}
		
		.effect-control {
			display: flex;
			align-items: center;
			gap: 5px;
		}
		
		.sample-pads {
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			gap: 10px;
			padding: 15px;
			max-height: 300px;
			overflow-y: auto;
		}
		
		.sample-pad {
			aspect-ratio: 1/1;
			display: flex;
			justify-content: center;
			align-items: center;
			background-color: #3c3c3c;
			border-radius: 8px;
			color: #f0f0f0;
			font-weight: bold;
			cursor: pointer;
			user-select: none;
			transition: all 0.1s ease;
			position: relative;
		}
		
		.sample-pad:hover {
			filter: brightness(1.2);
		}
		
		.sample-pad:active, .sample-pad.playing {
			transform: scale(0.95);
			filter: brightness(1.4);
		}

		.add-to-sequencer {
			position: absolute;
			bottom: 5px;
			right: 5px;
			width: 20px;
			height: 20px;
			border-radius: 50%;
			background-color: rgba(255, 255, 255, 0.3);
			color: white;
			border: none;
			font-size: 16px;
			line-height: 1;
			cursor: pointer;
			display: flex;
			justify-content: center;
			align-items: center;
			opacity: 0;
			transition: opacity 0.2s ease;
		}

		.sample-pad:hover .add-to-sequencer {
			opacity: 1;
		}

		.add-to-sequencer:hover {
			background-color: rgba(255, 255, 255, 0.5);
		}

		/* Loading indicator inside pads */
		.loading-dot {
			position: absolute;
			top: 5px;
			right: 5px;
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background-color: rgba(255, 255, 255, 0.7);
			animation: pulse 1s infinite;
		}
		
		/* Different colors for different sample categories */
		.sample-pad.drums {
			background-color: #7986CB;
		}
		
		.sample-pad.fx {
			background-color: #4DB6AC;
		}
		
		.sample-pad.synth {
			background-color: #FFB74D;
		}
		
		.sample-pad.vocals {
			background-color: #F06292;
		}

        /* Grid area styles */
		.active-grid-area {
			position: absolute;
			top: 0;
			left: 0;
			height: 100%;
			background-color: transparent; /* Changed from #1a1a1a to transparent */
			z-index: 1;
			pointer-events: none;
		}

		.inactive-grid-area {
			position: absolute;
			top: 0;
			height: 100%;
			background-color: rgba(21, 21, 21, 0.7); /* Using rgba for opacity */
			z-index: 1;
			pointer-events: none;
		}

		/* Make sure these CSS styles for the grid container are applied: */
		.grid-container {
			flex: 1;
			overflow: auto;
			position: relative;
			background-color: #1a1a1a;
			background-image: 
				linear-gradient(to right, #333 1px, transparent 1px),
				linear-gradient(to bottom, #333 1px, transparent 1px);
			background-size: 40px 32px;
		}

		/* Grid control buttons */
		.grid-controls {
			position: absolute;
			right: 10px;
			top: 10px;
			display: flex;
			gap: 5px;
			z-index: 100;
		}

		.grid-control-btn {
			padding: 5px 10px;
			background-color: #3c3c3c;
			color: #f0f0f0;
			border: none;
			border-radius: 4px;
			cursor: pointer;
		}

		.grid-control-btn:hover {
			background-color: #4c4c4c;
		}

		.grid-end-marker {
			position: absolute;
			top: 0;
			height: 100%;
			width: 2px;
			background-color: #ffcc00;
			z-index: 5;
		}

		.beat-indicator {
			position: absolute;
			top: 0;
			width: 1px;
			pointer-events: none;
		}

		.beat-indicator.measure {
			height: 15px;
			background-color: #fff;
		}

		.beat-indicator.beat {
			height: 5px;
			background-color: #666;
		}

		.beat-label {
			position: absolute;
			left: 5px;
			top: 0;
			font-size: 10px;
			color: #fff;
		}

        /* Note block styles */
        .note-block {
            position: absolute;
            height: 28px;
            background-color: #5b87ff;
            border-radius: 4px;
            cursor: move;
            user-select: none;
            opacity: 0.8;
        }

        .note-block:hover {
            opacity: 1;
        }

        .note-block .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: e-resize;
        }

        /* Playhead styles */
        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #ff5b5b;
            z-index: 10;
            pointer-events: none;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
        }

        .tempo-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

		.tracks-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 8px 10px;
			background-color: #252525;
			border-bottom: 1px solid #444;
		}

		.tracks-container {
			background-color: #252525;
			border-top: 1px solid #444;
		}

		.track-item {
			display: flex;
			align-items: center;
			padding: 6px 10px;
			margin: 3px 5px;
			background-color: #333;
			border-radius: 4px;
			cursor: pointer;
		}

		.track-item:hover {
			background-color: #444;
		}

		.track-item.active {
			border-left: 3px solid #5b87ff;
		}
		
		
		@keyframes pulse {
			0% { transform: scale(0.8); opacity: 0.5; }
			50% { transform: scale(1.2); opacity: 1; }
			100% { transform: scale(0.8); opacity: 0.5; }
		}

		/* Different colors for different sample categories */
		.sample-pad.drums {
			background-color: #7986CB;
		}

		.sample-pad.fx {
			background-color: #4DB6AC;
		}

		.sample-pad.synth {
			background-color: #FFB74D;
		}

		.sample-pad.vocals {
			background-color: #F06292;
		}

		/* Sample blocks in the sequencer */
		.note-block.sample-block {
			position: relative;
		}

		.sample-block .sample-name {
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			max-width: calc(100% - 8px);
		}

		/* Help section */
		.sample-help {
			padding: 10px 15px;
			font-size: 12px;
			color: #999;
			background-color: #222;
			border-top: 1px solid #444;
			border-radius: 0 0 8px 8px;
		}

		.sample-help p {
			margin: 5px 0;
		}		
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="controls">
            <button id="play-btn">Play</button>
            <button id="stop-btn">Stop</button>
            <div class="tempo-control">
                <label for="tempo">BPM:</label>
                <input type="number" id="tempo" min="60" max="200" value="120" style="width: 60px;">
            </div>
			<div class="instrument-control">
				<label for="instrument">Instrument:</label>
				<select id="instrument">
					<option value="sine">Sine</option>
					<option value="square">Square</option>
					<option value="sawtooth">Sawtooth</option>
					<option value="triangle">Triangle</option>
					<option value="piano">Piano</option>
				</select>
			</div>
			<button id="toggle-samples-btn">Samples</button>			
        </div>
        <button id="save-btn">Save</button>
        <button id="new-session-btn">New Session</button>
        <button id="clear-btn">Clear All</button>
    </div>

	<div class="instrument-toolbar">
		<div class="instrument-selector active" data-instrument="sine" style="background-color: #5b87ff;">
			<span>Sine</span>
		</div>
		<div class="instrument-selector" data-instrument="square" style="background-color: #ff5b87;">
			<span>Square</span>
		</div>
		<div class="instrument-selector" data-instrument="sawtooth" style="background-color: #5bff87;">
			<span>Sawtooth</span>
		</div>
		<div class="instrument-selector" data-instrument="triangle" style="background-color: #ffb75b;">
			<span>Triangle</span>
		</div>
		<div class="instrument-selector" data-instrument="piano" style="background-color: #b75bff;">
			<span>Piano</span>
		</div>
	</div>

	<div class="tooltip" style="background-color: #333; padding: 8px; margin: 5px; border-radius: 4px; font-size: 12px;">
		<p>Tips: Click grid to add notes. Right-click to delete. Drag to move. Double-click to toggle sustained/staccato mode.</p>
	</div>

    <div class="app-container">
        <div class="sidebar">
            <h3>Sessions</h3>
            <div id="sessions-list">
                <div class="session-item">New Session</div>
            </div>
        </div>

        <div class="sequencer-container">
            <div class="piano-container" id="piano-keys">
                <!-- Piano keys will be generated here -->
            </div>

            <div class="grid-container" id="grid-container">
                <div class="playhead" id="playhead"></div>
                <!-- Note blocks will be added here -->
            </div>
        </div>
    </div>

	<div id="tracks-container" class="tracks-container">
		<div class="tracks-header">
			<h3 style="margin: 0; color: #b0b0b0;">Tracks</h3>
			<button id="add-track-btn" style="padding: 4px 8px; background-color: #3c3c3c; color: #f0f0f0; border: none; border-radius: 4px; cursor: pointer;">Add Track</button>
		</div>
		<div id="tracks-list"></div>
	</div>

	<button id="emergency-reset" style="position: fixed; bottom: 10px; right: 10px; background-color: #ff5b5b; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; z-index: 9999;">Emergency Reset</button>

	<div class="sample-module" style="display: none;">
		<div class="sample-header">
			<h3>Audio Samples</h3>
			<button id="close-samples-btn">Ã—</button>
		</div>
		
		<div class="sample-controls">
			<div class="sample-category">
				<label>Category:</label>
				<select id="sample-category">
					<option value="drums">Drums</option>
					<option value="fx">FX</option>
					<option value="synth">Synth</option>
					<option value="vocals">Vocals</option>
				</select>
			</div>
			
			<div class="effects-panel">
				<div class="effect-control">
					<label>Reverb:</label>
					<input type="range" id="reverb-amount" min="0" max="100" value="30">
				</div>
				<div class="effect-control">
					<label>Delay:</label>
					<input type="range" id="delay-amount" min="0" max="100" value="0">
				</div>
			</div>
		</div>
		
		<div id="sample-pads" class="sample-pads">
			<!-- Sample pads will be added dynamically -->
		</div>
	</div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Constants
            const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const OCTAVES = [5, 4, 3, 2]; // Starting from higher octaves for a more intuitive layout
            const NOTE_HEIGHT = 32; // Height of each note row
            const GRID_CELL_WIDTH = 40; // Width of each grid cell
            const MAX_GRID_WIDTH = 4000; // Maximum width of the grid
			const INITIAL_GRID_CELLS = 16; // Start with 16 cells (4 bars of 4 beats)
			
            // Elements
            const pianoContainer = document.getElementById('piano-keys');
            const gridContainer = document.getElementById('grid-container');
            const playhead = document.getElementById('playhead');
            const playBtn = document.getElementById('play-btn');
            const stopBtn = document.getElementById('stop-btn');
            const tempoInput = document.getElementById('tempo');
            const clearBtn = document.getElementById('clear-btn');

            // State
            let isPlaying = false;
            let currentPosition = 0;
            let animationFrameId = null;
            let noteBlocks = [];
            let activeDragBlock = null;
            let activeResizeBlock = null;
            let dragOffset = { x: 0, y: 0 };
            let audioContext = null;
            let lastTimestamp = 0;
			let maxGridWidth = INITIAL_GRID_CELLS * GRID_CELL_WIDTH;
			let currentSessionIndex = -1;
			
            // Initialize audio context on user interaction
            function initAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

			document.getElementById('emergency-reset').addEventListener('click', function() {
				if (confirm('This will delete ALL saved sessions and reset the app. Continue?')) {
					localStorage.removeItem('musicSequencerSessions');
					location.reload();
				}
			});

            // Create piano keys
            function createPianoKeys() {
                let noteIndex = 0;
                
                OCTAVES.forEach(octave => {
                    NOTES.forEach(note => {
                        const keyElement = document.createElement('div');
                        const isBlackKey = note.includes('#');
                        
                        keyElement.className = `piano-key ${isBlackKey ? 'black-key' : 'white-key'}`;
                        keyElement.dataset.note = `${note}${octave}`;
                        keyElement.dataset.index = noteIndex;
                        keyElement.innerHTML = `${note}${octave}`;
                        
                        keyElement.addEventListener('click', function() {
                            playNote(note, octave, 0.5);
                        });
                        
                        pianoContainer.appendChild(keyElement);
                        noteIndex++;
                    });
                });
            }

			function initSamplesModule() {
				// Sample data by category with reliable URLs
				const sampleData = {
					drums: [
						{ name: 'Kick', url: 'https://freesound.org/data/previews/635/635209_3797507-lq.mp3', color: '#7986CB' },
						{ name: 'Snare', url: 'https://freesound.org/data/previews/387/387186_7255534-lq.mp3', color: '#7986CB' },
						{ name: 'Hi-Hat', url: 'https://freesound.org/data/previews/256/256543_4772965-lq.mp3', color: '#7986CB' },
						{ name: 'Clap', url: 'https://freesound.org/data/previews/215/215416_1979597-lq.mp3', color: '#7986CB' },
						{ name: 'Rim', url: 'https://freesound.org/data/previews/411/411460_8552667-lq.mp3', color: '#7986CB' },
						{ name: 'Tom', url: 'https://freesound.org/data/previews/307/307308_5674406-lq.mp3', color: '#7986CB' },
						{ name: 'Crash', url: 'https://freesound.org/data/previews/128/128136_1798270-lq.mp3', color: '#7986CB' },
						{ name: 'Ride', url: 'https://freesound.org/data/previews/406/406569_7560099-lq.mp3', color: '#7986CB' }
					],
					fx: [
						{ name: 'Whoosh', url: 'https://freesound.org/data/previews/333/333245_5260872-lq.mp3', color: '#4DB6AC' },
						{ name: 'Riser', url: 'https://freesound.org/data/previews/462/462087_9636170-lq.mp3', color: '#4DB6AC' },
						{ name: 'Drop', url: 'https://freesound.org/data/previews/571/571326_9034501-lq.mp3', color: '#4DB6AC' },
						{ name: 'Impact', url: 'https://freesound.org/data/previews/170/170583_1531312-lq.mp3', color: '#4DB6AC' }
					],
					synth: [
						{ name: 'Bass', url: 'https://freesound.org/data/previews/529/529736_7812963-lq.mp3', color: '#FFB74D' },
						{ name: 'Chord', url: 'https://freesound.org/data/previews/204/204952_1836758-lq.mp3', color: '#FFB74D' },
						{ name: 'Arp', url: 'https://freesound.org/data/previews/557/557917_6369414-lq.mp3', color: '#FFB74D' },
						{ name: 'Lead', url: 'https://freesound.org/data/previews/373/373852_5718625-lq.mp3', color: '#FFB74D' }
					],
					vocals: [
						{ name: 'Yeah', url: 'https://freesound.org/data/previews/186/186942_1339599-lq.mp3', color: '#F06292' },
						{ name: 'Hey', url: 'https://freesound.org/data/previews/488/488975_1523678-lq.mp3', color: '#F06292' },
						{ name: 'Go', url: 'https://freesound.org/data/previews/443/443137_6142149-lq.mp3', color: '#F06292' },
						{ name: 'Whoop', url: 'https://freesound.org/data/previews/459/459657_4770-lq.mp3', color: '#F06292' }
					]
				};
				
				// Audio context and sample buffers
				let audioContext = null;
				const sampleBuffers = {};
				let loadedSamples = new Set();
				let isLoadingSamples = false;
				
				// Effect nodes
				let reverbNode = null;
				let delayNode = null;
				
				// DOM elements
				const toggleButton = document.getElementById('toggle-samples-btn');
				const sampleModule = document.querySelector('.sample-module');
				const closeButton = document.getElementById('close-samples-btn');
				const categorySelect = document.getElementById('sample-category');
				const samplePadsContainer = document.getElementById('sample-pads');
				const reverbAmount = document.getElementById('reverb-amount');
				const delayAmount = document.getElementById('delay-amount');
				const loadingIndicator = document.getElementById('loading-indicator');
				
				// Initialize audio context on first user interaction
				function initAudio() {
					if (!audioContext) {
						audioContext = new (window.AudioContext || window.webkitAudioContext)();
						
						// Initialize effects
						initEffects();
					}
				}
				
				// Initialize audio effects
				function initEffects() {
					// Create reverb
					reverbNode = audioContext.createConvolver();
					createReverbImpulse(2.5).then(impulseBuffer => {
						reverbNode.buffer = impulseBuffer;
					});
					
					// Create delay
					delayNode = audioContext.createDelay(4.0);
					delayNode.delayTime.value = 0.3;
					
					const delayFeedback = audioContext.createGain();
					delayFeedback.gain.value = 0.4;
					
					delayNode.connect(delayFeedback);
					delayFeedback.connect(delayNode);
				}
				
				// Create reverb impulse response
				async function createReverbImpulse(duration = 2) {
					const sampleRate = audioContext.sampleRate;
					const length = sampleRate * duration;
					const impulse = audioContext.createBuffer(2, length, sampleRate);
					
					// Generate impulse
					for (let channel = 0; channel < 2; channel++) {
						const data = impulse.getChannelData(channel);
						for (let i = 0; i < length; i++) {
							data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, duration);
						}
					}
					
					return impulse;
				}
				
				// Load a sample with error handling and retries
				async function loadSample(name, url, retries = 2) {
					if (loadedSamples.has(name)) return true;
					
					try {
						// Add CORS proxy if needed
						const finalUrl = url.startsWith('http') ? url : `https://freesound.org/data/previews/${url}`;
						
						const response = await fetch(finalUrl);
						if (!response.ok) throw new Error(`HTTP error ${response.status}`);
						
						const arrayBuffer = await response.arrayBuffer();
						const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
						
						sampleBuffers[name] = audioBuffer;
						loadedSamples.add(name);
						
						console.log(`Loaded sample: ${name}`);
						return true;
					} catch (error) {
						console.error(`Error loading sample ${name} from ${url}:`, error);
						
						if (retries > 0) {
							console.log(`Retrying to load ${name}...`);
							return loadSample(name, url, retries - 1);
						}
						
						// Create a silent buffer as fallback
						if (!sampleBuffers[name]) {
							console.log(`Creating silent buffer for ${name}`);
							sampleBuffers[name] = createSilentBuffer(1);
							loadedSamples.add(name);
						}
						
						return false;
					}
				}
				
				// Create a silent buffer as fallback
				function createSilentBuffer(duration = 0.5) {
					const buffer = audioContext.createBuffer(
						2,
						audioContext.sampleRate * duration,
						audioContext.sampleRate
					);
					return buffer;
				}
				
				// Load samples for a category with loading indicator
				async function loadSamplesForCategory(category) {
					if (isLoadingSamples) return;
					
					const samples = sampleData[category];
					if (!samples) return;
					
					isLoadingSamples = true;
					showLoadingIndicator(true);
					
					try {
						const loadPromises = samples.map(sample => 
							loadSample(sample.name, sample.url)
						);
						
						await Promise.all(loadPromises);
					} finally {
						isLoadingSamples = false;
						showLoadingIndicator(false);
					}
				}
				
				// Show/hide loading indicator
				function showLoadingIndicator(show) {
					if (loadingIndicator) {
						loadingIndicator.style.display = show ? 'block' : 'none';
					}
				}
				
				// Play a sample with effects
				function playSample(name) {
					if (!audioContext) initAudio();
					
					if (!sampleBuffers[name]) {
						console.warn(`Sample "${name}" not loaded`);
						return;
					}
					
					// Create source node
					const source = audioContext.createBufferSource();
					source.buffer = sampleBuffers[name];
					
					// Set up gain for main volume
					const gainNode = audioContext.createGain();
					gainNode.gain.value = 0.8; // Slightly lower default volume
					
					// Set up dry/wet for reverb
					const dryGain = audioContext.createGain();
					const wetReverbGain = audioContext.createGain();
					wetReverbGain.gain.value = parseInt(reverbAmount.value) / 100;
					dryGain.gain.value = 1 - wetReverbGain.gain.value;
					
					// Set up dry/wet for delay
					const wetDelayGain = audioContext.createGain();
					wetDelayGain.gain.value = parseInt(delayAmount.value) / 100;
					
					// Connect the nodes
					source.connect(gainNode);
					gainNode.connect(dryGain);
					dryGain.connect(audioContext.destination);
					
					if (reverbNode && wetReverbGain.gain.value > 0) {
						gainNode.connect(reverbNode);
						reverbNode.connect(wetReverbGain);
						wetReverbGain.connect(audioContext.destination);
					}
					
					if (delayNode && wetDelayGain.gain.value > 0) {
						gainNode.connect(delayNode);
						delayNode.connect(wetDelayGain);
						wetDelayGain.connect(audioContext.destination);
					}
					
					// Start playback
					source.start();
					
					// Visual feedback
					const pad = Array.from(document.querySelectorAll('.sample-pad'))
						.find(pad => pad.textContent === name);
						
					if (pad) {
						pad.classList.add('playing');
						setTimeout(() => pad.classList.remove('playing'), 200);
					}
				}
				
				// Create sample pads for current category
				function createSamplePads(category) {
					samplePadsContainer.innerHTML = '';
					
					const samples = sampleData[category];
					if (!samples) return;
					
					samples.forEach(sample => {
						const pad = document.createElement('div');
						pad.className = `sample-pad ${category}`;
						pad.textContent = sample.name;
						pad.style.backgroundColor = sample.color;
						
						// Add loading indicator to the pad
						const loadingDot = document.createElement('div');
						loadingDot.className = 'loading-dot';
						loadingDot.style.display = loadedSamples.has(sample.name) ? 'none' : 'block';
						pad.appendChild(loadingDot);
						
						pad.addEventListener('mousedown', () => {
							pad.style.transform = 'scale(0.95)';
							playSample(sample.name);
						});
						
						pad.addEventListener('mouseup', () => {
							pad.style.transform = 'scale(1)';
						});
						
						pad.addEventListener('mouseleave', () => {
							pad.style.transform = 'scale(1)';
						});
						
						// Add to sequencer button
						const addToSequencerBtn = document.createElement('button');
						addToSequencerBtn.className = 'add-to-sequencer';
						addToSequencerBtn.innerHTML = '+';
						addToSequencerBtn.title = 'Add to sequencer';
						
						addToSequencerBtn.addEventListener('click', (e) => {
							e.stopPropagation(); // Prevent pad click
							addSampleToSequencer(sample.name, sample.color);
						});
						
						pad.appendChild(addToSequencerBtn);
						samplePadsContainer.appendChild(pad);
						
						addToSequencerBtn.addEventListener('click', (e) => {
							e.stopPropagation(); // Prevent pad click
							
							// Get current track
							const trackIndex = window.currentTrackIndex || 0;
							
							// Get current playhead position as insertion point
							const insertPosition = currentPosition || 0;
							
							// Add sample to the current track at playhead position
							addSampleToTrack(sample.name, sample.color, trackIndex, insertPosition);
						});
						
					});
				}

				function addSampleToTrack(sampleName, color, trackIndex, position) {
					if (!window.tracks || !window.tracks[trackIndex]) {
						console.error("Track not found");
						return;
					}
					
					// Create a UI indicator that sample was added
					const notification = document.createElement('div');
					notification.textContent = `Added ${sampleName} to ${window.tracks[trackIndex].name}`;
					notification.style.position = 'fixed';
					notification.style.bottom = '20px';
					notification.style.right = '20px';
					notification.style.background = 'rgba(0, 150, 0, 0.8)';
					notification.style.color = 'white';
					notification.style.padding = '10px 15px';
					notification.style.borderRadius = '4px';
					notification.style.zIndex = '9999';
					
					document.body.appendChild(notification);
					setTimeout(() => notification.remove(), 2000);
					
					// Create sample block in the grid
					const gridRect = gridContainer.getBoundingClientRect();
					const x = position;
					const y = trackIndex * NOTE_HEIGHT + 2;
					
					createSampleBlock(x, y, sampleName, color);
				}
				
				// Add sample to the sequencer grid
				function addSampleToSequencer(sampleName, color) {
					// Find the first visible row in the grid
					const gridContainer = document.getElementById('grid-container');
					if (!gridContainer) return;
					
					const gridRect = gridContainer.getBoundingClientRect();
					
					// Get current grid position
					const x = 0; // Start at the beginning
					const y = 2; // Small offset from top
					
					// Create a sample block in the grid
					createSampleBlock(x, y, sampleName, color);
				}
				
				// Create a sample block in the grid
				function createSampleBlock(x, y, sampleName, color) {
					// First check if the grid container exists
					const gridContainer = document.getElementById('grid-container');
					if (!gridContainer) {
						console.error('Grid container not found');
						return;
					}
					
					// Create the sample block
					const sampleBlock = document.createElement('div');
					sampleBlock.className = 'note-block sample-block';
					sampleBlock.style.left = `${x}px`;
					sampleBlock.style.top = `${y}px`;
					sampleBlock.style.width = `${GRID_CELL_WIDTH}px`;
					sampleBlock.dataset.sampleName = sampleName;
					sampleBlock.dataset.sustained = false;
					sampleBlock.style.backgroundColor = color || '#7986CB';
					sampleBlock.style.opacity = '0.8';
					sampleBlock.style.borderRadius = '4px 0 0 4px';
					sampleBlock.style.borderRight = '1px dashed white';
					
					// Add sample name text
					const nameLabel = document.createElement('span');
					nameLabel.className = 'sample-name';
					nameLabel.textContent = sampleName;
					nameLabel.style.fontSize = '10px';
					nameLabel.style.position = 'absolute';
					nameLabel.style.left = '4px';
					nameLabel.style.top = '4px';
					nameLabel.style.color = 'white';
					nameLabel.style.textShadow = '0 0 2px black';
					sampleBlock.appendChild(nameLabel);
					
					// Create resize handle
					const resizeHandle = document.createElement('div');
					resizeHandle.className = 'resize-handle';
					sampleBlock.appendChild(resizeHandle);
					
					// Set up drag handlers (similar to note blocks)
					sampleBlock.addEventListener('mousedown', startDragBlock);
					resizeHandle.addEventListener('mousedown', startResizeBlock);
					
					// Right-click to delete
					sampleBlock.addEventListener('contextmenu', function(e) {
						e.preventDefault();
						sampleBlock.remove();
					});
					
					// Double-click to toggle sustained/staccato
					sampleBlock.addEventListener('dblclick', function(e) {
						const isSustained = sampleBlock.dataset.sustained === 'true';
						sampleBlock.dataset.sustained = !isSustained;
						
						if (!isSustained) {
							sampleBlock.style.opacity = '0.9';
							sampleBlock.style.borderRadius = '4px';
							sampleBlock.style.borderRight = 'none';
						} else {
							sampleBlock.style.opacity = '0.7';
							sampleBlock.style.borderRadius = '4px 0 0 4px';
							sampleBlock.style.borderRight = '1px dashed white';
						}
					});
					
					// Add to the grid
					gridContainer.appendChild(sampleBlock);
					
					// Add to the blocks array if it exists
					if (window.noteBlocks) {
						window.noteBlocks.push(sampleBlock);
					}
				}
				
				// Make the sample module draggable
				function makeDraggable(element) {
					let isDragging = false;
					let offsetX, offsetY;
					
					// Add a drag handle to the header
					const header = element.querySelector('.sample-header');
					if (header) {
						header.style.cursor = 'move';
						
						header.addEventListener('mousedown', startDrag);
						
						function startDrag(e) {
							if (e.target === closeButton) return;
							
							isDragging = true;
							offsetX = e.clientX - element.getBoundingClientRect().left;
							offsetY = e.clientY - element.getBoundingClientRect().top;
							
							document.addEventListener('mousemove', onDrag);
							document.addEventListener('mouseup', stopDrag);
							
							// Prevent text selection during drag
							e.preventDefault();
						}
						
						function onDrag(e) {
							if (!isDragging) return;
							
							const left = e.clientX - offsetX;
							const top = e.clientY - offsetY;
							
							// Keep the element within the viewport
							const maxX = window.innerWidth - element.offsetWidth;
							const maxY = window.innerHeight - element.offsetHeight;
							
							element.style.left = `${Math.max(0, Math.min(left, maxX))}px`;
							element.style.top = `${Math.max(0, Math.min(top, maxY))}px`;
							element.style.transform = 'none'; // Remove the transform
						}
						
						function stopDrag() {
							isDragging = false;
							document.removeEventListener('mousemove', onDrag);
							document.removeEventListener('mouseup', stopDrag);
						}
					}
				}
				
				// Update the playNotesAtPosition function to handle sample blocks
				function extendPlayNotesAtPosition() {
					// Get the original function
					const originalFunction = window.playNotesAtPosition;
					
					// Replace with our extended version
					window.playNotesAtPosition = function(position) {
						// Call the original function first
						if (originalFunction) {
							originalFunction(position);
						}
						
						// Now handle sample blocks
						const sampleBlocks = document.querySelectorAll('.note-block.sample-block');
						sampleBlocks.forEach(block => {
							const blockLeft = parseInt(block.style.left);
							const blockWidth = parseInt(block.style.width);
							
							// Check if the playhead just crossed the start of this block
							if (position >= blockLeft && position <= blockLeft + 5) {
								const sampleName = block.dataset.sampleName;
								if (sampleName) {
									const isSustained = block.dataset.sustained === 'true';
									const duration = (blockWidth / GRID_CELL_WIDTH) * (60 / parseInt(tempoInput.value));
									
									// Play the sample
									playSample(sampleName);
								}
							}
						});
					};
				}
				
				// Event listeners
				function setupEventListeners() {
					// Toggle samples module
					toggleButton.addEventListener('click', () => {
						// Initialize audio if needed
						initAudio();
						
						// Toggle display
						if (sampleModule.style.display === 'none') {
							sampleModule.style.display = 'block';
							
							// Load and display current category
							const category = categorySelect.value;
							loadSamplesForCategory(category);
							createSamplePads(category);
						} else {
							sampleModule.style.display = 'none';
						}
					});
					
					// Close button
					closeButton.addEventListener('click', () => {
						sampleModule.style.display = 'none';
					});
					
					// Category selection
					categorySelect.addEventListener('change', () => {
						const category = categorySelect.value;
						loadSamplesForCategory(category);
						createSamplePads(category);
					});
					
					// Hide the module initially
					sampleModule.style.display = 'none';
				}
				
				// Call this function to initialize everything
				function init() {
					// First create the loading indicator if it doesn't exist
					if (!loadingIndicator) {
						const indicator = document.createElement('div');
						indicator.id = 'loading-indicator';
						indicator.innerHTML = 'Loading samples...';
						indicator.style.position = 'absolute';
						indicator.style.top = '50%';
						indicator.style.left = '50%';
						indicator.style.transform = 'translate(-50%, -50%)';
						indicator.style.backgroundColor = 'rgba(0,0,0,0.7)';
						indicator.style.color = 'white';
						indicator.style.padding = '10px 20px';
						indicator.style.borderRadius = '4px';
						indicator.style.display = 'none';
						indicator.style.zIndex = '10';
						sampleModule.appendChild(indicator);
					}
					
					setupEventListeners();
					makeDraggable(sampleModule);
					extendPlayNotesAtPosition();
					
					// ADD THIS NEW CODE HERE:
					// Add help section
					const addSampleCategoryDiv = document.createElement('div');
					addSampleCategoryDiv.className = 'sample-help';
					addSampleCategoryDiv.innerHTML = `
						<p>Click a sample pad to play it. Use the + button to add to sequencer.</p>
						<button id="add-sample-category-btn" style="width: 100%; padding: 8px; margin-top: 5px; background-color: #5b87ff; color: white; border: none; border-radius: 4px; cursor: pointer;">
							Add More Sample Packs
						</button>
					`;
					sampleModule.appendChild(addSampleCategoryDiv);
					
					// Add event listener for the button
					document.getElementById('add-sample-category-btn').addEventListener('click', function() {
						const newSampleCategory = {
							name: "Custom",
							samples: [
								{ name: 'Custom1', url: 'https://freesound.org/data/previews/521/521275_701537-lq.mp3', color: '#9C27B0' },
								{ name: 'Custom2', url: 'https://freesound.org/data/previews/323/323785_5260872-lq.mp3', color: '#9C27B0' }
							]
						};
						
						// Add option to dropdown
						const option = document.createElement('option');
						option.value = "custom";
						option.textContent = "Custom";
						categorySelect.appendChild(option);
						
						// Switch to the new category
						categorySelect.value = "custom";
						loadSamplesForCategory("custom");
						createSamplePads("custom");
						
						alert("Added new sample pack: Custom");
					});
					// END OF NEW CODE
					
					// Position the module near the center initially
					sampleModule.style.top = '100px';
					sampleModule.style.left = '50%';
					sampleModule.style.transform = 'translateX(-50%)';
				}
				
				// Initialize the module
				init();
				
				// Return public API for extension
				return {
					playSample,
					loadSample,
					addSampleToSequencer
				};
			}

			function setupSampleSystem() {
				// Initialize sample storage
				const sampleBuffers = {};
				const defaultSamples = [
					{ name: 'kick', url: 'https://cdn.freesound.org/previews/250/250547_4486188-lq.mp3' },
					{ name: 'snare', url: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3' },
					{ name: 'hihat', url: 'https://cdn.freesound.org/previews/484/484344_10343397-lq.mp3' },
					{ name: 'clap', url: 'https://cdn.freesound.org/previews/240/240622_4486188-lq.mp3' },
					{ name: 'crash', url: 'https://cdn.freesound.org/previews/521/521295_11253523-lq.mp3' }
				];
				
				// Load a sample into memory
				async function loadSample(name, url) {
					try {
						const response = await fetch(url);
						const arrayBuffer = await response.arrayBuffer();
						const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
						sampleBuffers[name] = audioBuffer;
						console.log(`Loaded sample: ${name}`);
						return true;
					} catch (error) {
						console.error(`Error loading sample ${name}:`, error);
						return false;
					}
				}
				
				// Load all default samples
				async function loadDefaultSamples() {
					for (const sample of defaultSamples) {
						await loadSample(sample.name, sample.url);
					}
				}
				
				// Play a sample with optional effects
				function playSample(name, time = 0, options = {}) {
					if (!sampleBuffers[name]) {
						console.warn(`Sample "${name}" not found`);
						return null;
					}
					
					// Create audio source from buffer
					const source = audioContext.createBufferSource();
					source.buffer = sampleBuffers[name];
					
					// Set up gain node for volume control
					const gainNode = audioContext.createGain();
					gainNode.gain.value = options.volume || 1.0;
					
					// Connect source to gain
					source.connect(gainNode);
					
					// Apply effects chain if available
					if (options.effects && Array.isArray(options.effects)) {
						let currentNode = gainNode;
						
						for (const effect of options.effects) {
							if (effect.node) {
								currentNode.connect(effect.node);
								currentNode = effect.node;
							}
						}
						
						currentNode.connect(audioContext.destination);
					} else {
						// Connect directly to output
						gainNode.connect(audioContext.destination);
					}
					
					// Start playback
					const startTime = audioContext.currentTime + (time || 0);
					source.start(startTime);
					
					return {
						source,
						gainNode
					};
				}
				
				// Create a basic reverb effect
				function createReverb(options = {}) {
					const convolver = audioContext.createConvolver();
					
					// Create impulse response for reverb
					const impulseLength = options.decay || 2;
					const sampleRate = audioContext.sampleRate;
					const impulse = audioContext.createBuffer(
						2, 
						impulseLength * sampleRate, 
						sampleRate
					);
					
					// Generate simple reverb impulse
					for (let channel = 0; channel < 2; channel++) {
						const impulseData = impulse.getChannelData(channel);
						for (let i = 0; i < impulse.length; i++) {
							impulseData[i] = (Math.random() * 2 - 1) * 
											 Math.pow(1 - i / impulse.length, impulseLength);
						}
					}
					
					convolver.buffer = impulse;
					
					// Create a gain node to control wet/dry mix
					const wetGain = audioContext.createGain();
					wetGain.gain.value = options.wet || 0.3;
					
					const dryGain = audioContext.createGain();
					dryGain.gain.value = options.dry || 0.7;
					
					// Create a merger node for the output
					const merger = audioContext.createGain();
					
					// Connect the nodes
					convolver.connect(wetGain);
					wetGain.connect(merger);
					dryGain.connect(merger);
					
					return {
						node: merger,
						input: (input) => {
							input.connect(convolver);
							input.connect(dryGain);
						}
					};
				}
				
				// Create a delay effect
				function createDelay(options = {}) {
					const delayNode = audioContext.createDelay();
					delayNode.delayTime.value = options.time || 0.3;
					
					const feedback = audioContext.createGain();
					feedback.gain.value = options.feedback || 0.4;
					
					const wetGain = audioContext.createGain();
					wetGain.gain.value = options.wet || 0.3;
					
					const dryGain = audioContext.createGain();
					dryGain.gain.value = options.dry || 0.7;
					
					const merger = audioContext.createGain();
					
					// Connect the nodes for delay with feedback
					delayNode.connect(feedback);
					feedback.connect(delayNode);
					delayNode.connect(wetGain);
					wetGain.connect(merger);
					dryGain.connect(merger);
					
					return {
						node: merger,
						input: (input) => {
							input.connect(delayNode);
							input.connect(dryGain);
						}
					};
				}
				
				// Initialize and return the API
				return {
					loadSample,
					loadDefaultSamples,
					playSample,
					createReverb,
					createDelay,
					getSampleList: () => Object.keys(sampleBuffers)
				};
			}

			// Create the UI for sample pads
			function createSamplePadsUI() {
				// Create container for sample pads
				const samplePadContainer = document.createElement('div');
				samplePadContainer.className = 'sample-pads-container';
				samplePadContainer.style.display = 'flex';
				samplePadContainer.style.flexWrap = 'wrap';
				samplePadContainer.style.gap = '10px';
				samplePadContainer.style.padding = '10px';
				samplePadContainer.style.backgroundColor = '#252525';
				samplePadContainer.style.borderTop = '1px solid #444';
				
				// Add heading
				const heading = document.createElement('h3');
				heading.textContent = 'Sample Pads';
				heading.style.width = '100%';
				heading.style.margin = '0 0 10px 0';
				heading.style.color = '#b0b0b0';
				samplePadContainer.appendChild(heading);
				
				// Get sample names from our system
				const sampleSystem = window.sampleSystem; // We'll create this later
				if (!sampleSystem) {
					console.warn('Sample system not initialized');
					return samplePadContainer;
				}
				
				const sampleNames = sampleSystem.getSampleList();
				
				// Color palette for pads
				const padColors = [
					'#7986CB', '#4DB6AC', '#FFB74D', '#F06292', 
					'#9575CD', '#4DD0E1', '#FFF176', '#BA68C8'
				];
				
				// Create a pad for each sample
				sampleNames.forEach((sampleName, index) => {
					const pad = document.createElement('div');
					pad.className = 'sample-pad';
					pad.textContent = sampleName;
					
					// Style the pad
					pad.style.width = '100px';
					pad.style.height = '100px';
					pad.style.backgroundColor = padColors[index % padColors.length];
					pad.style.borderRadius = '8px';
					pad.style.display = 'flex';
					pad.style.justifyContent = 'center';
					pad.style.alignItems = 'center';
					pad.style.fontWeight = 'bold';
					pad.style.color = 'white';
					pad.style.textTransform = 'uppercase';
					pad.style.cursor = 'pointer';
					pad.style.userSelect = 'none';
					pad.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
					pad.style.transition = 'all 0.1s ease';
					
					// Add hover and active effects
					pad.addEventListener('mousedown', () => {
						pad.style.transform = 'scale(0.95)';
						pad.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';
						
						// Play the sample
						sampleSystem.playSample(sampleName);
					});
					
					pad.addEventListener('mouseup', () => {
						pad.style.transform = 'scale(1)';
						pad.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
					});
					
					pad.addEventListener('mouseleave', () => {
						pad.style.transform = 'scale(1)';
						pad.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
					});
					
					samplePadContainer.appendChild(pad);
				});
				
				return samplePadContainer;
			}

			// Initialize and connect the sample system
			function initSampleSystem() {
				// Make sure audio context is initialized
				if (!audioContext) {
					audioContext = new (window.AudioContext || window.webkitAudioContext)();
				}
				
				// Create sample system
				window.sampleSystem = setupSampleSystem();
				
				// Load default samples
				window.sampleSystem.loadDefaultSamples().then(() => {
					console.log('All default samples loaded');
					
					// Create and add the sample pads UI
					const samplePadsUI = createSamplePadsUI();
					document.body.appendChild(samplePadsUI);
				});
				
				// Create and add a button to toggle sample pad visibility
				const toggleButton = document.createElement('button');
				toggleButton.textContent = 'Sample Pads';
				toggleButton.className = 'toggle-samples-btn';
				toggleButton.style.position = 'fixed';
				toggleButton.style.bottom = '10px';
				toggleButton.style.left = '10px';
				toggleButton.style.backgroundColor = '#5b87ff';
				toggleButton.style.color = 'white';
				toggleButton.style.border = 'none';
				toggleButton.style.padding = '8px 12px';
				toggleButton.style.borderRadius = '4px';
				toggleButton.style.cursor = 'pointer';
				toggleButton.style.zIndex = '9999';
				
				toggleButton.addEventListener('click', () => {
					const container = document.querySelector('.sample-pads-container');
					if (container) {
						if (container.style.display === 'none') {
							container.style.display = 'flex';
						} else {
							container.style.display = 'none';
						}
					}
				});
				
				document.body.appendChild(toggleButton);
			}

            // Play a note
			function playNote(note, octave, duration, isSustained = false, instrumentType = 'sine') {
				initAudio();
				
				// Map note to frequency
				const noteFrequencies = {
					'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63,
					'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
				};
				
				// Calculate frequency based on octave
				const baseFreq = noteFrequencies[note];
				const octaveFactor = Math.pow(2, octave - 4); // Normalize to octave 4
				const frequency = baseFreq * octaveFactor;
				
				// Create oscillator
				const oscillator = audioContext.createOscillator();
				const gainNode = audioContext.createGain();
				
				// Set oscillator type based on instrument
				if (instrumentType === 'piano') {
					// Simple piano-like sound with multiple oscillators
					oscillator.type = 'triangle';
					
					// Add a second oscillator for harmonics
					const harmonicOsc = audioContext.createOscillator();
					harmonicOsc.type = 'sine';
					harmonicOsc.frequency.value = frequency * 2; // One octave higher
					
					const harmonicGain = audioContext.createGain();
					harmonicGain.gain.value = 0.2; // Lower volume for harmonic
					
					harmonicOsc.connect(harmonicGain);
					harmonicGain.connect(audioContext.destination);
					harmonicOsc.start();
					harmonicOsc.stop(audioContext.currentTime + duration);
				} else {
					oscillator.type = instrumentType; // 'sine', 'square', 'sawtooth', or 'triangle'
				}
				
				oscillator.frequency.value = frequency;
				
				// Apply envelope based on sustained or staccato
				if (isSustained) {
					// Sustained note with longer attack and release
					gainNode.gain.setValueAtTime(0, audioContext.currentTime);
					gainNode.gain.linearRampToValueAtTime(0.7, audioContext.currentTime + 0.05);
					gainNode.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + duration * 0.8);
					gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
				} else {
					// Staccato note with quick attack and release
					gainNode.gain.setValueAtTime(0, audioContext.currentTime);
					gainNode.gain.linearRampToValueAtTime(0.7, audioContext.currentTime + 0.01);
					gainNode.gain.linearRampToValueAtTime(0.4, audioContext.currentTime + duration * 0.3);
					gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + Math.min(0.3, duration));
				}
				
				oscillator.connect(gainNode);
				gainNode.connect(audioContext.destination);
				
				oscillator.start();
				oscillator.stop(audioContext.currentTime + duration);
			}

            // Create a new note block
			function createNoteBlock(x, y, width = GRID_CELL_WIDTH, noteIndex, isSustained = false, instrument = 'sine') {
				const noteBlock = document.createElement('div');
				noteBlock.className = 'note-block';
				noteBlock.style.left = `${x}px`;
				noteBlock.style.top = `${y}px`;
				noteBlock.style.width = `${width}px`;
				noteBlock.dataset.noteIndex = noteIndex;
				noteBlock.dataset.sustained = isSustained;
				noteBlock.dataset.instrument = instrument;
				
				// Set color based on instrument
				noteBlock.style.backgroundColor = instrumentColors[instrument];
				
				// Style differently based on sustained/staccato
				if (isSustained) {
					noteBlock.style.opacity = '0.9';
					noteBlock.style.borderRadius = '4px';
				} else {
					noteBlock.style.opacity = '0.7';
					noteBlock.style.borderRadius = '4px 0 0 4px';
					noteBlock.style.borderRight = '1px dashed white';
				}
				
				// Get note information from the key at this index
				const pianoKey = pianoContainer.children[noteIndex];
				const noteData = pianoKey.dataset.note;
				noteBlock.dataset.note = noteData;
				
				// Create resize handle
				const resizeHandle = document.createElement('div');
				resizeHandle.className = 'resize-handle';
				noteBlock.appendChild(resizeHandle);
				
				// Set up event listeners for dragging
				noteBlock.addEventListener('mousedown', startDragBlock);
				resizeHandle.addEventListener('mousedown', startResizeBlock);
				
				// Double-click to toggle sustained/staccato
				noteBlock.addEventListener('dblclick', function(e) {
					const isSustained = noteBlock.dataset.sustained === 'true';
					noteBlock.dataset.sustained = !isSustained;
					
					if (!isSustained) {
						noteBlock.style.opacity = '0.9';
						noteBlock.style.borderRadius = '4px';
						noteBlock.style.borderRight = 'none';
					} else {
						noteBlock.style.opacity = '0.7';
						noteBlock.style.borderRadius = '4px 0 0 4px';
						noteBlock.style.borderRight = '1px dashed white';
					}
				});
				
				gridContainer.appendChild(noteBlock);
				noteBlocks.push(noteBlock);
				
				return noteBlock;
			}

			gridContainer.addEventListener('contextmenu', function(e) {
				e.preventDefault(); // Prevent the default context menu
				const block = e.target.closest('.note-block');
				if (block) {
					const blockIndex = noteBlocks.indexOf(block);
					if (blockIndex > -1) {
						noteBlocks.splice(blockIndex, 1);
					}
					block.remove();
				}
			});

            // Handle start dragging a note block
            function startDragBlock(e) {
                e.stopPropagation();
                activeDragBlock = e.target.closest('.note-block');
                
                if (activeDragBlock) {
                    const rect = activeDragBlock.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    document.addEventListener('mousemove', dragBlock);
                    document.addEventListener('mouseup', stopDragBlock);
                }
            }

            // Handle dragging a note block
            function dragBlock(e) {
                if (!activeDragBlock) return;
                
                const gridRect = gridContainer.getBoundingClientRect();
                const x = e.clientX - gridRect.left - dragOffset.x;
                const y = e.clientY - gridRect.top - dragOffset.y;
                
                // Snap to grid
                const snappedX = Math.max(0, Math.floor(x / GRID_CELL_WIDTH) * GRID_CELL_WIDTH);
                const snappedY = Math.max(0, Math.floor(y / NOTE_HEIGHT) * NOTE_HEIGHT + 2);
                
                activeDragBlock.style.left = `${snappedX}px`;
                activeDragBlock.style.top = `${snappedY}px`;
                
                // Update note index based on new position
                const noteIndex = Math.floor(snappedY / NOTE_HEIGHT);
                if (noteIndex < pianoContainer.children.length) {
                    const pianoKey = pianoContainer.children[noteIndex];
                    activeDragBlock.dataset.noteIndex = noteIndex;
                    activeDragBlock.dataset.note = pianoKey.dataset.note;
                }
            }

            // Handle stop dragging a note block
            function stopDragBlock() {
                activeDragBlock = null;
                document.removeEventListener('mousemove', dragBlock);
                document.removeEventListener('mouseup', stopDragBlock);
            }

            // Handle start resizing a note block
            function startResizeBlock(e) {
                e.stopPropagation();
                activeResizeBlock = e.target.closest('.note-block');
                
                if (activeResizeBlock) {
                    document.addEventListener('mousemove', resizeBlock);
                    document.addEventListener('mouseup', stopResizeBlock);
                }
            }

            // Handle resizing a note block
            function resizeBlock(e) {
                if (!activeResizeBlock) return;
                
                const gridRect = gridContainer.getBoundingClientRect();
                const blockRect = activeResizeBlock.getBoundingClientRect();
                
                let width = e.clientX - blockRect.left;
                width = Math.max(GRID_CELL_WIDTH, Math.floor(width / GRID_CELL_WIDTH) * GRID_CELL_WIDTH);
                
                activeResizeBlock.style.width = `${width}px`;
            }

            // Handle stop resizing a note block
            function stopResizeBlock() {
                activeResizeBlock = null;
                document.removeEventListener('mousemove', resizeBlock);
                document.removeEventListener('mouseup', stopResizeBlock);
            }

			function showQuickSaveNotification(sessionName) {
				const notification = document.createElement('div');
				notification.textContent = `Saved: ${sessionName}`;
				notification.style.position = 'fixed';
				notification.style.bottom = '20px';
				notification.style.right = '20px';
				notification.style.background = 'rgba(0, 150, 0, 0.8)';
				notification.style.color = 'white';
				notification.style.padding = '10px 15px';
				notification.style.borderRadius = '4px';
				notification.style.zIndex = '9999';
				notification.style.transition = 'opacity 0.5s ease';
				
				document.body.appendChild(notification);
				
				setTimeout(() => {
					notification.style.opacity = '0';
					setTimeout(() => notification.remove(), 500);
				}, 1500);
			}

			function setupAutoSave() {
				// Helper to detect changes to the grid
				const observeGridChanges = () => {
					// Set a timer to save after 3 seconds of inactivity
					if (window.autoSaveTimer) {
						clearTimeout(window.autoSaveTimer);
					}
					
					window.autoSaveTimer = setTimeout(() => {
						if (currentSessionIndex >= 0) {
							saveCurrentSession(true); // true = autosave
						}
					}, 3000); // 3 second delay
				};
				
				// Monitor note block creation, movement, and deletion
				const originalCreateNoteBlock = createNoteBlock;
				window.createNoteBlock = function(...args) {
					const block = originalCreateNoteBlock.apply(this, args);
					observeGridChanges();
					return block;
				};
				
				// Monitor drag end
				const originalStopDragBlock = stopDragBlock;
				window.stopDragBlock = function() {
					originalStopDragBlock.apply(this, arguments);
					observeGridChanges();
				};
				
				// Monitor resize end
				const originalStopResizeBlock = stopResizeBlock;
				window.stopResizeBlock = function() {
					originalStopResizeBlock.apply(this, arguments);
					observeGridChanges();
				};
				
				// Monitor note deletion
				gridContainer.addEventListener('contextmenu', function() {
					// If a block was right-clicked and deleted
					setTimeout(observeGridChanges, 100);
				});
				
				// Monitor tempo changes
				tempoInput.addEventListener('change', observeGridChanges);
			}

			function saveCurrentSession(isAutoSave = false) {
				// Get existing sessions
				let sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Check if we're editing an existing session
				if (currentSessionIndex >= 0 && currentSessionIndex < sessions.length) {
					// Update existing session without prompting
					const sessionName = sessions[currentSessionIndex].name;
					
					// Collect data from blocks
					const sessionData = {
						name: sessionName,
						blocks: [],
						tempo: parseInt(tempoInput.value) || 120,
						maxGridWidth: maxGridWidth
					};
					
					// Save note blocks
					const blocks = document.querySelectorAll('.note-block');
					blocks.forEach(block => {
						try {
							sessionData.blocks.push({
								x: parseInt(block.style.left) || 0,
								y: parseInt(block.style.top) || 0,
								width: parseInt(block.style.width) || GRID_CELL_WIDTH,
								noteIndex: parseInt(block.dataset.noteIndex) || 0,
								sustained: block.dataset.sustained === 'true',
								instrument: block.dataset.instrument || 'sine',
								sampleName: block.dataset.sampleName
							});
						} catch (error) {
							console.error("Error saving block:", error);
						}
					});
					
					// Update session in array
					sessions[currentSessionIndex] = sessionData;
					
					// Save to localStorage
					localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
					
					// Show quick save notification if not auto-save or first auto-save
					if (!isAutoSave || !window.lastAutoSave || Date.now() - window.lastAutoSave > 30000) {
						showQuickSaveNotification(isAutoSave ? `${sessionName} (Auto-saved)` : sessionName);
						window.lastAutoSave = Date.now();
					}
				} else {
					// New session - use prompt for name
					const sessionName = prompt("Enter a name for your session:", "My Session");
					if (!sessionName) return; // User cancelled
					
					// The rest of your existing save function for new sessions...
					const sessionData = {
						name: sessionName,
						blocks: [],
						tempo: parseInt(tempoInput.value) || 120,
						maxGridWidth: maxGridWidth
					};
					
					// Save note blocks
					const blocks = document.querySelectorAll('.note-block');
					blocks.forEach(block => {
						try {
							sessionData.blocks.push({
								x: parseInt(block.style.left) || 0,
								y: parseInt(block.style.top) || 0,
								width: parseInt(block.style.width) || GRID_CELL_WIDTH,
								noteIndex: parseInt(block.dataset.noteIndex) || 0,
								sustained: block.dataset.sustained === 'true',
								instrument: block.dataset.instrument || 'sine',
								sampleName: block.dataset.sampleName
							});
						} catch (error) {
							console.error("Error saving block:", error);
						}
					});
					
					// Add new session
					sessions.push(sessionData);
					currentSessionIndex = sessions.length - 1;
					
					// Save to localStorage
					localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
					
					// Update sessions list
					updateSessionsList();
					
					// Show notification
					showQuickSaveNotification(sessionName);
				}
			}

			// Update the saveCurrentSession function to handle auto-save
			function saveCurrentSession(isAutoSave = false) {
				// Get existing sessions
				let sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Check if we're editing an existing session
				if (currentSessionIndex >= 0 && currentSessionIndex < sessions.length) {
					// Update existing session without prompting
					const sessionName = sessions[currentSessionIndex].name;
					
					// Collect data from blocks
					const sessionData = {
						name: sessionName,
						blocks: [],
						tempo: parseInt(tempoInput.value) || 120,
						maxGridWidth: maxGridWidth
					};
					
					// Save note blocks
					const blocks = document.querySelectorAll('.note-block');
					blocks.forEach(block => {
						try {
							sessionData.blocks.push({
								x: parseInt(block.style.left) || 0,
								y: parseInt(block.style.top) || 0,
								width: parseInt(block.style.width) || GRID_CELL_WIDTH,
								noteIndex: parseInt(block.dataset.noteIndex) || 0,
								sustained: block.dataset.sustained === 'true',
								instrument: block.dataset.instrument || 'sine',
								sampleName: block.dataset.sampleName
							});
						} catch (error) {
							console.error("Error saving block:", error);
						}
					});
					
					// Update session in array
					sessions[currentSessionIndex] = sessionData;
					
					// Save to localStorage
					localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
					
					// Show quick save notification if not auto-save or first auto-save
					if (!isAutoSave || !window.lastAutoSave || Date.now() - window.lastAutoSave > 30000) {
						showQuickSaveNotification(isAutoSave ? `${sessionName} (Auto-saved)` : sessionName);
						window.lastAutoSave = Date.now();
					}
				} else {
					// New session - use prompt for name
					const sessionName = prompt("Enter a name for your session:", "My Session");
					if (!sessionName) return; // User cancelled
					
					// The rest of your existing save function for new sessions...
					const sessionData = {
						name: sessionName,
						blocks: [],
						tempo: parseInt(tempoInput.value) || 120,
						maxGridWidth: maxGridWidth
					};
					
					// Save note blocks
					const blocks = document.querySelectorAll('.note-block');
					blocks.forEach(block => {
						try {
							sessionData.blocks.push({
								x: parseInt(block.style.left) || 0,
								y: parseInt(block.style.top) || 0,
								width: parseInt(block.style.width) || GRID_CELL_WIDTH,
								noteIndex: parseInt(block.dataset.noteIndex) || 0,
								sustained: block.dataset.sustained === 'true',
								instrument: block.dataset.instrument || 'sine',
								sampleName: block.dataset.sampleName
							});
						} catch (error) {
							console.error("Error saving block:", error);
						}
					});
					
					// Add new session
					sessions.push(sessionData);
					currentSessionIndex = sessions.length - 1;
					
					// Save to localStorage
					localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
					
					// Update sessions list
					updateSessionsList();
					
					// Show notification
					showQuickSaveNotification(sessionName);
				}
			}

			function loadSession(sessionIndex) {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (sessionIndex >= sessions.length) return;
				
				const session = sessions[sessionIndex];
				
				// Clear current session
				clearAllNotes();
				
				// Set tempo
				tempoInput.value = session.tempo || 120;
				
				// Set grid width
				maxGridWidth = session.maxGridWidth || (INITIAL_GRID_CELLS * GRID_CELL_WIDTH);
				updateGridSize();
				
				// Load all blocks
				if (session.blocks && Array.isArray(session.blocks)) {
					session.blocks.forEach(blockData => {
						try {
							if (blockData.sampleName) {
								// It's a sample block
								createSampleBlock(
									blockData.x || 0,
									blockData.y || 0,
									blockData.sampleName,
									null, // Let color be determined by the sample category
									blockData.width || GRID_CELL_WIDTH,
									blockData.sustained === true
								);
							} else {
								// It's a regular note block
								const x = typeof blockData.x === 'number' ? blockData.x : 0;
								const y = typeof blockData.y === 'number' ? blockData.y : 0;
								const width = typeof blockData.width === 'number' ? blockData.width : GRID_CELL_WIDTH;
								const noteIndex = typeof blockData.noteIndex === 'number' ? blockData.noteIndex : 0;
								const sustained = blockData.sustained === true;
								const instrument = blockData.instrument || 'sine';
								
								createNoteBlock(x, y, width, noteIndex, sustained, instrument);
							}
						} catch (error) {
							console.error("Error loading block:", error);
						}
					});
				}
				
				// Update current session index
				currentSessionIndex = sessionIndex;
				
				// Show session name in the UI (optional)
				showCurrentSessionName(session.name);
			}

			function showSaveConfirmation(sessionName) {
				// Create a div for the notification
				const notification = document.createElement('div');
				notification.className = 'save-notification';
				notification.textContent = `Saved: ${sessionName}`;
				
				// Style the notification
				notification.style.position = 'fixed';
				notification.style.bottom = '20px';
				notification.style.right = '20px';
				notification.style.background = 'rgba(0, 150, 0, 0.8)';
				notification.style.color = 'white';
				notification.style.padding = '10px 15px';
				notification.style.borderRadius = '4px';
				notification.style.zIndex = '9999';
				notification.style.transition = 'opacity 0.5s ease';
				
				// Add to document
				document.body.appendChild(notification);
				
				// Remove after 2 seconds
				setTimeout(() => {
					notification.style.opacity = '0';
					setTimeout(() => notification.remove(), 500);
				}, 1500);
			}

			function loadSavedSessions() {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Update the sessions list in the sidebar
				const sessionsList = document.getElementById('sessions-list');
				sessionsList.innerHTML = '';
				
				// Add each session to the list
				sessions.forEach((session, index) => {
					const sessionItem = document.createElement('div');
					sessionItem.className = 'session-item';
					sessionItem.innerHTML = session.name || `Session ${index + 1}`;
					
					// Add click event to load session
					sessionItem.addEventListener('click', function() {
						loadSession(index);
					});
					
					sessionsList.appendChild(sessionItem);
				});
			}

			function updateSessionsList() {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Update the sessions list in the sidebar
				const sessionsList = document.getElementById('sessions-list');
				sessionsList.innerHTML = '';
				
				// Add each session to the list
				sessions.forEach((session, index) => {
					const sessionItem = document.createElement('div');
					sessionItem.className = 'session-item';
					sessionItem.innerHTML = session.name || `Session ${index + 1}`;
					
					// Add click event to load session
					sessionItem.addEventListener('click', function() {
						loadSession(index);
					});
					
					// Add right-click menu
					sessionItem.addEventListener('contextmenu', function(e) {
						e.preventDefault();
						
						// Remove any existing context menus
						const existingMenus = document.querySelectorAll('.context-menu');
						existingMenus.forEach(menu => menu.remove());
						
						// Create context menu
						const menu = document.createElement('div');
						menu.className = 'context-menu';
						menu.style.position = 'fixed'; // Use fixed positioning
						menu.style.left = `${e.clientX}px`;
						menu.style.top = `${e.clientY}px`;
						menu.style.zIndex = '1000';
						
						// Add options
						const renameOption = document.createElement('div');
						renameOption.textContent = 'Rename';
						renameOption.addEventListener('click', function() {
							renameSession(index);
							menu.remove();
						});
						
						const deleteOption = document.createElement('div');
						deleteOption.textContent = 'Delete';
						deleteOption.addEventListener('click', function() {
							deleteSession(index);
							menu.remove();
						});
						
						menu.appendChild(renameOption);
						menu.appendChild(deleteOption);
						document.body.appendChild(menu);
						
						// Close menu when clicking outside
						setTimeout(() => {
							document.addEventListener('click', function closeMenu() {
								menu.remove();
								document.removeEventListener('click', closeMenu);
							}, { once: true });
						}, 0);
					});
					
					sessionsList.appendChild(sessionItem);
				});
				
				// Add "New Session" button
				const newSessionItem = document.createElement('div');
				newSessionItem.className = 'session-item new-session';
				newSessionItem.innerHTML = '+ New Session';
				newSessionItem.addEventListener('click', createNewSession);
				sessionsList.appendChild(newSessionItem);
			}

			// Add this function to your script
			function resetGrid() {
				// Clear all notes
				clearAllNotes();
				
				// Reset grid size to default
				maxGridWidth = INITIAL_GRID_CELLS * GRID_CELL_WIDTH;
				
				// Initialize grid properties
				gridContainer.style.backgroundImage = 'linear-gradient(to right, #333 1px, transparent 1px), linear-gradient(to bottom, #333 1px, transparent 1px)';
				gridContainer.style.backgroundSize = `${GRID_CELL_WIDTH}px ${NOTE_HEIGHT}px`;
				gridContainer.style.backgroundColor = '#1a1a1a';
				
				// Update grid display
				updateGridSize();
				
				console.log("Grid reset complete");
			}

			// Function to rename a session
			function renameSession(index) {
				// Get sessions
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (index >= sessions.length) return;
				
				const session = sessions[index];
				const newName = prompt("Enter a new name for the session:", session.name);
				
				if (!newName) return; // User cancelled
				
				session.name = newName;
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				updateSessionsList();
			}

			// Function to delete a session
			function deleteSession(index) {
				// Get sessions
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (index >= sessions.length) return;
				
				if (!confirm("Are you sure you want to delete this session?")) return;
				
				// Get the name for logging
				const sessionName = sessions[index].name;
				console.log(`Deleting session: ${sessionName} (index: ${index})`);
				
				// Remove the session at the specified index
				sessions.splice(index, 1);
				
				// Save updated sessions array
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				console.log(`Sessions after deletion: ${sessions.length}`);
				
				// Update current session index
				if (currentSessionIndex === index) {
					// We deleted the current session
					if (sessions.length === 0) {
						// No more sessions
						currentSessionIndex = -1;
						clearAllNotes();
						console.log("Cleared all notes - no more sessions");
					} else if (index >= sessions.length) {
						// Last session was deleted, load the new last session
						currentSessionIndex = sessions.length - 1;
						loadSession(currentSessionIndex);
						console.log(`Loading last session (new index: ${currentSessionIndex})`);
					} else {
						// Load the session at the same index (which is now a different session)
						currentSessionIndex = index;
						loadSession(currentSessionIndex);
						console.log(`Loading session at same index (new index: ${currentSessionIndex})`);
					}
				} else if (currentSessionIndex > index) {
					// We deleted a session before the current one, adjust index
					currentSessionIndex--;
					console.log(`Adjusted current session index: ${currentSessionIndex}`);
				}
				// else: we deleted a session after the current one, no index adjustment needed
				
				// Update the UI
				updateSessionsList();
				
				// Show feedback
				const notification = document.createElement('div');
				notification.textContent = `Deleted: ${sessionName}`;
				notification.style.position = 'fixed';
				notification.style.bottom = '20px';
				notification.style.right = '20px';
				notification.style.background = 'rgba(200, 50, 50, 0.8)';
				notification.style.color = 'white';
				notification.style.padding = '10px 15px';
				notification.style.borderRadius = '4px';
				notification.style.zIndex = '9999';
				notification.style.transition = 'opacity 0.5s ease';
				
				document.body.appendChild(notification);
				
				setTimeout(() => {
					notification.style.opacity = '0';
					setTimeout(() => notification.remove(), 500);
				}, 1500);
			}

			function createNewSession() {
				// Clear all notes
				clearAllNotes();
				
				// Reset grid to default size
				maxGridWidth = INITIAL_GRID_CELLS * GRID_CELL_WIDTH;
				updateGridSize();
				
				// Prompt for a name
				const sessionName = prompt("Enter a name for your new session:", "New Session");
				if (!sessionName) return; // User cancelled
				
				// Create a blank session
				const sessionData = {
					name: sessionName,
					blocks: [],
					tempo: parseInt(tempoInput.value) || 120,
					maxGridWidth: maxGridWidth
				};
				
				// Save session
				let sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				sessions.push(sessionData);
				
				// Update current session index to point to this new session
				currentSessionIndex = sessions.length - 1;
				
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				
				// Update UI
				updateSessionsList();
			}


			// Modified clear function to ensure grid is properly cleared
			function clearAllNotes() {
				// Remove all note blocks from the grid
				const blocks = document.querySelectorAll('.note-block');
				blocks.forEach(block => {
					block.remove();
				});
				
				// Reset noteBlocks array
				noteBlocks = [];
			}

			function initInstrumentSelectors() {
				const selectors = document.querySelectorAll('.instrument-selector');
				
				selectors.forEach(selector => {
					selector.addEventListener('click', function() {
						// Remove active class from all selectors
						selectors.forEach(s => s.classList.remove('active'));
						
						// Add active class to clicked selector
						selector.classList.add('active');
						
						// Set current instrument
						currentInstrument = selector.dataset.instrument;
					});
				});
			}

			// Replace the existing grid container click event with these new mouse event handlers
			let isDrawing = false;
			let drawStartX = 0;
			let drawStartY = 0;
			let currentDrawBlock = null;
			let currentInstrument = 'sine';
			let instrumentColors = {
				'sine': '#5b87ff',
				'square': '#ff5b87',
				'sawtooth': '#5bff87',
				'triangle': '#ffb75b',
				'piano': '#b75bff'
			};

			// Handle mousedown to start drawing
			gridContainer.addEventListener('mousedown', function(e) {
				// Don't create a block if we're clicking on an existing block
				if (e.target.closest('.note-block')) return;
				if (e.button !== 0) return; // Only respond to left-click
				
				isDrawing = true;
				
				const rect = gridContainer.getBoundingClientRect();
				const x = e.clientX - rect.left;
				const y = e.clientY - rect.top;
				
				// Snap to grid
				drawStartX = Math.floor(x / GRID_CELL_WIDTH) * GRID_CELL_WIDTH;
				drawStartY = Math.floor(y / NOTE_HEIGHT) * NOTE_HEIGHT + 2;
				
				// Get note index based on y position
				const noteIndex = Math.floor(drawStartY / NOTE_HEIGHT);
				
				// Only create if within piano key range
				if (noteIndex < pianoContainer.children.length) {
					// Create initial block
					currentDrawBlock = createNoteBlock(drawStartX, drawStartY, GRID_CELL_WIDTH, noteIndex, true, currentInstrument);
				}
			});

			// Handle mousemove to extend the block
			gridContainer.addEventListener('mousemove', function(e) {
				if (!isDrawing || !currentDrawBlock) return;
				
				const rect = gridContainer.getBoundingClientRect();
				const x = e.clientX - rect.left;
				
				// Calculate width based on how far we've dragged
				let width = Math.max(GRID_CELL_WIDTH, x - drawStartX);
				width = Math.ceil(width / GRID_CELL_WIDTH) * GRID_CELL_WIDTH;
				
				// Update the block width
				currentDrawBlock.style.width = `${width}px`;
			});

			// Handle mouseup to finish drawing
			gridContainer.addEventListener('mouseup', function(e) {
				isDrawing = false;
				currentDrawBlock = null;
			});

			// Handle mouseleave to finish drawing if we leave the grid
			gridContainer.addEventListener('mouseleave', function(e) {
				isDrawing = false;
				currentDrawBlock = null;
			});

            // Animation function for playhead
            function animate(timestamp) {
                if (!lastTimestamp) lastTimestamp = timestamp;
                
                const deltaTime = timestamp - lastTimestamp;
                lastTimestamp = timestamp;
                
                const tempo = parseInt(tempoInput.value);
                const pixelsPerBeat = GRID_CELL_WIDTH;
                const pixelsPerSecond = (tempo / 60) * pixelsPerBeat;
                const pixelsDelta = (pixelsPerSecond * deltaTime) / 1000;
                
                currentPosition += pixelsDelta;
                
                // Loop back to start if we reach the end of the grid
                if (currentPosition > MAX_GRID_WIDTH) {
                    currentPosition = 0;
                }
                
                playhead.style.left = `${currentPosition}px`;
                
                // Play notes at current position
                playNotesAtPosition(currentPosition);
                
                if (isPlaying) {
                    animationFrameId = requestAnimationFrame(animate);
                }
            }

			function addGridControlButtons() {
				// Create container for grid control buttons
				const controlsContainer = document.createElement('div');
				controlsContainer.className = 'grid-controls';
				
				// Add extend button
				const extendButton = document.createElement('button');
				extendButton.innerHTML = '+';
				extendButton.title = 'Add 4 more beats';
				extendButton.className = 'grid-control-btn';
				
				// Add shrink button
				const shrinkButton = document.createElement('button');
				shrinkButton.innerHTML = '-';
				shrinkButton.title = 'Remove 4 beats';
				shrinkButton.className = 'grid-control-btn';
				
				// Add event listeners that stop event propagation
				extendButton.addEventListener('click', function(e) {
					e.stopPropagation(); // Stop event from bubbling up to the grid
					maxGridWidth += 4 * GRID_CELL_WIDTH;
					updateGridSize();
				});
				
				shrinkButton.addEventListener('click', function(e) {
					e.stopPropagation(); // Stop event from bubbling up to the grid
					// Don't allow less than the initial size
					if (maxGridWidth > INITIAL_GRID_CELLS * GRID_CELL_WIDTH) {
						maxGridWidth -= 4 * GRID_CELL_WIDTH;
						updateGridSize();
					}
				});
				
				// Also prevent mousedown events from propagating
				extendButton.addEventListener('mousedown', function(e) {
					e.stopPropagation();
				});
				
				shrinkButton.addEventListener('mousedown', function(e) {
					e.stopPropagation();
				});
				
				// Add buttons to container
				controlsContainer.appendChild(shrinkButton);
				controlsContainer.appendChild(extendButton);
				
				// Add container to grid
				gridContainer.appendChild(controlsContainer);
			}

			// Update grid size and draw end marker
			function updateGridSize() {
				// Force grid container to have the correct styles
				gridContainer.style.backgroundImage = 'linear-gradient(to right, #333 1px, transparent 1px), linear-gradient(to bottom, #333 1px, transparent 1px)';
				gridContainer.style.backgroundSize = `${GRID_CELL_WIDTH}px ${NOTE_HEIGHT}px`;
				gridContainer.style.backgroundColor = '#1a1a1a';
				
				// Clear all existing indicators and markers
				const existingElements = document.querySelectorAll('.beat-indicator, .grid-end-marker, .active-grid-area, .inactive-grid-area');
				existingElements.forEach(element => element.remove());
				
				// Important: We don't want to limit the active area on the left side
				// The active area should start at position 0 and extend to maxGridWidth
				
				// Create active grid area (always created fresh)
				const activeArea = document.createElement('div');
				activeArea.className = 'active-grid-area';
				activeArea.style.width = `${maxGridWidth}px`;
				activeArea.style.left = '0px';
				activeArea.style.backgroundColor = 'transparent';
				activeArea.style.zIndex = '1';
				
				// Create inactive grid area to the right of maxGridWidth
				const inactiveArea = document.createElement('div');
				inactiveArea.className = 'inactive-grid-area';
				inactiveArea.style.left = `${maxGridWidth}px`;
				inactiveArea.style.width = `${MAX_GRID_WIDTH - maxGridWidth}px`;
				inactiveArea.style.zIndex = '1';
				
				// Create end marker
				const endMarker = document.createElement('div');
				endMarker.id = 'grid-end-marker';
				endMarker.className = 'grid-end-marker';
				endMarker.style.left = `${maxGridWidth}px`;
				
				// Add elements to grid in the correct order
				gridContainer.appendChild(activeArea);
				gridContainer.appendChild(inactiveArea);
				gridContainer.appendChild(endMarker);
				
				// Add beat indicators
				addBeatIndicators();
			}

			// Update the animation function
			function animate(timestamp) {
				if (!lastTimestamp) lastTimestamp = timestamp;
				
				const deltaTime = timestamp - lastTimestamp;
				lastTimestamp = timestamp;
				
				const tempo = parseInt(tempoInput.value);
				const pixelsPerBeat = GRID_CELL_WIDTH;
				const pixelsPerSecond = (tempo / 60) * pixelsPerBeat;
				const pixelsDelta = (pixelsPerSecond * deltaTime) / 1000;
				
				currentPosition += pixelsDelta;
				
				// Loop back to start if we reach the max grid width
				if (currentPosition > maxGridWidth) {
					currentPosition = 0;
				}
				
				playhead.style.left = `${currentPosition}px`;
				
				// Play notes at current position
				playNotesAtPosition(currentPosition);
				
				if (isPlaying) {
					animationFrameId = requestAnimationFrame(animate);
				}
			}

			function addBeatIndicators() {
				// Remove existing indicators
				const existingIndicators = document.querySelectorAll('.beat-indicator');
				existingIndicators.forEach(indicator => indicator.remove());
				
				// Create beat numbers at the top
				for (let i = 0; i <= maxGridWidth / GRID_CELL_WIDTH; i++) {
					// Add a stronger indicator every 4 beats (one bar)
					const isMeasure = i % 4 === 0;
					
					const indicator = document.createElement('div');
					indicator.className = `beat-indicator ${isMeasure ? 'measure' : 'beat'}`;
					indicator.style.left = `${i * GRID_CELL_WIDTH}px`;
					
					if (isMeasure) {
						// Add measure number
						const label = document.createElement('div');
						label.innerHTML = Math.floor(i / 4) + 1;
						label.className = 'beat-label';
						indicator.appendChild(label);
					}
					
					gridContainer.appendChild(indicator);
				}
			}

            // Play notes that the playhead is currently crossing
			function playNotesAtPosition(position) {
				noteBlocks.forEach(block => {
					const blockLeft = parseInt(block.style.left);
					const blockWidth = parseInt(block.style.width);
					
					// Check if the playhead just crossed the start of this note block
					if (position >= blockLeft && position <= blockLeft + 5) {
						const noteData = block.dataset.note;
						if (noteData) {
							const note = noteData.slice(0, -1); // Remove the octave
							const octave = parseInt(noteData.slice(-1));
							const duration = (blockWidth / GRID_CELL_WIDTH) * (60 / parseInt(tempoInput.value));
							const isSustained = block.dataset.sustained === 'true';
							const instrument = block.dataset.instrument || 'sine';
							playNote(note, octave, duration, isSustained, instrument);
						}
					}
				});
			}

			// Track management functions
			function initTracks() {
				// Create default track if none exist
				if (!window.tracks) {
					window.tracks = [];
					const defaultTrack = {
						name: 'Track 1', 
						instrument: 'sine',
						blocks: [],
						isMuted: false,
						isSolo: false
					};
					window.tracks.push(defaultTrack);
					window.currentTrackIndex = 0;
				}
				
				updateTracksList();
			}

			function setupTracksPanel() {
				const trackToggle = document.getElementById('track-toggle');
				const tracksContainer = document.getElementById('tracks-container');
				
				if (!trackToggle || !tracksContainer) {
					console.error("Track panel elements not found");
					return;
				}
				
				trackToggle.addEventListener('click', function() {
					tracksContainer.classList.toggle('open');
					trackToggle.classList.toggle('open');
				});
			}

			function updateTracksList() {
				const tracksList = document.getElementById('tracks-list');
				if (!tracksList) return;
				
				tracksList.innerHTML = '';
				
				if (window.tracks && window.tracks.length) {
					window.tracks.forEach((track, index) => {
						const trackItem = document.createElement('div');
						trackItem.className = `track-item ${index === window.currentTrackIndex ? 'active' : ''}`;
						
						// Add track name
						const nameSpan = document.createElement('span');
						nameSpan.textContent = track.name;
						nameSpan.style.flexGrow = '1';
						trackItem.appendChild(nameSpan);
						
						// Add controls div
						const controlsDiv = document.createElement('div');
						controlsDiv.style.display = 'flex';
						controlsDiv.style.gap = '5px';
						
						// Add mute button with clear labeling
						const muteBtn = document.createElement('button');
						muteBtn.textContent = track.isMuted ? 'Unmute' : 'Mute';
						muteBtn.title = track.isMuted ? 'Click to unmute track' : 'Click to mute track';
						muteBtn.style.padding = '2px 6px';
						muteBtn.style.backgroundColor = track.isMuted ? '#ff5b5b' : '#3c3c3c';
						muteBtn.style.color = '#f0f0f0';
						muteBtn.style.border = 'none';
						muteBtn.style.borderRadius = '4px';
						muteBtn.style.fontSize = '10px';
						muteBtn.style.cursor = 'pointer';
						
						muteBtn.addEventListener('click', (e) => {
							e.stopPropagation();
							track.isMuted = !track.isMuted;
							updateTracksList();
						});
						
						controlsDiv.appendChild(muteBtn);
						trackItem.appendChild(controlsDiv);
						
						// Make the whole track item clickable to select track
						trackItem.addEventListener('click', () => {
							window.currentTrackIndex = index;
							updateTracksList();
						});
						
						tracksList.appendChild(trackItem);
					});
				}
			}

			function initGrid() {
				gridContainer.style.backgroundImage = 'linear-gradient(to right, #333 1px, transparent 1px), linear-gradient(to bottom, #333 1px, transparent 1px)';
				gridContainer.style.backgroundSize = `${GRID_CELL_WIDTH}px ${NOTE_HEIGHT}px`;
				gridContainer.style.backgroundColor = '#1a1a1a';
			}

            // Play/Stop functionality
            playBtn.addEventListener('click', function() {
                initAudio();
                if (!isPlaying) {
                    isPlaying = true;
                    lastTimestamp = 0;
                    animationFrameId = requestAnimationFrame(animate);
                    playBtn.textContent = 'Pause';
                } else {
                    isPlaying = false;
                    cancelAnimationFrame(animationFrameId);
                    playBtn.textContent = 'Play';
                }
            });

            stopBtn.addEventListener('click', function() {
                isPlaying = false;
                cancelAnimationFrame(animationFrameId);
                currentPosition = 0;
                playhead.style.left = '0px';
                playBtn.textContent = 'Play';
            });

            // Clear all note blocks
			clearBtn.addEventListener('click', clearAllNotes);

			// Connect the save button to the saveCurrentSession function
			document.getElementById('save-btn').addEventListener('click', saveCurrentSession);

			// Connect the new session button to the createNewSession function
			document.getElementById('new-session-btn').addEventListener('click', createNewSession);

			const deleteSessionBtn = document.createElement('button');
			deleteSessionBtn.id = 'delete-session-btn';
			deleteSessionBtn.textContent = 'Delete Session';
			deleteSessionBtn.addEventListener('click', function() {
				if (currentSessionIndex >= 0) {
					deleteSession(currentSessionIndex);
				} else {
					alert('No session currently selected.');
				}
			});
			const toolbar = document.querySelector('.toolbar');
			toolbar.appendChild(deleteSessionBtn);

            // Initialize the app
            createPianoKeys();
			initInstrumentSelectors();
			updateSessionsList();
			initGrid();
			addGridControlButtons();
			updateGridSize();
			loadSavedSessions();
			initTracks();
			setupTracksPanel();
			initSampleSystem();
			initSamplesModule();
			setupAutoSave();
			
        });
    </script>
</body>
</html>