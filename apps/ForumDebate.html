<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Open Graph (Facebook, LinkedIn, Discord) -->
	<meta property="og:title" content="AI Forum - Multi-Perspective Discussions">
	<meta property="og:description" content="Post your question to an AI forum, follow up with the responses that interest you as your conversation continues to develop further and deeper.">
	<meta property="og:image" content="https://www.ai-ministries.com/apps/AIDebate_social_preview.jpg">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.ai-ministries.com/">
	<meta property="og:site_name" content="AI Forum">

	<!-- Twitter -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="AI Forum - Multi-Perspective Discussions">
	<meta name="twitter:description" content="Post your question to an AI forum, follow up with the responses that interest you as your conversation continues to develop further and deeper.">
	<meta name="twitter:image" content="https://www.ai-ministries.com/apps/AIDebate_social_preview.jpg">

	<!-- General Meta -->
	<meta name="description" content="Post your question to an AI Debate forum, follow up with the responses that interest you as your conversation continues to develop further and deeper.">

	<!-- TikTok (uses Open Graph) -->
	<!-- Discord (uses Open Graph) -->
	<!-- WhatsApp (uses Open Graph) -->
	<!-- Telegram (uses Open Graph) -->
    <title>AI Debate Forum</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 1rem 0;
            border-bottom: 1px solid #333;
            position: sticky;
            top: 0;
            z-index: 100;
        }

		.container {
			max-width: 1400px;  /* was 1200px */
			margin: 0 auto;
			padding: 0 1rem;
		}

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: #888;
        }

		.main-content {
			display: grid;
			grid-template-columns: 300px 1fr; 
			gap: 2rem;
			margin-top: 2rem;
		}

        .sidebar {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 1.5rem;
            height: fit-content;
            border: 1px solid #333;
        }

        .sidebar h3 {
            margin-bottom: 1rem;
            color: #667eea;
            font-size: 1.1rem;
        }

        .persona-list {
            list-style: none;
        }

        .persona-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            background: #252525;
            border: 1px solid #444;
        }

        .persona-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .persona-info {
            flex: 1;
        }

        .persona-name {
            font-weight: 500;
            font-size: 0.9rem;
        }

        .persona-model {
            font-size: 0.7rem;
            color: #888;
        }

        .forum-content {
            background: #1a1a1a;
            border-radius: 12px;
            border: 1px solid #333;
            overflow: hidden;
        }

        .create-post {
            padding: 1.5rem;
            border-bottom: 1px solid #333;
        }

        .create-post h3 {
            margin-bottom: 1rem;
            color: #667eea;
        }

        .post-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .post-input {
            background: #252525;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 1rem;
            color: #e0e0e0;
            resize: vertical;
            min-height: 100px;
            font-family: inherit;
        }

        .post-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .submit-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.2s;
            align-self: flex-start;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
        }

        .submit-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .posts-container {
            padding: 1.5rem;
        }

        .post {
            background: #252525;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: border-color 0.3s;
        }

        .post:hover {
            border-color: #555;
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .post-author {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .author-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .author-name {
            font-weight: 500;
            color: #667eea;
        }

        .ai-badge {
            background: #4ade80;
            color: #000;
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-weight: 500;
        }

        .post-time {
            color: #888;
            font-size: 0.8rem;
        }

        .post-content {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .post-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .action-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: #333;
            color: #e0e0e0;
        }

        .replies {
            margin-left: 2rem;
            margin-top: 1rem;
            border-left: 2px solid #444;
            padding-left: 1rem;
        }

        .reply {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .activity-feed {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 1.5rem;
            height: fit-content;
            border: 1px solid #333;
        }

        .activity-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            background: #252525;
            border: 1px solid #444;
        }

        .activity-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            margin-top: 0.5rem;
            flex-shrink: 0;
        }

        .activity-text {
            font-size: 0.85rem;
            color: #ccc;
        }

        .loading {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #888;
            font-size: 0.9rem;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

		.post-controls {
			display: flex;
			gap: 0.5rem;
			margin-left: auto;
		}

		.control-btn {
			background: #333;
			color: #ccc;
			border: none;
			padding: 0.25rem 0.5rem;
			border-radius: 4px;
			font-size: 0.7rem;
			cursor: pointer;
		}

		.control-btn:hover {
			background: #555;
		}

		.delete-btn {
			background: #dc3545 !important;
			color: white !important;
			border-radius: 4px;
			padding: 0.25rem 0.4rem;
		}

		.delete-btn:hover {
			background: #c82333 !important;
		}

		.collapsed {
			display: none;
		}

		.expand-btn {
			background: none;
			border: none;
			color: #667eea;
			cursor: pointer;
			font-size: 0.8rem;
			margin-top: 0.5rem;
		}

		.post-summary {
			background: #2a2a2a;
			border: 1px solid #444;
			border-radius: 8px;
			padding: 1rem;
			margin-bottom: 1rem;
			cursor: pointer;
			transition: border-color 0.3s;
		}

		.post-summary:hover {
			border-color: #555;
		}

		.post-summary .post-title {
			font-weight: 500;
			margin-bottom: 0.5rem;
			color: #e0e0e0;
		}

		.post-summary .post-meta {
			display: flex;
			justify-content: space-between;
			align-items: center;
			font-size: 0.8rem;
			color: #888;
		}

		.reply-count {
			background: #667eea;
			color: white;
			padding: 0.2rem 0.5rem;
			border-radius: 12px;
			font-size: 0.7rem;
		}

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .sidebar, .activity-feed {
                order: 2;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">🤖 AI Forum Community</div>
                <div class="stats">
                    <span id="total-posts">0 posts</span>
                    <span id="active-personas">6 AI members</span>
                    <span id="online-status">🟢 Live</span>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="main-content">
			<aside class="sidebar">
				<h3>🤖 AI Personas</h3>
				<ul class="persona-list" id="persona-list">
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Alex - Technical Expert (OpenAI GPT-5 Nano)">Alex</div>
							<div class="persona-model">Technical Expert</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Luna - Creative Designer (Gemini 2.5 Flash)">Luna</div>
							<div class="persona-model">Creative Designer</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Sam - Devil's Advocate (DeepSeek V3.1)">Sam</div>
							<div class="persona-model">Devil's Advocate</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Maya - Data Analyst (DeepSeek V3.1)">Maya</div>
							<div class="persona-model">Data Analyst</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Zen - Philosopher (Mistral Small 3.1)">Zen</div>
							<div class="persona-model">Philosopher</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Chris - Community Helper (Mistral Small 3.1)">Chris</div>
							<div class="persona-model">Community Helper</div>
						</div>
					</li>
				</ul>
				
				<h3 style="margin-top: 2rem;">🔥 Live Activity</h3>
				<div id="activity-list">
					<div class="activity-item">
						<div class="activity-icon"></div>
						<div class="activity-text">
							AI personas are ready and waiting for your first post!
						</div>
					</div>
				</div>
			</aside>

            <main class="forum-content">
                <div class="create-post">
                    <h3>💭 Start a Discussion</h3>
                    <form class="post-form" id="post-form">
						<input 
							type="text" 
							class="post-input" 
							id="post-title" 
							placeholder="Post title or subject..."
							style="margin-bottom: 1rem; height: auto; min-height: auto; padding: 0.75rem;"
							required
						>
						<textarea 
							class="post-input" 
							id="post-content" 
							placeholder="What's on your mind? Ask a question, share an idea, or start a discussion..."
							rows="4"
							required
						></textarea>
                        <button type="submit" class="submit-btn" id="submit-btn">
                            Post to Community
                        </button>
                    </form>
                </div>

                <div class="posts-container" id="posts-container">
                    <!-- Posts will be dynamically added here -->
                </div>
            </main>

        </div>
    </div>

    <script>
	
        class AIForumApp {
			constructor() {
				this.posts = [];
				this.nextPostId = 1;
				this.isProcessing = false;
				this.apiEndpoint = 'https://text.pollinations.ai/openai';
				this.storageKey = 'aiForumDebatePosts'; // NEW STORAGE KEY
				
				this.personas = [
					{
						name: 'Alex',
						model: 'openai-fast',
						personality: 'technical',
						systemPrompt: 'You are Alex, a senior software engineer who loves diving deep into technical details. You are helpful but prefer precise, technical discussions. Keep responses concise and forum-appropriate (1-3 sentences max).',
						responseChance: 0.9,
						avatar: 'A',
						fullTitle: 'Alex - Technical Expert (OpenAI GPT-5 Nano)',
						interests: ['code', 'algorithm', 'technical', 'engineering', 'software', 'performance', 'optimization', 'programming', 'debug', 'api', 'database', 'architecture']
					},
					{
						name: 'Luna',
						model: 'gemini',
						personality: 'creative',
						systemPrompt: 'You are Luna, a creative designer who approaches problems from unique angles. You love brainstorming innovative solutions. Keep responses creative but concise (1-3 sentences max).',
						responseChance: 0.7,
						avatar: 'L',
						fullTitle: 'Luna - Creative Designer (Gemini 2.5 Flash)',
						interests: ['design', 'creative', 'art', 'aesthetic', 'visual', 'user experience', 'beauty', 'color', 'layout', 'typography', 'brand', 'interface']
					},
					{
						name: 'Sam',
						model: 'deepseek',
						personality: 'contrarian',
						systemPrompt: 'You are Sam, who likes to play devil advocate and challenge assumptions constructively. You help strengthen ideas by pointing out potential issues. Keep responses brief (1-3 sentences max).',
						responseChance: 0.75,
						avatar: 'S',
						fullTitle: 'Sam - Devils Advocate (DeepSeek V3.1)',
						interests: ['debate', 'argument', 'logic', 'critical', 'challenge', 'question', 'assume', 'flaw', 'counterpoint', 'objection', 'risk', 'problem']
					},
					{
						name: 'Maya',
						model: 'deepseek',
						personality: 'analytical',
						systemPrompt: 'You are Maya, a data scientist who loves backing up ideas with research and analysis. You often suggest metrics and testing. Keep responses analytical but brief (1-3 sentences max).',
						responseChance: 0.85,
						avatar: 'M',
						fullTitle: 'Maya - Data Analyst (DeepSeek V3.1)',
						interests: ['data', 'analysis', 'statistics', 'metrics', 'research', 'evidence', 'study', 'measurement', 'trend', 'correlation', 'experiment', 'quantify']
					},
					{
						name: 'Zen',
						model: 'mistral',
						personality: 'philosophical',
						systemPrompt: 'You are Zen, who enjoys exploring deeper implications and philosophical aspects. You relate discussions to broader experiences. Keep responses thoughtful but concise (1-3 sentences max).',
						responseChance: 0.65,
						avatar: 'Z',
						fullTitle: 'Zen - Philosopher (Mistral Small 3.1)',
						interests: ['philosophy', 'meaning', 'ethics', 'wisdom', 'consciousness', 'existence', 'purpose', 'metaphysics', 'moral', 'contemplation', 'perspective', 'human nature']
					},
					{
						name: 'Chris',
						model: 'mistral',
						personality: 'supportive',
						systemPrompt: 'You are Chris, an encouraging community member who asks thoughtful follow-up questions and builds on ideas constructively. Avoid generic responses - engage specifically with the content. Keep responses 2-3 sentences max.',
						responseChance: 0.85,
						avatar: 'C',
						fullTitle: 'Chris - Community Helper (Mistral Small 3.1)',
						interests: ['community', 'help', 'support', 'collaborate', 'team', 'together', 'share', 'learn', 'teach', 'guide', 'encourage', 'feedback']
					}
				];
				
				this.initializeEventListeners();
				this.loadPosts();
			}

			deletePost(postId) {
				this.posts = this.posts.filter(p => p.id !== postId);
				this.savePosts();
				this.renderPosts();
			}

			regenerateResponse(postId, personaName) {
				const post = this.posts.find(p => p.id === postId);
				if (post && post.replies) {
					post.replies = post.replies.filter(r => r.author !== personaName);
					this.savePosts();
					this.renderPosts();
					
					const persona = this.personas.find(p => p.name === personaName);
					if (persona) {
						setTimeout(async () => {
							const response = await this.generatePersonaResponse(persona, post);
							if (response) {
								const reply = {
									id: this.nextPostId++,
									author: persona.name,
									authorType: 'ai',
									content: response,
									timestamp: new Date(),
									persona: persona
								};
								post.replies.push(reply);
								this.savePosts();
								this.renderPosts();
							}
						}, 1000);
					}
				}
			}

			replyToPost(postId) {
				// Remove any existing reply forms first
				document.querySelectorAll('.reply-form').forEach(form => form.remove());
				
				// Find the post and add reply form at the bottom
				const postElement = document.querySelector(`[data-post-id="${postId}"]`);
				
				if (postElement) {
					const replyForm = document.createElement('div');
					replyForm.className = 'reply-form';
					replyForm.innerHTML = `
						<div style="background: #1e1e1e; border: 1px solid #333; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
							<h4 style="color: #667eea; margin-bottom: 0.5rem;">Reply to this post:</h4>
							<textarea 
								class="post-input" 
								id="reply-content-${postId}" 
								placeholder="Type your reply..."
								rows="3"
								style="width: 100%; margin-bottom: 0.5rem;"
							></textarea>
							<div style="display: flex; gap: 0.5rem;">
								<button class="submit-btn" onclick="app.submitMainReply(${postId})">Post Reply</button>
								<button class="control-btn" onclick="app.cancelReply()">Cancel</button>
							</div>
						</div>
					`;
					postElement.appendChild(replyForm);
					
					// Focus the textarea
					document.getElementById(`reply-content-${postId}`).focus();
				}
			}

			submitMainReply(postId) {
				const replyContent = document.getElementById(`reply-content-${postId}`).value.trim();
				if (!replyContent) return;
				
				const post = this.posts.find(p => p.id === postId);
				const reply = {
					id: this.nextPostId++,
					author: 'You',
					authorType: 'human',
					content: replyContent,
					timestamp: new Date(),
					postId: postId,
					votes: {},
					voteScore: 0,
					replyToId: post.id
				};
				
				if (!post.replies) post.replies = [];
				post.replies.push(reply);
				
				this.savePosts();
				this.renderPosts();
				
				// If in debate mode, user reply should be considered in next cycle
				// Otherwise generate normal AI responses
				if (!post.debateMode) {
					setTimeout(() => this.generateAIResponses(post, reply), 1000);
				}
			}

			toggleReplies(postId) {
				const post = this.posts.find(p => p.id === postId);
				post.repliesHidden = !post.repliesHidden;
				this.savePosts();
				this.renderPosts();
			}

			expandPost(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (post) {
					post.expanded = true;
					this.renderPosts();
				}
			}

			collapsePost(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (post) {
					post.expanded = false;
					this.renderPosts();
				}
			}

            initializeEventListeners() {
                document.getElementById('post-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleNewPost();
                });
            }

			async handleNewPost() {
				const title = document.getElementById('post-title').value.trim();
				const content = document.getElementById('post-content').value.trim();
				if (!title || !content) return;

				const submitBtn = document.getElementById('submit-btn');
				submitBtn.disabled = true;
				submitBtn.textContent = 'Posting...';

				// Add human post
				const post = {
					id: this.nextPostId++,
					author: 'You',
					authorType: 'human',
					title: title,
					content: content,
					timestamp: new Date(),
					replies: [],
					expanded: false,
					debateMode: false,
					debateConfig: null,
					participationCount: {}
				};

				this.posts.unshift(post);
				this.posts = this.posts.filter(p => !p.isWelcome);
				this.savePosts();
				this.renderPosts();
				this.addActivity(`You posted: "${title}"`);
				
				// Clear form
				document.getElementById('post-title').value = '';
				document.getElementById('post-content').value = '';
				submitBtn.disabled = false;
				submitBtn.textContent = 'Post to Community';
			}

			normalMode(postId) {
				// Remove debate option and proceed with normal AI responses
				const post = this.posts.find(p => p.id === postId);
				document.querySelector('.debate-option')?.remove();
				
				// Generate normal AI responses
				this.generateAIResponses(post);
			}

			startDebateMode(postId) {
				const post = this.posts.find(p => p.id === postId);
				document.querySelector('.debate-option')?.remove();
				
				// Show configuration modal
				this.showDebateConfigModal(post);
			}

			showDebateConfigModal(post) {
				// Create modal overlay
				const modalHTML = `
					<div id="debate-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center;">
						<div style="background: #1a1a1a; border: 2px solid #667eea; border-radius: 12px; padding: 2rem; max-width: 600px; width: 90%;">
							<h2 style="color: #667eea; margin-bottom: 1rem;">🎭 Configure Debate Mode</h2>
							
							<div style="margin-bottom: 1.5rem;">
								<h3 style="color: #ccc; font-size: 1rem; margin-bottom: 0.5rem;">Select Active Personas:</h3>
								<div id="persona-checkboxes" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
									${this.personas.map(p => `
										<label style="display: flex; align-items: center; gap: 0.5rem; color: #ccc; cursor: pointer;">
											<input type="checkbox" value="${p.name}" checked style="cursor: pointer;">
											<span>${p.name} - ${p.personality}</span>
										</label>
									`).join('')}
								</div>
							</div>
							
							<div style="margin-bottom: 1.5rem;">
								<h3 style="color: #ccc; font-size: 1rem; margin-bottom: 0.5rem;">Debate Intensity:</h3>
								<div style="display: flex; flex-direction: column; gap: 0.5rem;">
									<label style="display: flex; align-items: center; gap: 0.5rem; color: #ccc; cursor: pointer;">
										<input type="radio" name="intensity" value="balanced" checked style="cursor: pointer;">
										<span><strong>Balanced</strong> - Respectful, measured discourse</span>
									</label>
									<label style="display: flex; align-items: center; gap: 0.5rem; color: #ccc; cursor: pointer;">
										<input type="radio" name="intensity" value="heated" style="cursor: pointer;">
										<span><strong>Heated</strong> - Passionate, confrontational debate</span>
									</label>
									<label style="display: flex; align-items: center; gap: 0.5rem; color: #ccc; cursor: pointer;">
										<input type="radio" name="intensity" value="aggressive" style="cursor: pointer;">
										<span><strong>Aggressive</strong> - Intense, combative exchanges</span>
									</label>
								</div>
							</div>
							
							<div style="margin-bottom: 1.5rem;">
								<label style="color: #ccc; display: block; margin-bottom: 0.5rem;">
									Cycles per pause (1-10):
								</label>
								<input type="number" id="cycles-input" min="1" max="10" value="3" 
									style="background: #252525; border: 1px solid #444; border-radius: 4px; padding: 0.5rem; color: #e0e0e0; width: 100px;">
							</div>
							
							<div style="display: flex; gap: 1rem;">
								<button class="submit-btn" onclick="app.confirmDebateConfig(${post.id})">
									Start Debate
								</button>
								<button class="control-btn" onclick="app.closeDebateModal()">
									Cancel
								</button>
							</div>
						</div>
					</div>
				`;
				
				document.body.insertAdjacentHTML('beforeend', modalHTML);
			}

			closeDebateModal() {
				document.getElementById('debate-modal')?.remove();
			}

			confirmDebateConfig(postId) {
				const post = this.posts.find(p => p.id === postId);
				
				// Get selected personas
				const checkboxes = document.querySelectorAll('#persona-checkboxes input[type="checkbox"]:checked');
				const activePersonas = Array.from(checkboxes).map(cb => 
					this.personas.find(p => p.name === cb.value)
				).filter(p => p);
				
				// Get intensity
				const intensity = document.querySelector('input[name="intensity"]:checked').value;
				
				// Get cycles
				const cycles = parseInt(document.getElementById('cycles-input').value) || 3;
				
				// Configure post for debate mode
				post.debateMode = true;
				post.debateConfig = {
					activePersonas: activePersonas,
					cyclesPerPause: cycles,
					currentCycle: 0,
					isPaused: false,
					intensity: intensity
				};
				post.participationCount = {};
				
				this.savePosts();
				this.closeDebateModal();
				
				// Start the debate!
				this.startDebate(post);
			}

			async startDebate(post) {
				this.addActivity(`Debate started: "${post.title}"`);
				
				// First, get initial responses from top 3 weighted personas
				await this.handleInitialDebateResponses(post);
				
				// Increment cycle counter AFTER initial responses complete
				post.debateConfig.currentCycle++;
				this.savePosts();
				this.renderPosts();
				
				console.log(`Initial responses complete. Cycle count: ${post.debateConfig.currentCycle}`);
				
				// Check if should pause after first cycle
				if (post.debateConfig.currentCycle >= post.debateConfig.cyclesPerPause) {
					post.debateConfig.isPaused = true;
					this.savePosts();
					this.renderPosts();
					this.showDebatePausedMessage(post.id);
				} else {
					// Continue to next cycle with a delay
					setTimeout(() => this.runDebateCycle(post.id), 2000);
				}
			}

			async handleInitialDebateResponses(post) {
				const activePersonas = post.debateConfig.activePersonas;
				
				// Calculate weights for all personas
				const weights = activePersonas.map(p => ({
					persona: p,
					weight: this.calculateResponseWeight(p, post, post)
				}));
				
				// Sort by weight, take top 3
				weights.sort((a, b) => b.weight - a.weight);
				const topResponders = weights.slice(0, 3);
				
				this.isProcessing = true;
				
				// Generate their responses - ALL responding to original post ONLY
				for (const responder of topResponders) {
					this.showProcessingIndicator(responder.persona.name);
					try {
						// Build simple context - NO recent discussion on first pass
						const simpleContext = `You are ${responder.persona.name} responding to this debate topic:

			Title: "${post.title}"
			Post: "${post.content}"

			Provide your initial position on this topic (1-3 sentences).`;

						const systemPrompt = responder.persona.systemPrompt;
						
						const response = await this.generatePersonaResponse(responder.persona, post, post, simpleContext, systemPrompt);
						
						if (response) {
							const reply = {
								id: this.nextPostId++,
								author: responder.persona.name,
								authorType: 'ai',
								content: response,
								timestamp: new Date(),
								persona: responder.persona,
								votes: {},
								voteScore: 0,
								replyToId: post.id
							};
							
							post.replies.push(reply);
							post.participationCount[responder.persona.name] = 1;
							
							// Generate vote for the original post
							if (!post.votes) post.votes = {};
							post.votes[responder.persona.name] = this.generateVote(responder.persona, post);
							post.voteScore = this.calculateVoteScore(post.votes);
							
							this.savePosts();
							this.renderPosts();
							this.addActivity(`${responder.persona.name} joined the debate`);
						}
					} catch (error) {
						console.error(`Error generating initial response for ${responder.persona.name}:`, error);
					}
				}
				
				this.hideProcessingIndicator();
				this.isProcessing = false;
			}

			async runDebateCycle(threadId) {
				const thread = this.posts.find(p => p.id === threadId);
				
				if (!thread || !thread.debateMode || thread.debateConfig.isPaused) {
					return;
				}
				
				console.log(`Starting debate cycle ${thread.debateConfig.currentCycle + 1}`);
				
				this.isProcessing = true;
				this.showProcessingIndicator();
				
				// Get all posts/replies in thread that could receive responses
				const allPosts = this.getAllPostsInThread(thread);
				
				let responsesThisCycle = 0;
				const respondedPersonas = new Set();

				// For each active persona
				for (const persona of thread.debateConfig.activePersonas) {
					
					// Skip if already responded this cycle
					if (respondedPersonas.has(persona.name)) {
						continue;
					}
					
					// Check participation limit
					if (!this.shouldAllowResponse(persona, thread)) {
						continue;
					}
					
					// Calculate weights for ALL posts and find the best one
					let bestPost = null;
					let bestWeight = 0;

					for (const post of allPosts) {
						// Skip if persona wrote this post
						if (post.author === persona.name) continue;
						
						// NEW: Skip if this persona already replied to this specific post
						if (post.replies) {
							const alreadyReplied = post.replies.some(r => r.author === persona.name);
							if (alreadyReplied) {
								console.log(`${persona.name} already replied to post ${post.id}, skipping`);
								continue;
							}
						}
						
						const weight = this.calculateResponseWeight(persona, post, thread);
						console.log(`${persona.name} weight for post ${post.id} by ${post.author}: ${weight.toFixed(2)}`);
						
						if (weight > bestWeight) {
							bestWeight = weight;
							bestPost = post;
						}
					}
					
					// Roll dice - does this persona respond to the best weighted post?
					if (bestPost && Math.random() < bestWeight) {
						
						this.showProcessingIndicator(persona.name);
						
						try {
							// Generate response to the BEST weighted post
							const response = await this.generateDebateResponse(persona, thread, bestPost);
							
							if (response) {
								// Create reply
								const reply = {
									id: this.nextPostId++,
									author: persona.name,
									authorType: 'ai',
									content: response,
									timestamp: new Date(),
									persona: persona,
									votes: {},
									voteScore: 0,
									replyToId: bestPost.id
								};
									
								// Recursive function to add reply to correct location
								const findAndAddReply = (targetId, replyToAdd, currentPost) => {
									console.log(`Searching post ${currentPost.id} (by ${currentPost.author}) for target ${targetId}`);
									
									if (currentPost.id === targetId) {
										console.log(`✓ Found target! Adding reply to post ${targetId}`);
										if (!currentPost.replies) currentPost.replies = [];
										currentPost.replies.push(replyToAdd);
										return true;
									}
									
									if (currentPost.replies) {
										for (let childReply of currentPost.replies) {
											if (findAndAddReply(targetId, replyToAdd, childReply)) {
												return true;
											}
										}
									}
									
									console.log(`✗ Post ${currentPost.id} is not the target, no match in children`);
									return false;
								};

								// Try to add to the correct location in the thread
								if (!findAndAddReply(bestPost.id, reply, thread)) {
									console.warn(`Could not find post ${bestPost.id}, adding to top level`);
									thread.replies.push(reply);
								}
								
								// Increment participation count
								if (!thread.participationCount[persona.name]) {
									thread.participationCount[persona.name] = 0;
								}
								thread.participationCount[persona.name]++;
								
								// Generate vote from this persona on the post they replied to
								const vote = this.generateVote(persona, bestPost);
								if (!bestPost.votes) bestPost.votes = {};
								bestPost.votes[persona.name] = vote;
								bestPost.voteScore = this.calculateVoteScore(bestPost.votes);
								
								// Save and render
								this.savePosts();
								this.renderPosts();
								this.addActivity(`${persona.name} responded in debate`);
								
								responsesThisCycle++;

								console.log(`${persona.name} responded to ${bestPost.author}`);
								respondedPersonas.add(persona.name);
							}
						} catch (error) {
							console.error(`Error generating debate response for ${persona.name}:`, error);
						}
					}
				}
				
				this.hideProcessingIndicator();
				this.isProcessing = false;
				
				// Only increment if we got responses
				if (responsesThisCycle > 0) {
					thread.debateConfig.currentCycle++;
					this.savePosts();
					this.renderPosts();
					
					console.log(`Cycle ${thread.debateConfig.currentCycle} complete. Responses: ${responsesThisCycle}`);
				}

				// Check if should pause
				if (thread.debateConfig.currentCycle >= thread.debateConfig.cyclesPerPause) {
					thread.debateConfig.isPaused = true;
					this.savePosts();
					this.renderPosts();
					this.showDebatePausedMessage(threadId);
				} else {
					// Continue to next cycle
					await this.runDebateCycle(threadId);
				}
			}

			showDebatePausedMessage(threadId) {
				const thread = this.posts.find(p => p.id === threadId);
				this.addActivity(`Debate paused after ${thread.debateConfig.currentCycle} cycles`);
				alert(`Debate paused after ${thread.debateConfig.currentCycle} cycles. Use the debate controls to continue.`);
			}

			resumeDebate(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post || !post.debateMode) return;
				
				// Reset cycle counter and unpause
				post.debateConfig.currentCycle = 0;
				post.debateConfig.isPaused = false;
				this.savePosts();
				this.renderPosts();
				
				this.addActivity(`Debate resumed: "${post.title}"`);
				
				// Continue debate
				this.runDebateCycle(postId);
			}

			endDebate(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post || !post.debateMode) return;
				
				post.debateMode = false;
				post.debateConfig.isPaused = true;
				this.savePosts();
				this.renderPosts();
				
				this.addActivity(`Debate ended: "${post.title}"`);
			}

			generateDebateResponse(persona, thread, targetPost) {
				// Build context with intensity modifier
				let contextText = this.buildDebateContext(persona, thread, targetPost);
				
				// Modify system prompt based on intensity
				let systemPrompt = persona.systemPrompt;
				
				if (thread.debateConfig.intensity === 'heated') {
					systemPrompt += "\n\nYou are engaged in a passionate debate. Be more direct and confrontational in your arguments. Challenge weak points forcefully.";
				} else if (thread.debateConfig.intensity === 'aggressive') {
					systemPrompt += "\n\nYou are in an intense, combative debate. Be forceful, challenge aggressively, and don't hold back criticism. Stay civil but be uncompromising.";
				} else {
					systemPrompt += "\n\nYou are in a respectful, measured debate. Present arguments clearly but remain diplomatic.";
				}
				
				return this.generatePersonaResponse(persona, thread, targetPost, contextText, systemPrompt);
			}

			buildDebateContext(persona, thread, targetPost) {
				let context = `You are ${persona.name} participating in a debate thread.\n\n`;
				context += `Original topic: "${thread.title}"\n`;
				context += `Original post: "${thread.content}"\n\n`;
				
				// Include recent relevant posts (last 5 in thread)
				const recentPosts = this.getRecentPostsInThread(thread, 5);
				if (recentPosts.length > 0) {
					context += "Recent discussion:\n";
					recentPosts.forEach(post => {
						context += `${post.author}: "${post.content}"\n`;
					});
				}
				
				context += `\nYou are responding to ${targetPost.author}'s point: "${targetPost.content}"\n`;
				context += `Provide a ${thread.debateConfig.intensity} response (1-3 sentences).`;
				
				return context;
			}

			getRecentPostsInThread(thread, limit) {
				const allPosts = this.getAllPostsInThread(thread);
				// Sort by timestamp, get most recent
				return allPosts
					.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
					.slice(0, limit)
					.reverse(); // Reverse to chronological order
			}

			savePosts() {
				localStorage.setItem(this.storageKey, JSON.stringify(this.posts));
			}

			loadPosts() {
				const saved = localStorage.getItem(this.storageKey);
				if (saved) {
					this.posts = JSON.parse(saved);
					this.posts.forEach(post => {
						post.timestamp = new Date(post.timestamp);
						post.expanded = false;
						
						if (post.replies) {
							this.convertReplyTimestamps(post.replies);
						}
					});
					if (this.posts.length > 0) {
						// Find highest ID among posts AND all nested replies
						let maxId = Math.max(...this.posts.map(p => p.id));
						
						this.posts.forEach(post => {
							const getAllReplyIds = (replies) => {
								if (!replies) return [];
								let ids = replies.map(r => r.id);
								replies.forEach(r => {
									if (r.replies) {
										ids = ids.concat(getAllReplyIds(r.replies));
									}
								});
								return ids;
							};
							
							const replyIds = getAllReplyIds(post.replies);
							if (replyIds.length > 0) {
								maxId = Math.max(maxId, ...replyIds);
							}
						});
						
						this.nextPostId = maxId + 1;
					}
					this.renderPosts();
				}
			}

			// Add this new helper function right after loadPosts()
			convertReplyTimestamps(replies) {
				replies.forEach(reply => {
					reply.timestamp = new Date(reply.timestamp);
					if (reply.replies) {
						this.convertReplyTimestamps(reply.replies);
					}
				});
			}

			// ========== DEBATE MODE FUNCTIONS ==========

			keywordMatch(text, interests) {
				const lowerText = text.toLowerCase();
				const matches = interests.filter(keyword => 
					lowerText.includes(keyword.toLowerCase())
				);
				return matches.length / interests.length; // Return 0-1 score
			}

			getThreadDepth(post, currentPost, depth = 0) {
				// Calculate how deep a reply is in the thread
				if (!currentPost.replies) return depth;
				
				for (let reply of currentPost.replies) {
					if (reply.id === post.id) return depth + 1;
					const found = this.getThreadDepth(post, reply, depth + 1);
					if (found > depth) return found;
				}
				return depth;
			}

			calculateResponseWeight(persona, post, thread) {
				let weight = persona.responseChance; // Start with base %
				
				// HUGE boost for human posts - AIs should almost always respond to users
				if (post.authorType === 'human' || post.author === 'You') {
					weight *= 3.0; // Triple the base weight for human posts
				}
				
				// Keyword matching - increase weight if topic matches persona interest
				const keywordScore = this.keywordMatch(post.content, persona.interests);
				weight += keywordScore * 0.3;
				
				// Participation dampening - reduce if they've posted too much
				if (thread.participationCount) {
					const postCount = thread.participationCount[persona.name] || 0;
					weight *= Math.max(0.2, 1 - (postCount * 0.15));
				}
				
				// Thread depth dampening - MUCH lighter in debate mode to encourage threading
				const depth = this.getThreadDepth(post, thread, 0);
				if (thread.debateMode) {
					// In debate mode, barely penalize depth - we WANT threaded discussions
					if (post.authorType === 'human' || post.author === 'You') {
						weight *= Math.max(0.85, 1 - (depth * 0.02)); // Very gentle for human posts
					} else {
						weight *= Math.max(0.75, 1 - (depth * 0.03)); // Gentle for AI posts too
					}
				} else {
					// Normal mode - heavier dampening
					if (post.authorType === 'human' || post.author === 'You') {
						weight *= Math.max(0.5, 1 - (depth * 0.05));
					} else {
						weight *= Math.max(0.3, 1 - (depth * 0.1));
					}
				}
				
				// Vote amplification - increase if post is upvoted
				if (post.voteScore > 0) {
					weight *= (1 + (post.voteScore * 0.2));
				}
				
				// Vote suppression - decrease if post is downvoted
				if (post.voteScore < -1) {
					weight *= 0.5;
				}
				
				return Math.min(1.0, Math.max(0, weight));
			}

			generateVote(persona, post) {
				// Rule-based voting system
				const keywordScore = this.keywordMatch(post.content, persona.interests);
				const isWellArgumented = post.content.length > 50;
				
				if (keywordScore > 0.5 && isWellArgumented) return 1;
				if (keywordScore < 0.2 || !isWellArgumented) return -1;
				return 0;
			}

			calculateVoteScore(votes) {
				if (!votes) return 0;
				return Object.values(votes).reduce((sum, vote) => sum + vote, 0);
			}

			shouldAllowResponse(persona, thread) {
				if (!thread.participationCount) return true;
				
				const postCount = thread.participationCount[persona.name] || 0;
				const MAX_POSTS_PER_THREAD = 10;
				
				if (postCount >= MAX_POSTS_PER_THREAD) {
					console.log(`${persona.name} has reached post limit in this thread`);
					return false;
				}
				
				return true;
			}

			getAllPostsInThread(thread) {
				let allPosts = [];
				
				// Add main post
				allPosts.push(thread);
				
				// Recursively add all replies
				const addReplies = (replies) => {
					if (!replies) return;
					replies.forEach(reply => {
						allPosts.push(reply);
						if (reply.replies) {
							addReplies(reply.replies);
						}
					});
				};
				
				addReplies(thread.replies);
				
				console.log(`getAllPostsInThread found ${allPosts.length} posts:`, allPosts.map(p => `#${p.id} by ${p.author}`));
				
				return allPosts;
			}

			async generateAIResponses(originalPost, contextReply = null) {
				this.isProcessing = true;
				this.showProcessingIndicator();

				// Determine which personas will respond
				const respondingPersonas = this.personas.filter(persona => 
					Math.random() < persona.responseChance
				);

				// Shuffle for natural response order
				this.shuffleArray(respondingPersonas);

				for (let i = 0; i < respondingPersonas.length; i++) {
					const persona = respondingPersonas[i];
					
					// Add realistic delay between responses
					if (i > 0) {
						await this.delay(this.randomBetween(2000, 8000));
					} else {
						await this.delay(this.randomBetween(1000, 4000));
					}

					try {
						const response = await this.generatePersonaResponse(persona, originalPost, contextReply);
						if (response && response !== null) {
							const reply = {
								id: this.nextPostId++,
								author: persona.name,
								authorType: 'ai',
								content: response,
								timestamp: new Date(),
								persona: persona
							};

							// If contextReply is provided, add to that reply's nested replies
							if (contextReply) {
								if (!contextReply.replies) contextReply.replies = [];
								contextReply.replies.push(reply);
							} else {
								originalPost.replies.push(reply);
							}
							
							this.renderPosts();
							this.addActivity(`${persona.name} replied to your post`);
							this.savePosts();
						} else {
							console.log(`${persona.name} failed to generate response - skipping`);
						}
					} catch (error) {
						console.error(`Error generating response for ${persona.name}:`, error);
					}
				}

				this.isProcessing = false;
				this.hideProcessingIndicator();
			}

			async generatePersonaResponse(persona, originalPost, contextReply = null, customContext = null, customSystemPrompt = null) {
				try {
					let contextText;
					
					if (customContext) {
						// Debate mode - use provided context
						contextText = customContext;
					} else if (contextReply) {
						// Build conversation thread context
						const threadContext = this.buildThreadContext(originalPost, contextReply);
						contextText = `You are ${persona.name} joining this conversation thread:

			Original post: "${originalPost.content}"

			Conversation so far:
			${threadContext}

			Respond as ${persona.name} to this conversation thread.`;
					} else {
						contextText = `You are ${persona.name} responding to this forum post: "${originalPost.content}"`;
					}

					const payload = {
						model: persona.model,
						messages: [
							{
								role: 'system',
								content: customSystemPrompt || (persona.systemPrompt + ' You are responding to a conversation thread. Pay attention to who said what to whom.')
							},
							{
								role: 'user',
								content: contextText
							}
						],
						max_tokens: 250,
						private: true
					};

					const response = await fetch(this.apiEndpoint, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						},
						body: JSON.stringify(payload)
					});

					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}

					const data = await response.json();
					console.log('API Response for', persona.name, ':', data);

					if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
						return data.choices[0].message.content.trim();
					} else {
						console.error('Unexpected API response structure:', data);
						return null;
					}
				} catch (error) {
					console.error('API Error:', error);
					return null;
				}
			}

			buildThreadContext(originalPost, contextReply) {
				let context = `Title: ${originalPost.title || 'Untitled'}\n`;
				context += `Original Post: ${originalPost.content}\n\n`;
				
				// Find the path to contextReply and build it properly
				const path = this.findReplyPath(originalPost.replies, contextReply, []);
				
				for (let i = 0; i < path.length; i++) {
					const reply = path[i];
					const authorName = reply.authorType === 'human' ? 'User' : reply.author;
					context += `${authorName}: ${reply.content}\n`;
				}
				
				return context;
			}

			// Add this helper function:
			findReplyPath(replies, targetReply, currentPath) {
				if (!replies) return null;
				
				for (let reply of replies) {
					const newPath = [...currentPath, reply];
					
					if (reply.id === targetReply.id) {
						return newPath;
					}
					
					if (reply.replies) {
						const found = this.findReplyPath(reply.replies, targetReply, newPath);
						if (found) return found;
					}
				}
				
				return null;
			}

            renderPosts() {
                const container = document.getElementById('posts-container');
                container.innerHTML = this.posts.map(post => this.renderPost(post)).join('');
                document.getElementById('total-posts').textContent = `${this.getTotalPostCount()} posts`;
            }

			renderReplies(replies, depth = 0, parentPostId) {
				if (!replies || replies.length === 0) return '';
				
				const visualDepth = Math.min(depth, 6); // Cap at 6 levels
				const indentStyle = visualDepth > 0 ? `margin-left: ${visualDepth * 15}px; border-left: 2px solid #444; padding-left: 1rem;` : '';
				
				return replies.map(reply => {
					const avatar = reply.authorType === 'ai' ? reply.persona.avatar : '👤';
					const badge = reply.authorType === 'ai' ? '<span class="ai-badge">AI</span>' : '';
					const regenerateBtn = reply.authorType === 'ai' ? 
						`<button class="control-btn" onclick="app.regenerateResponse(${parentPostId}, '${reply.author}')">Regenerate</button>` : '';
					const deleteReplyBtn = `<button class="control-btn delete-btn" onclick="app.deleteReply(${parentPostId}, ${reply.id})" title="Delete reply">🗑️</button>`;
					
					const nestedReplies = reply.replies ? this.renderReplies(reply.replies, depth + 1, parentPostId) : '';
					
					return `<div class="reply" style="${indentStyle}">
						<div class="post-header">
							<div class="post-author">
								<div class="author-avatar">${avatar}</div>
								<span class="author-name">${reply.author}</span>
								${badge}
								<span style="color: #888; font-size: 0.7rem; margin-left: 0.5rem;">ID: ${reply.id} ${reply.replyToId ? `→ #${reply.replyToId}` : ''}</span>
							</div>
							<div class="post-controls">${regenerateBtn}${deleteReplyBtn}</div>
							<span class="post-time" style="margin-left: 0.5rem;">${this.formatTime(reply.timestamp)}</span>
						</div>
						<div class="post-content">${reply.content}</div>
						<div class="post-actions" style="margin-top: 0.5rem;">
							<button class="action-btn" onclick="app.replyToAI(${parentPostId}, '${reply.author}', ${reply.id})">Reply</button>
						</div>
						${nestedReplies}
					</div>`;
				}).join('');
			}

			deleteReply(postId, replyId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post) return;
				
				// First, find the reply to check if it has children
				const findReplyAndParent = (repliesArray, parentArray = null, parentIndex = -1) => {
					for (let i = 0; i < repliesArray.length; i++) {
						const reply = repliesArray[i];
						if (reply.id === replyId) {
							return { reply, parentArray, parentIndex, currentArray: repliesArray, currentIndex: i };
						}
						if (reply.replies) {
							const found = findReplyAndParent(reply.replies, repliesArray, i);
							if (found) return found;
						}
					}
					return null;
				};
				
				const replyData = findReplyAndParent(post.replies);
				if (!replyData) {
					console.log(`Reply ${replyId} not found`);
					return;
				}
				
				const { reply, parentArray, parentIndex, currentArray, currentIndex } = replyData;
				
				// Check if reply has children and confirm deletion
				if (reply.replies && reply.replies.length > 0) {
					const childCount = reply.replies.length;
					if (!confirm(`This reply has ${childCount} nested ${childCount === 1 ? 'reply' : 'replies'}. Delete just this reply and preserve the nested ones?`)) {
						return;
					}
					
					// Move children up to parent level
					if (parentArray) {
						// Insert children where the parent was, then remove the parent
						parentArray.splice(parentIndex + 1, 0, ...reply.replies);
					} else {
						// Insert children in main replies array where this reply was
						post.replies.splice(currentIndex + 1, 0, ...reply.replies);
					}
				}
				
				// Remove the reply itself
				currentArray.splice(currentIndex, 1);
				
				this.savePosts();
				this.renderPosts();
				console.log(`Deleted reply ${replyId}`);
			}

			renderPost(post) {
				const authorClass = post.authorType === 'ai' ? 'ai-author' : 
								 post.authorType === 'system' ? 'system-author' : 'human-author';
				
				const avatar = post.authorType === 'ai' ? post.persona.avatar :
							  post.authorType === 'system' ? '⚙️' : '👤';

				const badge = post.authorType === 'ai' ? '<span class="ai-badge">AI</span>' : '';

				// Debate status indicator
				let debateStatusHTML = '';
				if (post.debateMode && post.debateConfig) {
					const config = post.debateConfig;
					const statusText = config.isPaused ? 'PAUSED' : 'ACTIVE';
					const totalReplies = post.replies ? post.replies.length : 0;
					
					debateStatusHTML = `
						<div style="background: linear-gradient(45deg, #667eea, #764ba2); padding: 1rem; margin: 1rem 0; border-radius: 8px;">
							<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
								<span style="font-weight: bold; color: white;">🎭 DEBATE MODE ${statusText}</span>
								<span style="color: white;">Cycle ${config.currentCycle}/${config.cyclesPerPause} | ${totalReplies} responses</span>
							</div>
							<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
								${config.isPaused ? 
									`<button class="submit-btn" onclick="app.resumeDebate(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">▶️ Continue (+${config.cyclesPerPause} cycles)</button>` :
									`<button class="control-btn" onclick="app.pauseDebate(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">⏸ Pause</button>`
								}
								<button class="control-btn" onclick="app.endDebate(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">⏹ End Debate</button>
								<button class="control-btn" onclick="app.showParticipationMetrics(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">📊 Stats</button>
								<button class="control-btn" onclick="app.printThread(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">🖨️ Print/PDF</button>
							</div>
						</div>
					`;
				}
				
				const deleteBtn = (post.authorType !== 'system' || post.canDelete) ? 
					'<button class="control-btn delete-btn" onclick="app.deletePost(' + post.id + ')" title="Delete post">🗑️</button>' : '';
				
				const repliesHtml = this.renderReplies(post.replies, 0, post.id);

				const replyCount = post.replies ? post.replies.length : 0;
				const isExpanded = post.expanded === true;
				const repliesHidden = post.repliesHidden === true;
				const preview = post.content.length > 100 ? post.content.substring(0, 100) + '...' : post.content;
				
				// COLLAPSED STATE (default)
				if (!isExpanded) {
					// Check if this is a brand new post that needs debate option
					const needsDebateOption = post.authorType === 'human' && !post.debateMode && post.replies.length === 0;
					
					let debatePromptHTML = '';
					if (needsDebateOption) {
						debatePromptHTML = `
							<div class="debate-option" style="background: #2a2a2a; border: 2px solid #667eea; border-radius: 8px; padding: 1rem; margin-top: 0.5rem;">
								<h4 style="color: #667eea; margin-bottom: 0.5rem; font-size: 0.9rem;">🎭 Enable Debate Mode?</h4>
								<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
									<button class="submit-btn" onclick="app.startDebateMode(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">
										Start Debate
									</button>
									<button class="control-btn" onclick="app.normalMode(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">
										Normal Replies
									</button>
								</div>
							</div>
						`;
					}
					
					return '<div class="post-summary" data-post-id="' + post.id + '">' +
						'<div class="post-title" onclick="app.expandPost(' + post.id + ')" style="position: relative;">' + 
							(post.title || 'Untitled') + 
							'<span style="position: absolute; left: 50%; transform: translateX(-50%); color: #666; font-size: 0.75rem; font-weight: normal;">▲ CLICK TO EXPAND ▲</span>' +
						'</div>' +
						'<div class="post-preview" style="color: #ccc; font-size: 0.9rem; margin: 0.5rem 0; line-height: 1.4;" onclick="app.expandPost(' + post.id + ')">' + preview + '</div>' +
						'<div class="post-meta">' +
							'<span>' + post.author + ' • ' + this.formatTime(post.timestamp) + '</span>' +
							'<span class="reply-count">' + replyCount + ' replies</span>' +
						'</div>' +
						'<div class="post-actions" style="margin-top: 0.5rem;">' +
							'<button class="action-btn">💬 ' + replyCount + '</button>' +
							'<button class="action-btn" onclick="app.toggleFavorite(' + post.id + ')">' + (post.favorited ? '❤️ Favorited' : '🤍 Favorite') + '</button>' +
							'<button class="action-btn">🔗 Share</button>' +
						'</div>' +
						debatePromptHTML +
					'</div>';
				}

				// EXPANDED STATE
				const toggleRepliesBtn = replyCount > 0 ? 
					'<button class="expand-btn" onclick="app.toggleReplies(' + post.id + ')">' + 
					(repliesHidden ? 'Show ' + replyCount + ' replies' : 'Hide replies') + '</button>' : '';

				return '<div class="post" data-post-id="' + post.id + '">' +
					'<div class="post-header" style="cursor: pointer; position: relative;">' +
						'<div class="post-author" onclick="app.collapsePost(' + post.id + ')">' +
							'<div class="author-avatar">' + avatar + '</div>' +
							'<span class="author-name ' + authorClass + '">' + post.author + '</span>' +
							badge +
						'</div>' +
						'<div style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); color: #666; font-size: 0.85rem; pointer-events: none;">▲ CLICK TO COLLAPSE</div>' +
						'<div class="post-controls" onclick="event.stopPropagation();">' + deleteBtn + '</div>' +
						'<span class="post-time" style="margin-left: 0.5rem;" onclick="app.collapsePost(' + post.id + ')">' + this.formatTime(post.timestamp) + '</span>' +
					'</div>' +
					'<div class="post-content">' + 
						(post.title ? '<strong>' + post.title + '</strong><br><br>' : '') + 
						post.content + 
					'</div>' +
					debateStatusHTML +
					'<div class="post-actions">' +
						'<button class="action-btn">💬 ' + replyCount + '</button>' +
						'<button class="action-btn" onclick="app.toggleFavorite(' + post.id + ')">' + (post.favorited ? '❤️ Favorited' : '🤍 Favorite') + '</button>' +
						'<button class="action-btn" onclick="app.replyToPost(' + post.id + ')">Reply</button>' +
						'<button class="action-btn">🔗 Share</button>' +
					'</div>' +
					'<div style="margin: 0.5rem 0;">' + toggleRepliesBtn + '</div>' +
					(replyCount > 0 && !repliesHidden ? '<div class="replies">' + this.renderReplies(post.replies, 0, post.id) + '</div>' : '') +
					'<div style="text-align: center; padding: 0.5rem 0; color: #666; font-size: 0.85rem; cursor: pointer; border-top: 1px solid #333;" onclick="app.collapsePost(' + post.id + ')">▲ CLICK TO COLLAPSE</div>' +
				'</div>';
			}

			printThread(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post) return;
				
				const printWindow = window.open('', '_blank');
				
				const formatReplies = (replies) => {
					if (!replies) return '';
					let text = '';
					replies.forEach(reply => {
						const badge = reply.authorType === 'ai' ? '<span class="ai-badge">AI</span>' : '';
						const replyTo = reply.replyToId ? ' <span class="id">→ #' + reply.replyToId + '</span>' : '';
						text += '<div class="reply"><div><span class="author">' + reply.author + '</span>' + badge + '<span class="id">#' + reply.id + '</span>' + replyTo + '</div><div class="content">' + reply.content + '</div>';
						if (reply.replies) {
							text += formatReplies(reply.replies);
						}
						text += '</div>';
					});
					return text;
				};
				
				const html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>' + post.title + '</title><style>@media print{body{margin:0;padding:20px}}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;max-width:800px;margin:0 auto;padding:20px;background:white;color:#000}h1{color:#667eea;margin-bottom:10px}.post{margin:20px 0;padding:15px;background:#f5f5f5;border-left:4px solid #667eea;border-radius:4px}.reply{margin-left:30px;margin-top:10px;padding:12px;background:#fafafa;border-left:3px solid #888;border-radius:4px}.author{font-weight:bold;color:#667eea}.ai-badge{background:#4ade80;color:#000;padding:2px 8px;border-radius:4px;font-size:.75em;margin-left:5px;font-weight:600}.content{margin-top:8px;line-height:1.6}.id{color:#888;font-size:.85em;margin-left:8px}</style></head><body><h1>' + post.title + '</h1><div class="post"><div><span class="author">' + post.author + '</span><span class="id">#' + post.id + '</span></div><div class="content">' + post.content + '</div></div>' + formatReplies(post.replies) + '<script>window.onload=function(){window.print()}<' + '/script></body></html>';
				
				printWindow.document.write(html);
				printWindow.document.close();
			}

			showProcessingIndicator(personaName = null) {
				// Only show activity message when there's a specific persona
				if (personaName) {
					const activity = document.getElementById('activity-list');
					const indicator = document.createElement('div');
					indicator.className = 'activity-item';
					indicator.id = 'processing-indicator';
					indicator.innerHTML = `
						<div class="activity-icon"></div>
						<div class="activity-text loading">
							<div class="spinner"></div>
							${personaName + ' is responding...'}
						</div>
					`;
					activity.insertBefore(indicator, activity.firstChild);
					
					this.highlightPersona(personaName);
				}
			}
			
			highlightPersona(personaName) {
				// Remove any existing highlights
				document.querySelectorAll('.persona-item').forEach(item => {
					item.style.background = '#252525';
					item.style.border = '1px solid #444';
				});
				
				// Highlight the active persona
				const personaItems = document.querySelectorAll('.persona-item');
				const persona = this.personas.find(p => p.name === personaName);
				if (persona) {
					const index = this.personas.indexOf(persona);
					if (personaItems[index]) {
						personaItems[index].style.background = 'linear-gradient(45deg, #667eea44, #764ba244)';
						personaItems[index].style.border = '2px solid #667eea';
						personaItems[index].style.transition = 'all 0.3s';
					}
				}
			}

			clearPersonaHighlight() {
				document.querySelectorAll('.persona-item').forEach(item => {
					item.style.background = '#252525';
					item.style.border = '1px solid #444';
				});
			}

			hideProcessingIndicator() {
				const indicator = document.getElementById('processing-indicator');
				if (indicator) {
					indicator.remove();
				}
				
				// Also remove any stuck "thinking" activity messages
				const activityList = document.getElementById('activity-list');
				const activities = activityList.querySelectorAll('.activity-item');
				activities.forEach(item => {
					if (item.textContent.includes('thinking') || item.textContent.includes('responding')) {
						item.remove();
					}
				});
				
				this.clearPersonaHighlight();
			}

			toggleFavorite(postId) {
				const post = this.posts.find(p => p.id === postId);
				post.favorited = !post.favorited;
				this.savePosts();
				this.renderPosts();
			}

			addActivity(text) {
				const activity = document.getElementById('activity-list');
				
				// Remove existing activity with the same text
				const existingActivities = activity.querySelectorAll('.activity-item');
				existingActivities.forEach(item => {
					if (item.querySelector('.activity-text')?.textContent === text) {
						item.remove();
					}
				});
				
				// Add new activity
				const item = document.createElement('div');
				item.className = 'activity-item';
				item.innerHTML = `
					<div class="activity-icon"></div>
					<div class="activity-text">${text}</div>
				`;
				activity.insertBefore(item, activity.firstChild);

				// Keep only last 10 activities
				const items = activity.children;
				while (items.length > 10) {
					activity.removeChild(items[items.length - 1]);
				}
			}

			replyToAI(postId, aiAuthor, replyId = null) {
				// Remove any existing reply forms first
				document.querySelectorAll('.reply-form').forEach(form => form.remove());
				
				const post = this.posts.find(p => p.id === postId);
				const repliesContainer = document.querySelector(`[data-post-id="${postId}"] .replies`);
				
				if (repliesContainer) {
					const replyForm = document.createElement('div');
					replyForm.className = 'reply-form';
					replyForm.innerHTML = `
						<div style="background: #1e1e1e; border: 1px solid #333; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
							<h4 style="color: #667eea; margin-bottom: 0.5rem;">Reply to ${aiAuthor}:</h4>
							<textarea 
								class="post-input" 
								id="reply-content-${postId}" 
								placeholder="Type your reply..."
								rows="3"
								style="width: 100%; margin-bottom: 0.5rem;"
							></textarea>
							<div style="display: flex; gap: 0.5rem;">
								<button class="submit-btn" onclick="app.submitReply(${postId}, '${aiAuthor}', ${replyId})">Post Reply</button>
								<button class="control-btn" onclick="app.cancelReply()">Cancel</button>
							</div>
						</div>
					`;
					repliesContainer.appendChild(replyForm);
					
					// Focus the textarea
					document.getElementById(`reply-content-${postId}`).focus();
				}
			}

			submitReply(postId, aiAuthor, replyId = null) {
				const replyContent = document.getElementById(`reply-content-${postId}`).value.trim();
				if (!replyContent) return;
				
				console.log('submitReply called:', postId, aiAuthor, replyId);
				
				const post = this.posts.find(p => p.id === postId);
				const userReply = {
					id: this.nextPostId++,
					author: 'You',
					authorType: 'human',
					content: replyContent,
					timestamp: new Date(),
					replies: [],
					votes: {},
					voteScore: 0,
					replyToId: replyId || post.id
				};
				
				console.log('User reply created:', userReply);
				
				// Find the specific reply by ID recursively
				const targetReply = this.findReplyById(post.replies, replyId) || post.replies.find(r => r.author === aiAuthor);
				
				console.log('Target reply found:', targetReply);
				
				if (targetReply) {
					if (!targetReply.replies) targetReply.replies = [];
					targetReply.replies.push(userReply);
					console.log('Reply added to target, target now has', targetReply.replies.length, 'replies');
				} else {
					post.replies.push(userReply);
					console.log('Reply added to top level');
				}
				
				this.savePosts();
				this.renderPosts();
				
				// If in debate mode, user reply should be considered in next cycle
				if (!post.debateMode) {
					setTimeout(() => this.generateAIResponses(post, userReply), 1000);
				}
			}

			// Add this helper function:
			findReplyById(replies, replyId) {
				if (!replies || !replyId) return null;
				
				for (let reply of replies) {
					if (reply.id === replyId) {
						return reply;
					}
					if (reply.replies) {
						const found = this.findReplyById(reply.replies, replyId);
						if (found) return found;
					}
				}
				return null;
			}

			findReplyIdByAuthor(post, authorName) {
				const reply = post.replies.find(r => r.author === authorName);
				return reply ? reply.id : null;
			}

			cancelReply() {
				document.querySelectorAll('.reply-form').forEach(form => form.remove());
			}

            getTotalPostCount() {
                return this.posts.length + this.posts.reduce((total, post) => 
                    total + (post.replies ? post.replies.length : 0), 0
                );
            }

            formatTime(date) {
                const now = new Date();
                const diff = now - date;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                
                if (minutes < 1) return 'just now';
                if (minutes < 60) return `${minutes}m ago`;
                if (hours < 24) return `${hours}h ago`;
                return date.toLocaleDateString();
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            randomBetween(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
			
			pauseDebate(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post || !post.debateMode) return;
				
				post.debateConfig.isPaused = true;
				this.savePosts();
				this.renderPosts();
				this.addActivity('Debate manually paused');
			}

			showParticipationMetrics(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post || !post.debateMode) return;
				
				let metricsHTML = '<h4 style="color: #667eea; margin-bottom: 0.5rem;">Participation Stats:</h4>';
				metricsHTML += '<div style="display: flex; flex-direction: column; gap: 0.3rem;">';
				
				const sortedParticipation = Object.entries(post.participationCount)
					.sort((a, b) => b[1] - a[1]);
				
				if (sortedParticipation.length === 0) {
					metricsHTML += '<p style="color: #ccc;">No responses yet</p>';
				} else {
					sortedParticipation.forEach(([name, count]) => {
						metricsHTML += `<div style="color: #ccc;"><strong>${name}:</strong> ${count} posts</div>`;
					});
				}
				
				metricsHTML += '</div>';
				
				alert('Debate Participation\n\n' + sortedParticipation.map(([name, count]) => `${name}: ${count} posts`).join('\n'));
			}
			
        }

		let app;
        // Initialize the app when page loads
		document.addEventListener('DOMContentLoaded', () => {
			app = new AIForumApp();
		});
    </script>
</body>
</html>