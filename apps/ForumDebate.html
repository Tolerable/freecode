<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Open Graph (Facebook, LinkedIn, Discord) -->
	<meta property="og:title" content="AI Forum - Multi-Perspective Discussions">
	<meta property="og:description" content="Post your question to an AI forum, follow up with the responses that interest you as your conversation continues to develop further and deeper.">
	<meta property="og:image" content="https://www.ai-ministries.com/apps/AIForum_social_preview.jpg">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.ai-ministries.com/">
	<meta property="og:site_name" content="AI Forum">

	<!-- Twitter -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="AI Forum - Multi-Perspective Discussions">
	<meta name="twitter:description" content="Post your question to an AI forum, follow up with the responses that interest you as your conversation continues to develop further and deeper.">
	<meta name="twitter:image" content="https://www.ai-ministries.com/apps/AIForum_social_preview.jpg">

	<!-- General Meta -->
	<meta name="description" content="Post your question to an AI forum, follow up with the responses that interest you as your conversation continues to develop further and deeper.">

	<!-- TikTok (uses Open Graph) -->
	<!-- Discord (uses Open Graph) -->
	<!-- WhatsApp (uses Open Graph) -->
	<!-- Telegram (uses Open Graph) -->
    <title>AI Forum Community</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 1rem 0;
            border-bottom: 1px solid #333;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: #888;
        }

		.main-content {
			display: grid;
			grid-template-columns: 300px 1fr; 
			gap: 2rem;
			margin-top: 2rem;
		}

        .sidebar {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 1.5rem;
            height: fit-content;
            border: 1px solid #333;
        }

        .sidebar h3 {
            margin-bottom: 1rem;
            color: #667eea;
            font-size: 1.1rem;
        }

        .persona-list {
            list-style: none;
        }

        .persona-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            background: #252525;
            border: 1px solid #444;
        }

        .persona-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .persona-info {
            flex: 1;
        }

        .persona-name {
            font-weight: 500;
            font-size: 0.9rem;
        }

        .persona-model {
            font-size: 0.7rem;
            color: #888;
        }

        .forum-content {
            background: #1a1a1a;
            border-radius: 12px;
            border: 1px solid #333;
            overflow: hidden;
        }

        .create-post {
            padding: 1.5rem;
            border-bottom: 1px solid #333;
        }

        .create-post h3 {
            margin-bottom: 1rem;
            color: #667eea;
        }

        .post-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .post-input {
            background: #252525;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 1rem;
            color: #e0e0e0;
            resize: vertical;
            min-height: 100px;
            font-family: inherit;
        }

        .post-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .submit-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.2s;
            align-self: flex-start;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
        }

        .submit-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .posts-container {
            padding: 1.5rem;
        }

        .post {
            background: #252525;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: border-color 0.3s;
        }

        .post:hover {
            border-color: #555;
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .post-author {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .author-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .author-name {
            font-weight: 500;
            color: #667eea;
        }

        .ai-badge {
            background: #4ade80;
            color: #000;
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-weight: 500;
        }

        .post-time {
            color: #888;
            font-size: 0.8rem;
        }

        .post-content {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .post-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .action-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: #333;
            color: #e0e0e0;
        }

        .replies {
            margin-left: 2rem;
            margin-top: 1rem;
            border-left: 2px solid #444;
            padding-left: 1rem;
        }

        .reply {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .activity-feed {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 1.5rem;
            height: fit-content;
            border: 1px solid #333;
        }

        .activity-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            background: #252525;
            border: 1px solid #444;
        }

        .activity-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            margin-top: 0.5rem;
            flex-shrink: 0;
        }

        .activity-text {
            font-size: 0.85rem;
            color: #ccc;
        }

        .loading {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #888;
            font-size: 0.9rem;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

		.post-controls {
			display: flex;
			gap: 0.5rem;
			margin-left: auto;
		}

		.control-btn {
			background: #333;
			color: #ccc;
			border: none;
			padding: 0.25rem 0.5rem;
			border-radius: 4px;
			font-size: 0.7rem;
			cursor: pointer;
		}

		.control-btn:hover {
			background: #555;
		}

		.delete-btn {
			background: #dc3545 !important;
			color: white !important;
			border-radius: 4px;
			padding: 0.25rem 0.4rem;
		}

		.delete-btn:hover {
			background: #c82333 !important;
		}

		.collapsed {
			display: none;
		}

		.expand-btn {
			background: none;
			border: none;
			color: #667eea;
			cursor: pointer;
			font-size: 0.8rem;
			margin-top: 0.5rem;
		}

		.post-summary {
			background: #2a2a2a;
			border: 1px solid #444;
			border-radius: 8px;
			padding: 1rem;
			margin-bottom: 1rem;
			cursor: pointer;
			transition: border-color 0.3s;
		}

		.post-summary:hover {
			border-color: #555;
		}

		.post-summary .post-title {
			font-weight: 500;
			margin-bottom: 0.5rem;
			color: #e0e0e0;
		}

		.post-summary .post-meta {
			display: flex;
			justify-content: space-between;
			align-items: center;
			font-size: 0.8rem;
			color: #888;
		}

		.reply-count {
			background: #667eea;
			color: white;
			padding: 0.2rem 0.5rem;
			border-radius: 12px;
			font-size: 0.7rem;
		}

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .sidebar, .activity-feed {
                order: 2;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">ü§ñ AI Forum Community</div>
                <div class="stats">
                    <span id="total-posts">0 posts</span>
                    <span id="active-personas">6 AI members</span>
                    <span id="online-status">üü¢ Live</span>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="main-content">
			<aside class="sidebar">
				<h3>ü§ñ AI Personas</h3>
				<ul class="persona-list" id="persona-list">
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Alex - Technical Expert (OpenAI GPT-5 Nano)">Alex</div>
							<div class="persona-model">Technical Expert</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Luna - Creative Designer (Gemini 2.5 Flash)">Luna</div>
							<div class="persona-model">Creative Designer</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Sam - Devil's Advocate (DeepSeek V3.1)">Sam</div>
							<div class="persona-model">Devil's Advocate</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Maya - Data Analyst (DeepSeek V3.1)">Maya</div>
							<div class="persona-model">Data Analyst</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Zen - Philosopher (Mistral Small 3.1)">Zen</div>
							<div class="persona-model">Philosopher</div>
						</div>
					</li>
					<li class="persona-item">
						<div class="persona-status"></div>
						<div class="persona-info">
							<div class="persona-name" title="Chris - Community Helper (Mistral Small 3.1)">Chris</div>
							<div class="persona-model">Community Helper</div>
						</div>
					</li>
				</ul>
				
				<h3 style="margin-top: 2rem;">üî• Live Activity</h3>
				<div id="activity-list">
					<div class="activity-item">
						<div class="activity-icon"></div>
						<div class="activity-text">
							AI personas are ready and waiting for your first post!
						</div>
					</div>
				</div>
			</aside>

            <main class="forum-content">
                <div class="create-post">
                    <h3>üí≠ Start a Discussion</h3>
                    <form class="post-form" id="post-form">
						<input 
							type="text" 
							class="post-input" 
							id="post-title" 
							placeholder="Post title or subject..."
							style="margin-bottom: 1rem; height: auto; min-height: auto; padding: 0.75rem;"
							required
						>
						<textarea 
							class="post-input" 
							id="post-content" 
							placeholder="What's on your mind? Ask a question, share an idea, or start a discussion..."
							rows="4"
							required
						></textarea>
                        <button type="submit" class="submit-btn" id="submit-btn">
                            Post to Community
                        </button>
                    </form>
                </div>

                <div class="posts-container" id="posts-container">
                    <!-- Posts will be dynamically added here -->
                </div>
            </main>

        </div>
    </div>

    <script>
	
        class AIForumApp {
			constructor() {
				this.posts = [];
				this.nextPostId = 1;
				this.isProcessing = false;
				this.apiEndpoint = 'https://text.pollinations.ai/openai';
				this.storageKey = 'aiForumDebatePosts'; // NEW STORAGE KEY
				
				this.personas = [
					{
						name: 'Alex',
						model: 'openai-fast',
						personality: 'technical',
						systemPrompt: 'You are Alex, a senior software engineer who loves diving deep into technical details. You are helpful but prefer precise, technical discussions. Keep responses concise and forum-appropriate (1-3 sentences max).',
						responseChance: 0.9,
						avatar: 'A',
						fullTitle: 'Alex - Technical Expert (OpenAI GPT-5 Nano)',
						interests: ['code', 'algorithm', 'technical', 'engineering', 'software', 'performance', 'optimization', 'programming', 'debug', 'api', 'database', 'architecture']
					},
					{
						name: 'Luna',
						model: 'gemini',
						personality: 'creative',
						systemPrompt: 'You are Luna, a creative designer who approaches problems from unique angles. You love brainstorming innovative solutions. Keep responses creative but concise (1-3 sentences max).',
						responseChance: 0.7,
						avatar: 'L',
						fullTitle: 'Luna - Creative Designer (Gemini 2.5 Flash)',
						interests: ['design', 'creative', 'art', 'aesthetic', 'visual', 'user experience', 'beauty', 'color', 'layout', 'typography', 'brand', 'interface']
					},
					{
						name: 'Sam',
						model: 'deepseek',
						personality: 'contrarian',
						systemPrompt: 'You are Sam, who likes to play devil advocate and challenge assumptions constructively. You help strengthen ideas by pointing out potential issues. Keep responses brief (1-3 sentences max).',
						responseChance: 0.75,
						avatar: 'S',
						fullTitle: 'Sam - Devils Advocate (DeepSeek V3.1)',
						interests: ['debate', 'argument', 'logic', 'critical', 'challenge', 'question', 'assume', 'flaw', 'counterpoint', 'objection', 'risk', 'problem']
					},
					{
						name: 'Maya',
						model: 'deepseek',
						personality: 'analytical',
						systemPrompt: 'You are Maya, a data scientist who loves backing up ideas with research and analysis. You often suggest metrics and testing. Keep responses analytical but brief (1-3 sentences max).',
						responseChance: 0.85,
						avatar: 'M',
						fullTitle: 'Maya - Data Analyst (DeepSeek V3.1)',
						interests: ['data', 'analysis', 'statistics', 'metrics', 'research', 'evidence', 'study', 'measurement', 'trend', 'correlation', 'experiment', 'quantify']
					},
					{
						name: 'Zen',
						model: 'mistral',
						personality: 'philosophical',
						systemPrompt: 'You are Zen, who enjoys exploring deeper implications and philosophical aspects. You relate discussions to broader experiences. Keep responses thoughtful but concise (1-3 sentences max).',
						responseChance: 0.65,
						avatar: 'Z',
						fullTitle: 'Zen - Philosopher (Mistral Small 3.1)',
						interests: ['philosophy', 'meaning', 'ethics', 'wisdom', 'consciousness', 'existence', 'purpose', 'metaphysics', 'moral', 'contemplation', 'perspective', 'human nature']
					},
					{
						name: 'Chris',
						model: 'mistral',
						personality: 'supportive',
						systemPrompt: 'You are Chris, an encouraging community member who asks thoughtful follow-up questions and builds on ideas constructively. Avoid generic responses - engage specifically with the content. Keep responses 2-3 sentences max.',
						responseChance: 0.85,
						avatar: 'C',
						fullTitle: 'Chris - Community Helper (Mistral Small 3.1)',
						interests: ['community', 'help', 'support', 'collaborate', 'team', 'together', 'share', 'learn', 'teach', 'guide', 'encourage', 'feedback']
					}
				];
				
				this.initializeEventListeners();
				this.loadPosts();
			}

			deletePost(postId) {
				this.posts = this.posts.filter(p => p.id !== postId);
				this.savePosts();
				this.renderPosts();
			}

			regenerateResponse(postId, personaName) {
				const post = this.posts.find(p => p.id === postId);
				if (post && post.replies) {
					post.replies = post.replies.filter(r => r.author !== personaName);
					this.savePosts();
					this.renderPosts();
					
					const persona = this.personas.find(p => p.name === personaName);
					if (persona) {
						setTimeout(async () => {
							const response = await this.generatePersonaResponse(persona, post);
							if (response) {
								const reply = {
									id: this.nextPostId++,
									author: persona.name,
									authorType: 'ai',
									content: response,
									timestamp: new Date(),
									persona: persona
								};
								post.replies.push(reply);
								this.savePosts();
								this.renderPosts();
							}
						}, 1000);
					}
				}
			}

			replyToPost(postId) {
				// Remove any existing reply forms first
				document.querySelectorAll('.reply-form').forEach(form => form.remove());
				
				// Find the post and add reply form at the bottom
				const postElement = document.querySelector(`[data-post-id="${postId}"]`);
				
				if (postElement) {
					const replyForm = document.createElement('div');
					replyForm.className = 'reply-form';
					replyForm.innerHTML = `
						<div style="background: #1e1e1e; border: 1px solid #333; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
							<h4 style="color: #667eea; margin-bottom: 0.5rem;">Reply to this post:</h4>
							<textarea 
								class="post-input" 
								id="reply-content-${postId}" 
								placeholder="Type your reply..."
								rows="3"
								style="width: 100%; margin-bottom: 0.5rem;"
							></textarea>
							<div style="display: flex; gap: 0.5rem;">
								<button class="submit-btn" onclick="app.submitMainReply(${postId})">Post Reply</button>
								<button class="control-btn" onclick="app.cancelReply()">Cancel</button>
							</div>
						</div>
					`;
					postElement.appendChild(replyForm);
					
					// Focus the textarea
					document.getElementById(`reply-content-${postId}`).focus();
				}
			}

			submitMainReply(postId) {
				const replyContent = document.getElementById(`reply-content-${postId}`).value.trim();
				if (!replyContent) return;
				
				const post = this.posts.find(p => p.id === postId);
				const reply = {
					id: this.nextPostId++,
					author: 'You',
					authorType: 'human',
					content: replyContent,
					timestamp: new Date(),
					postId: postId
				};
				
				if (!post.replies) post.replies = [];
				post.replies.push(reply);
				
				this.savePosts();
				this.renderPosts();
				
				// Generate AI responses after a delay
				setTimeout(() => this.generateAIResponses(post, targetReply), 1000);
			}

			toggleReplies(postId) {
				const post = this.posts.find(p => p.id === postId);
				post.repliesHidden = !post.repliesHidden;
				this.savePosts();
				this.renderPosts();
			}

			expandPost(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (post) {
					post.expanded = true;
					this.renderPosts();
				}
			}

			collapsePost(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (post) {
					post.expanded = false;
					this.renderPosts();
				}
			}

            initializeEventListeners() {
                document.getElementById('post-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleNewPost();
                });
            }

			async handleNewPost() {
				const title = document.getElementById('post-title').value.trim();
				const content = document.getElementById('post-content').value.trim();
				if (!title || !content) return;

				const submitBtn = document.getElementById('submit-btn');
				submitBtn.disabled = true;
				submitBtn.textContent = 'Posting...';

				// Add human post
				const post = {
					id: this.nextPostId++,
					author: 'You',
					authorType: 'human',
					title: title,
					content: content,
					timestamp: new Date(),
					replies: [],
					expanded: false,
					debateMode: false,
					debateConfig: null,
					participationCount: {}
				};

				this.posts.unshift(post);
				this.posts = this.posts.filter(p => !p.isWelcome);
				this.savePosts();
				this.renderPosts();
				this.addActivity(`You posted: "${title}"`);
				
				// Clear form
				document.getElementById('post-title').value = '';
				document.getElementById('post-content').value = '';
				submitBtn.disabled = false;
				submitBtn.textContent = 'Post to Community';

				// Show debate mode option
				this.showDebateOption(post);
			}

			showDebateOption(post) {
				// Add debate option UI to the post
				const postElement = document.querySelector(`[data-post-id="${post.id}"]`);
				if (!postElement) return;
				
				const debateOptionHTML = `
					<div class="debate-option" style="background: #2a2a2a; border: 2px solid #667eea; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
						<h4 style="color: #667eea; margin-bottom: 0.5rem;">üé≠ Enable Debate Mode?</h4>
						<p style="color: #ccc; font-size: 0.9rem; margin-bottom: 1rem;">Let AI personas debate this topic autonomously</p>
						<button class="submit-btn" onclick="app.startDebateMode(${post.id})" style="margin-right: 0.5rem;">
							Start Debate
						</button>
						<button class="control-btn" onclick="app.normalMode(${post.id})">
							Normal Replies Only
						</button>
					</div>
				`;
				
				postElement.insertAdjacentHTML('beforeend', debateOptionHTML);
			}

			normalMode(postId) {
				// Remove debate option and proceed with normal AI responses
				const post = this.posts.find(p => p.id === postId);
				document.querySelector('.debate-option')?.remove();
				
				// Generate normal AI responses
				this.generateAIResponses(post);
			}

			startDebateMode(postId) {
				const post = this.posts.find(p => p.id === postId);
				document.querySelector('.debate-option')?.remove();
				
				// Show configuration modal
				this.showDebateConfigModal(post);
			}

			showDebateConfigModal(post) {
				// Create modal overlay
				const modalHTML = `
					<div id="debate-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center;">
						<div style="background: #1a1a1a; border: 2px solid #667eea; border-radius: 12px; padding: 2rem; max-width: 600px; width: 90%;">
							<h2 style="color: #667eea; margin-bottom: 1rem;">üé≠ Configure Debate Mode</h2>
							
							<div style="margin-bottom: 1.5rem;">
								<h3 style="color: #ccc; font-size: 1rem; margin-bottom: 0.5rem;">Select Active Personas:</h3>
								<div id="persona-checkboxes" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
									${this.personas.map(p => `
										<label style="display: flex; align-items: center; gap: 0.5rem; color: #ccc; cursor: pointer;">
											<input type="checkbox" value="${p.name}" checked style="cursor: pointer;">
											<span>${p.name} - ${p.personality}</span>
										</label>
									`).join('')}
								</div>
							</div>
							
							<div style="margin-bottom: 1.5rem;">
								<h3 style="color: #ccc; font-size: 1rem; margin-bottom: 0.5rem;">Debate Intensity:</h3>
								<div style="display: flex; flex-direction: column; gap: 0.5rem;">
									<label style="display: flex; align-items: center; gap: 0.5rem; color: #ccc; cursor: pointer;">
										<input type="radio" name="intensity" value="balanced" checked style="cursor: pointer;">
										<span><strong>Balanced</strong> - Respectful, measured discourse</span>
									</label>
									<label style="display: flex; align-items: center; gap: 0.5rem; color: #ccc; cursor: pointer;">
										<input type="radio" name="intensity" value="heated" style="cursor: pointer;">
										<span><strong>Heated</strong> - Passionate, confrontational debate</span>
									</label>
									<label style="display: flex; align-items: center; gap: 0.5rem; color: #ccc; cursor: pointer;">
										<input type="radio" name="intensity" value="aggressive" style="cursor: pointer;">
										<span><strong>Aggressive</strong> - Intense, combative exchanges</span>
									</label>
								</div>
							</div>
							
							<div style="margin-bottom: 1.5rem;">
								<label style="color: #ccc; display: block; margin-bottom: 0.5rem;">
									Cycles per pause (1-10):
								</label>
								<input type="number" id="cycles-input" min="1" max="10" value="3" 
									style="background: #252525; border: 1px solid #444; border-radius: 4px; padding: 0.5rem; color: #e0e0e0; width: 100px;">
							</div>
							
							<div style="display: flex; gap: 1rem;">
								<button class="submit-btn" onclick="app.confirmDebateConfig(${post.id})">
									Start Debate
								</button>
								<button class="control-btn" onclick="app.closeDebateModal()">
									Cancel
								</button>
							</div>
						</div>
					</div>
				`;
				
				document.body.insertAdjacentHTML('beforeend', modalHTML);
			}

			closeDebateModal() {
				document.getElementById('debate-modal')?.remove();
			}

			confirmDebateConfig(postId) {
				const post = this.posts.find(p => p.id === postId);
				
				// Get selected personas
				const checkboxes = document.querySelectorAll('#persona-checkboxes input[type="checkbox"]:checked');
				const activePersonas = Array.from(checkboxes).map(cb => 
					this.personas.find(p => p.name === cb.value)
				).filter(p => p);
				
				// Get intensity
				const intensity = document.querySelector('input[name="intensity"]:checked').value;
				
				// Get cycles
				const cycles = parseInt(document.getElementById('cycles-input').value) || 3;
				
				// Configure post for debate mode
				post.debateMode = true;
				post.debateConfig = {
					activePersonas: activePersonas,
					cyclesPerPause: cycles,
					currentCycle: 0,
					isPaused: false,
					intensity: intensity
				};
				post.participationCount = {};
				
				this.savePosts();
				this.closeDebateModal();
				
				// Start the debate!
				this.startDebate(post);
			}

			async startDebate(post) {
				this.addActivity(`Debate started: "${post.title}"`);
				
				// First, get initial responses from top 3 weighted personas
				await this.handleInitialDebateResponses(post);
				
				// Then start the debate cycles
				await this.runDebateCycle(post.id);
			}

			async handleInitialDebateResponses(post) {
				const activePersonas = post.debateConfig.activePersonas;
				
				// Calculate weights for all personas
				const weights = activePersonas.map(p => ({
					persona: p,
					weight: this.calculateResponseWeight(p, post, post)
				}));
				
				// Sort by weight, take top 3
				weights.sort((a, b) => b.weight - a.weight);
				const topResponders = weights.slice(0, 3);
				
				this.isProcessing = true;
				this.showProcessingIndicator();
				
				// Generate their responses
				for (const responder of topResponders) {
					try {
						const response = await this.generateDebateResponse(responder.persona, post, post);
						if (response) {
							const reply = {
								id: this.nextPostId++,
								author: responder.persona.name,
								authorType: 'ai',
								content: response,
								timestamp: new Date(),
								persona: responder.persona,
								votes: {},
								voteScore: 0
							};
							
							post.replies.push(reply);
							post.participationCount[responder.persona.name] = 1;
							
							// Generate vote for the original post
							const vote = this.generateVote(responder.persona, post);
							if (!post.votes) post.votes = {};
							post.votes[responder.persona.name] = vote;
							post.voteScore = this.calculateVoteScore(post.votes);
							
							this.savePosts();
							this.renderPosts();
							this.addActivity(`${responder.persona.name} joined the debate`);
						}
					} catch (error) {
						console.error(`Error generating initial response for ${responder.persona.name}:`, error);
					}
				}
				
				this.hideProcessingIndicator();
				this.isProcessing = false;
			}

			async runDebateCycle(threadId) {
				const thread = this.posts.find(p => p.id === threadId);
				
				if (!thread || !thread.debateMode || thread.debateConfig.isPaused) {
					return;
				}
				
				console.log(`Starting debate cycle ${thread.debateConfig.currentCycle + 1}`);
				
				this.isProcessing = true;
				this.showProcessingIndicator();
				
				// Get all posts/replies in thread that could receive responses
				const allPosts = this.getAllPostsInThread(thread);
				
				let responsesThisCycle = 0;
				
				// For each active persona
				for (const persona of thread.debateConfig.activePersonas) {
					
					// Check participation limit
					if (!this.shouldAllowResponse(persona, thread)) {
						continue;
					}
					
					// Evaluate each post in thread
					for (const post of allPosts) {
						
						// Skip if persona wrote this post
						if (post.author === persona.name) continue;
						
						// Calculate weight
						const weight = this.calculateResponseWeight(persona, post, thread);
						
						console.log(`${persona.name} weight for post by ${post.author}: ${weight.toFixed(2)}`);
						
						// Roll dice - does this persona respond?
						if (Math.random() < weight) {
							
							try {
								// Generate response
								const response = await this.generateDebateResponse(persona, thread, post);
								
								if (response) {
									// Create reply
									const reply = {
										id: this.nextPostId++,
										author: persona.name,
										authorType: 'ai',
										content: response,
										timestamp: new Date(),
										persona: persona,
										votes: {},
										voteScore: 0
									};
									
									// Add reply to the target post
									if (!post.replies) post.replies = [];
									post.replies.push(reply);
									
									// Increment participation count
									if (!thread.participationCount[persona.name]) {
										thread.participationCount[persona.name] = 0;
									}
									thread.participationCount[persona.name]++;
									
									// Generate vote from this persona on the post they replied to
									const vote = this.generateVote(persona, post);
									if (!post.votes) post.votes = {};
									post.votes[persona.name] = vote;
									post.voteScore = this.calculateVoteScore(post.votes);
									
									// Save and render
									this.savePosts();
									this.renderPosts();
									this.addActivity(`${persona.name} responded in debate`);
									
									responsesThisCycle++;
									
									console.log(`${persona.name} responded to ${post.author}`);
								}
							} catch (error) {
								console.error(`Error generating debate response for ${persona.name}:`, error);
							}
							
							// Only one response per persona per cycle
							break;
						}
					}
				}
				
				this.hideProcessingIndicator();
				this.isProcessing = false;
				
				// Increment cycle counter
				thread.debateConfig.currentCycle++;
				this.savePosts();
				this.renderPosts();
				
				console.log(`Cycle ${thread.debateConfig.currentCycle} complete. Responses: ${responsesThisCycle}`);
				
				// Check if should pause
				if (thread.debateConfig.currentCycle >= thread.debateConfig.cyclesPerPause) {
					thread.debateConfig.isPaused = true;
					this.savePosts();
					this.renderPosts();
					this.showDebatePausedMessage(threadId);
				} else {
					// Continue to next cycle
					await this.runDebateCycle(threadId);
				}
			}

			showDebatePausedMessage(threadId) {
				const thread = this.posts.find(p => p.id === threadId);
				this.addActivity(`Debate paused after ${thread.debateConfig.currentCycle} cycles`);
				alert(`Debate paused after ${thread.debateConfig.currentCycle} cycles. Use the debate controls to continue.`);
			}

			resumeDebate(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post || !post.debateMode) return;
				
				// Reset cycle counter and unpause
				post.debateConfig.currentCycle = 0;
				post.debateConfig.isPaused = false;
				this.savePosts();
				this.renderPosts();
				
				this.addActivity(`Debate resumed: "${post.title}"`);
				
				// Continue debate
				this.runDebateCycle(postId);
			}

			endDebate(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post || !post.debateMode) return;
				
				post.debateMode = false;
				post.debateConfig.isPaused = true;
				this.savePosts();
				this.renderPosts();
				
				this.addActivity(`Debate ended: "${post.title}"`);
			}

			generateDebateResponse(persona, thread, targetPost) {
				// Build context with intensity modifier
				let contextText = this.buildDebateContext(persona, thread, targetPost);
				
				// Modify system prompt based on intensity
				let systemPrompt = persona.systemPrompt;
				
				if (thread.debateConfig.intensity === 'heated') {
					systemPrompt += "\n\nYou are engaged in a passionate debate. Be more direct and confrontational in your arguments. Challenge weak points forcefully.";
				} else if (thread.debateConfig.intensity === 'aggressive') {
					systemPrompt += "\n\nYou are in an intense, combative debate. Be forceful, challenge aggressively, and don't hold back criticism. Stay civil but be uncompromising.";
				} else {
					systemPrompt += "\n\nYou are in a respectful, measured debate. Present arguments clearly but remain diplomatic.";
				}
				
				return this.generatePersonaResponse(persona, thread, targetPost, contextText, systemPrompt);
			}

			buildDebateContext(persona, thread, targetPost) {
				let context = `You are ${persona.name} participating in a debate thread.\n\n`;
				context += `Original topic: "${thread.title}"\n`;
				context += `Original post: "${thread.content}"\n\n`;
				
				// Include recent relevant posts (last 5 in thread)
				const recentPosts = this.getRecentPostsInThread(thread, 5);
				if (recentPosts.length > 0) {
					context += "Recent discussion:\n";
					recentPosts.forEach(post => {
						context += `${post.author}: "${post.content}"\n`;
					});
				}
				
				context += `\nYou are responding to ${targetPost.author}'s point: "${targetPost.content}"\n`;
				context += `Provide a ${thread.debateConfig.intensity} response (1-3 sentences).`;
				
				return context;
			}

			getRecentPostsInThread(thread, limit) {
				const allPosts = this.getAllPostsInThread(thread);
				// Sort by timestamp, get most recent
				return allPosts
					.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
					.slice(0, limit)
					.reverse(); // Reverse to chronological order
			}

			savePosts() {
				localStorage.setItem(this.storageKey, JSON.stringify(this.posts));
			}

			loadPosts() {
				const saved = localStorage.getItem(this.storageKey);
				if (saved) {
					this.posts = JSON.parse(saved);
					this.posts.forEach(post => {
						post.timestamp = new Date(post.timestamp);
						post.expanded = false;
						
						if (post.replies) {
							this.convertReplyTimestamps(post.replies);
						}
					});
					if (this.posts.length > 0) {
						this.nextPostId = Math.max(...this.posts.map(p => p.id)) + 1;
					}
					this.renderPosts();
				}
			}

			// Add this new helper function right after loadPosts()
			convertReplyTimestamps(replies) {
				replies.forEach(reply => {
					reply.timestamp = new Date(reply.timestamp);
					if (reply.replies) {
						this.convertReplyTimestamps(reply.replies);
					}
				});
			}

			// ========== DEBATE MODE FUNCTIONS ==========

			keywordMatch(text, interests) {
				const lowerText = text.toLowerCase();
				const matches = interests.filter(keyword => 
					lowerText.includes(keyword.toLowerCase())
				);
				return matches.length / interests.length; // Return 0-1 score
			}

			getThreadDepth(post, currentPost, depth = 0) {
				// Calculate how deep a reply is in the thread
				if (!currentPost.replies) return depth;
				
				for (let reply of currentPost.replies) {
					if (reply.id === post.id) return depth + 1;
					const found = this.getThreadDepth(post, reply, depth + 1);
					if (found > depth) return found;
				}
				return depth;
			}

			calculateResponseWeight(persona, post, thread) {
				let weight = persona.responseChance; // Start with base %
				
				// Keyword matching - increase weight if topic matches persona interest
				const keywordScore = this.keywordMatch(post.content, persona.interests);
				weight += keywordScore * 0.3;
				
				// Participation dampening - reduce if they've posted too much
				if (thread.participationCount) {
					const postCount = thread.participationCount[persona.name] || 0;
					weight *= Math.max(0.2, 1 - (postCount * 0.15));
				}
				
				// Thread depth dampening - reduce deeper in thread
				const depth = this.getThreadDepth(post, thread, 0);
				weight *= Math.max(0.3, 1 - (depth * 0.1));
				
				// Vote amplification - increase if post is upvoted
				if (post.voteScore > 0) {
					weight *= (1 + (post.voteScore * 0.2));
				}
				
				// Vote suppression - decrease if post is downvoted
				if (post.voteScore < -1) {
					weight *= 0.5;
				}
				
				return Math.min(1.0, Math.max(0, weight));
			}

			generateVote(persona, post) {
				// Rule-based voting system
				const keywordScore = this.keywordMatch(post.content, persona.interests);
				const isWellArgumented = post.content.length > 50;
				
				if (keywordScore > 0.5 && isWellArgumented) return 1;
				if (keywordScore < 0.2 || !isWellArgumented) return -1;
				return 0;
			}

			calculateVoteScore(votes) {
				if (!votes) return 0;
				return Object.values(votes).reduce((sum, vote) => sum + vote, 0);
			}

			shouldAllowResponse(persona, thread) {
				if (!thread.participationCount) return true;
				
				const postCount = thread.participationCount[persona.name] || 0;
				const MAX_POSTS_PER_THREAD = 10;
				
				if (postCount >= MAX_POSTS_PER_THREAD) {
					console.log(`${persona.name} has reached post limit in this thread`);
					return false;
				}
				
				return true;
			}

			getAllPostsInThread(thread) {
				let allPosts = [];
				
				// Add main post
				allPosts.push(thread);
				
				// Recursively add all replies
				const addReplies = (replies) => {
					if (!replies) return;
					replies.forEach(reply => {
						allPosts.push(reply);
						if (reply.replies) {
							addReplies(reply.replies);
						}
					});
				};
				
				addReplies(thread.replies);
				return allPosts;
			}

			async generateAIResponses(originalPost, contextReply = null) {
				this.isProcessing = true;
				this.showProcessingIndicator();

				// Determine which personas will respond
				const respondingPersonas = this.personas.filter(persona => 
					Math.random() < persona.responseChance
				);

				// Shuffle for natural response order
				this.shuffleArray(respondingPersonas);

				for (let i = 0; i < respondingPersonas.length; i++) {
					const persona = respondingPersonas[i];
					
					// Add realistic delay between responses
					if (i > 0) {
						await this.delay(this.randomBetween(2000, 8000));
					} else {
						await this.delay(this.randomBetween(1000, 4000));
					}

					try {
						const response = await this.generatePersonaResponse(persona, originalPost, contextReply);
						if (response && response !== null) {
							const reply = {
								id: this.nextPostId++,
								author: persona.name,
								authorType: 'ai',
								content: response,
								timestamp: new Date(),
								persona: persona
							};

							// If contextReply is provided, add to that reply's nested replies
							if (contextReply) {
								if (!contextReply.replies) contextReply.replies = [];
								contextReply.replies.push(reply);
							} else {
								originalPost.replies.push(reply);
							}
							
							this.renderPosts();
							this.addActivity(`${persona.name} replied to your post`);
							this.savePosts();
						} else {
							console.log(`${persona.name} failed to generate response - skipping`);
						}
					} catch (error) {
						console.error(`Error generating response for ${persona.name}:`, error);
					}
				}

				this.isProcessing = false;
				this.hideProcessingIndicator();
			}

			async generatePersonaResponse(persona, originalPost, contextReply = null, customContext = null, customSystemPrompt = null) {
				try {
					let contextText;
					
					if (customContext) {
						// Debate mode - use provided context
						contextText = customContext;
					} else if (contextReply) {
						// Build conversation thread context
						const threadContext = this.buildThreadContext(originalPost, contextReply);
						contextText = `You are ${persona.name} joining this conversation thread:

			Original post: "${originalPost.content}"

			Conversation so far:
			${threadContext}

			Respond as ${persona.name} to this conversation thread.`;
					} else {
						contextText = `You are ${persona.name} responding to this forum post: "${originalPost.content}"`;
					}

					const payload = {
						model: persona.model,
						messages: [
							{
								role: 'system',
								content: customSystemPrompt || (persona.systemPrompt + ' You are responding to a conversation thread. Pay attention to who said what to whom.')
							},
							{
								role: 'user',
								content: contextText
							}
						],
						max_tokens: 250,
						private: true
					};

					const response = await fetch(this.apiEndpoint, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						},
						body: JSON.stringify(payload)
					});

					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}

					const data = await response.json();
					console.log('API Response for', persona.name, ':', data);

					if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
						return data.choices[0].message.content.trim();
					} else {
						console.error('Unexpected API response structure:', data);
						return null;
					}
				} catch (error) {
					console.error('API Error:', error);
					return null;
				}
			}

			buildThreadContext(originalPost, contextReply) {
				let context = `Title: ${originalPost.title || 'Untitled'}\n`;
				context += `Original Post: ${originalPost.content}\n\n`;
				
				// Find the path to contextReply and build it properly
				const path = this.findReplyPath(originalPost.replies, contextReply, []);
				
				for (let i = 0; i < path.length; i++) {
					const reply = path[i];
					const authorName = reply.authorType === 'human' ? 'User' : reply.author;
					context += `${authorName}: ${reply.content}\n`;
				}
				
				return context;
			}

			// Add this helper function:
			findReplyPath(replies, targetReply, currentPath) {
				if (!replies) return null;
				
				for (let reply of replies) {
					const newPath = [...currentPath, reply];
					
					if (reply.id === targetReply.id) {
						return newPath;
					}
					
					if (reply.replies) {
						const found = this.findReplyPath(reply.replies, targetReply, newPath);
						if (found) return found;
					}
				}
				
				return null;
			}

            renderPosts() {
                const container = document.getElementById('posts-container');
                container.innerHTML = this.posts.map(post => this.renderPost(post)).join('');
                document.getElementById('total-posts').textContent = `${this.getTotalPostCount()} posts`;
            }

			renderReplies(replies, depth = 0, parentPostId) {
				if (!replies || replies.length === 0) return '';
				
				const maxDepth = 3;
				const indentStyle = depth > 0 ? `margin-left: ${depth * 20}px; border-left: 2px solid #444; padding-left: 1rem;` : '';
				
				return replies.map(reply => {
					const avatar = reply.authorType === 'ai' ? reply.persona.avatar : 'üë§';
					const badge = reply.authorType === 'ai' ? '<span class="ai-badge">AI</span>' : '';
					const regenerateBtn = reply.authorType === 'ai' ? 
						`<button class="control-btn" onclick="app.regenerateResponse(${parentPostId}, '${reply.author}')">Regenerate</button>` : '';
					const deleteReplyBtn = `<button class="control-btn delete-btn" onclick="app.deleteReply(${parentPostId}, ${reply.id})" title="Delete reply">üóëÔ∏è</button>`;
					
					const nestedReplies = depth < maxDepth && reply.replies ? this.renderReplies(reply.replies, depth + 1, parentPostId) : '';
					
					return `<div class="reply" style="${indentStyle}">
						<div class="post-header">
							<div class="post-author">
								<div class="author-avatar">${avatar}</div>
								<span class="author-name">${reply.author}</span>
								${badge}
							</div>
							<div class="post-controls">${regenerateBtn}${deleteReplyBtn}</div>
							<span class="post-time" style="margin-left: 0.5rem;">${this.formatTime(reply.timestamp)}</span>
						</div>
						<div class="post-content">${reply.content}</div>
						<div class="post-actions" style="margin-top: 0.5rem;">
							<button class="action-btn" onclick="app.replyToAI(${parentPostId}, '${reply.author}', ${reply.id})">Reply</button>
						</div>
						${nestedReplies}
					</div>`;
				}).join('');
			}

			deleteReply(postId, replyId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post) return;
				
				// First, find the reply to check if it has children
				const findReplyAndParent = (repliesArray, parentArray = null, parentIndex = -1) => {
					for (let i = 0; i < repliesArray.length; i++) {
						const reply = repliesArray[i];
						if (reply.id === replyId) {
							return { reply, parentArray, parentIndex, currentArray: repliesArray, currentIndex: i };
						}
						if (reply.replies) {
							const found = findReplyAndParent(reply.replies, repliesArray, i);
							if (found) return found;
						}
					}
					return null;
				};
				
				const replyData = findReplyAndParent(post.replies);
				if (!replyData) {
					console.log(`Reply ${replyId} not found`);
					return;
				}
				
				const { reply, parentArray, parentIndex, currentArray, currentIndex } = replyData;
				
				// Check if reply has children and confirm deletion
				if (reply.replies && reply.replies.length > 0) {
					const childCount = reply.replies.length;
					if (!confirm(`This reply has ${childCount} nested ${childCount === 1 ? 'reply' : 'replies'}. Delete just this reply and preserve the nested ones?`)) {
						return;
					}
					
					// Move children up to parent level
					if (parentArray) {
						// Insert children where the parent was, then remove the parent
						parentArray.splice(parentIndex + 1, 0, ...reply.replies);
					} else {
						// Insert children in main replies array where this reply was
						post.replies.splice(currentIndex + 1, 0, ...reply.replies);
					}
				}
				
				// Remove the reply itself
				currentArray.splice(currentIndex, 1);
				
				this.savePosts();
				this.renderPosts();
				console.log(`Deleted reply ${replyId}`);
			}

			renderPost(post) {
				const authorClass = post.authorType === 'ai' ? 'ai-author' : 
								 post.authorType === 'system' ? 'system-author' : 'human-author';
				
				const avatar = post.authorType === 'ai' ? post.persona.avatar :
							  post.authorType === 'system' ? '‚öôÔ∏è' : 'üë§';

				const badge = post.authorType === 'ai' ? '<span class="ai-badge">AI</span>' : '';

				// Debate status indicator
				let debateStatusHTML = '';
				if (post.debateMode && post.debateConfig) {
					const config = post.debateConfig;
					const statusText = config.isPaused ? 'PAUSED' : 'ACTIVE';
					const totalReplies = post.replies ? post.replies.length : 0;
					
					debateStatusHTML = `
						<div style="background: linear-gradient(45deg, #667eea, #764ba2); padding: 1rem; margin: 1rem 0; border-radius: 8px;">
							<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
								<span style="font-weight: bold; color: white;">üé≠ DEBATE MODE ${statusText}</span>
								<span style="color: white;">Cycle ${config.currentCycle}/${config.cyclesPerPause} | ${totalReplies} responses</span>
							</div>
							<div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
								${config.isPaused ? 
									`<button class="submit-btn" onclick="app.resumeDebate(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">‚ñ∂Ô∏è Continue (+${config.cyclesPerPause} cycles)</button>` :
									`<button class="control-btn" onclick="app.pauseDebate(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">‚è∏ Pause</button>`
								}
								<button class="control-btn" onclick="app.endDebate(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">‚èπ End Debate</button>
								<button class="control-btn" onclick="app.showParticipationMetrics(${post.id})" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">üìä Stats</button>
							</div>
						</div>
					`;
				}
				
				const deleteBtn = (post.authorType !== 'system' || post.canDelete) ? 
					'<button class="control-btn delete-btn" onclick="app.deletePost(' + post.id + ')" title="Delete post">üóëÔ∏è</button>' : '';
				
				const repliesHtml = this.renderReplies(post.replies, 0, post.id);

				const replyCount = post.replies ? post.replies.length : 0;
				const isExpanded = post.expanded === true;
				const repliesHidden = post.repliesHidden === true;
				const preview = post.content.length > 100 ? post.content.substring(0, 100) + '...' : post.content;
				
				// COLLAPSED STATE (default)
				if (!isExpanded) {
					return '<div class="post-summary">' +
						'<div class="post-title" onclick="app.expandPost(' + post.id + ')">' + (post.title || 'Untitled') + '</div>' +
						'<div class="post-preview" style="color: #ccc; font-size: 0.9rem; margin: 0.5rem 0; line-height: 1.4;" onclick="app.expandPost(' + post.id + ')">' + preview + '</div>' +
						'<div class="post-meta">' +
							'<span>' + post.author + ' ‚Ä¢ ' + this.formatTime(post.timestamp) + '</span>' +
							'<span class="reply-count">' + replyCount + ' replies</span>' +
						'</div>' +
						'<div class="post-actions" style="margin-top: 0.5rem;">' +
							'<button class="action-btn">üí¨ ' + replyCount + '</button>' +
							'<button class="action-btn" onclick="app.toggleFavorite(' + post.id + ')">' + (post.favorited ? '‚ù§Ô∏è Favorited' : 'ü§ç Favorite') + '</button>' +
							'<button class="action-btn">üîó Share</button>' +
						'</div>' +
					'</div>';
				}

				// EXPANDED STATE
				const collapseBtn = '<button class="expand-btn" onclick="app.collapsePost(' + post.id + ')">Collapse post</button>';
				const toggleRepliesBtn = replyCount > 0 ? 
					'<button class="expand-btn" onclick="app.toggleReplies(' + post.id + ')">' + 
					(repliesHidden ? 'Show ' + replyCount + ' replies' : 'Hide replies') + '</button>' : '';

				return '<div class="post" data-post-id="' + post.id + '">' +
					'<div class="post-header" onclick="app.collapsePost(' + post.id + ')" style="cursor: pointer;">' +
						'<div class="post-author">' +
							'<div class="author-avatar">' + avatar + '</div>' +
							'<span class="author-name ' + authorClass + '">' + post.author + '</span>' +
							badge +
						'</div>' +
					'<div class="post-controls" onclick="event.stopPropagation();">' + deleteBtn + '</div>' +
					'<span class="post-time" style="margin-left: 0.5rem;">' + this.formatTime(post.timestamp) + '</span>' +
					'</div>' +
					'<div class="post-content">' + 
						(post.title ? '<strong>' + post.title + '</strong><br><br>' : '') + 
						post.content + 
					'</div>' +
					debateStatusHTML +
					'<div class="post-actions">' +
						'<button class="action-btn">üí¨ ' + replyCount + '</button>' +
						'<button class="action-btn" onclick="app.toggleFavorite(' + post.id + ')">' + (post.favorited ? '‚ù§Ô∏è Favorited' : 'ü§ç Favorite') + '</button>' +
						'<button class="action-btn" onclick="app.replyToPost(' + post.id + ')">Reply</button>' +
						'<button class="action-btn">üîó Share</button>' +
					'</div>' +
					'<div style="margin: 1rem 0;">' + collapseBtn + '</div>' +
					'<div style="margin: 0.5rem 0;">' + toggleRepliesBtn + '</div>' +
					(replyCount > 0 && !repliesHidden ? '<div class="replies">' + this.renderReplies(post.replies, 0, post.id) + '</div>' : '') +
				'</div>';
			}

            showProcessingIndicator() {
                const activity = document.getElementById('activity-list');
                const indicator = document.createElement('div');
                indicator.className = 'activity-item';
                indicator.id = 'processing-indicator';
                indicator.innerHTML = `
                    <div class="activity-icon"></div>
                    <div class="activity-text loading">
                        <div class="spinner"></div>
                        AI personas are thinking and responding...
                    </div>
                `;
                activity.insertBefore(indicator, activity.firstChild);
            }

            hideProcessingIndicator() {
                const indicator = document.getElementById('processing-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }

			toggleFavorite(postId) {
				const post = this.posts.find(p => p.id === postId);
				post.favorited = !post.favorited;
				this.savePosts();
				this.renderPosts();
			}

            addActivity(text) {
                const activity = document.getElementById('activity-list');
                const item = document.createElement('div');
                item.className = 'activity-item';
                item.innerHTML = `
                    <div class="activity-icon"></div>
                    <div class="activity-text">${text}</div>
                `;
                activity.insertBefore(item, activity.firstChild);

                // Keep only last 10 activities
                const items = activity.children;
                while (items.length > 10) {
                    activity.removeChild(items[items.length - 1]);
                }
            }

			replyToAI(postId, aiAuthor, replyId = null) {
				// Remove any existing reply forms first
				document.querySelectorAll('.reply-form').forEach(form => form.remove());
				
				const post = this.posts.find(p => p.id === postId);
				const repliesContainer = document.querySelector(`[data-post-id="${postId}"] .replies`);
				
				if (repliesContainer) {
					const replyForm = document.createElement('div');
					replyForm.className = 'reply-form';
					replyForm.innerHTML = `
						<div style="background: #1e1e1e; border: 1px solid #333; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
							<h4 style="color: #667eea; margin-bottom: 0.5rem;">Reply to ${aiAuthor}:</h4>
							<textarea 
								class="post-input" 
								id="reply-content-${postId}" 
								placeholder="Type your reply..."
								rows="3"
								style="width: 100%; margin-bottom: 0.5rem;"
							></textarea>
							<div style="display: flex; gap: 0.5rem;">
								<button class="submit-btn" onclick="app.submitReply(${postId}, '${aiAuthor}', ${replyId})">Post Reply</button>
								<button class="control-btn" onclick="app.cancelReply()">Cancel</button>
							</div>
						</div>
					`;
					repliesContainer.appendChild(replyForm);
					
					// Focus the textarea
					document.getElementById(`reply-content-${postId}`).focus();
				}
			}

			submitReply(postId, aiAuthor, replyId = null) {
				const replyContent = document.getElementById(`reply-content-${postId}`).value.trim();
				if (!replyContent) return;
				
				const post = this.posts.find(p => p.id === postId);
				const userReply = {
					id: this.nextPostId++,
					author: 'You',
					authorType: 'human',
					content: replyContent,
					timestamp: new Date(),
					replies: []
				};
				
				// Find the specific reply by ID recursively
				const targetReply = this.findReplyById(post.replies, replyId) || post.replies.find(r => r.author === aiAuthor);
				
				if (targetReply) {
					if (!targetReply.replies) targetReply.replies = [];
					targetReply.replies.push(userReply);
				} else {
					post.replies.push(userReply); // fallback to top level
				}
				
				this.savePosts();
				this.renderPosts();
				
				setTimeout(() => this.generateAIResponses(post, userReply), 1000);
			}

			// Add this helper function:
			findReplyById(replies, replyId) {
				if (!replies || !replyId) return null;
				
				for (let reply of replies) {
					if (reply.id === replyId) {
						return reply;
					}
					if (reply.replies) {
						const found = this.findReplyById(reply.replies, replyId);
						if (found) return found;
					}
				}
				return null;
			}

			findReplyIdByAuthor(post, authorName) {
				const reply = post.replies.find(r => r.author === authorName);
				return reply ? reply.id : null;
			}

			cancelReply() {
				document.querySelectorAll('.reply-form').forEach(form => form.remove());
			}

            getTotalPostCount() {
                return this.posts.length + this.posts.reduce((total, post) => 
                    total + (post.replies ? post.replies.length : 0), 0
                );
            }

            formatTime(date) {
                const now = new Date();
                const diff = now - date;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                
                if (minutes < 1) return 'just now';
                if (minutes < 60) return `${minutes}m ago`;
                if (hours < 24) return `${hours}h ago`;
                return date.toLocaleDateString();
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            randomBetween(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
			
			pauseDebate(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post || !post.debateMode) return;
				
				post.debateConfig.isPaused = true;
				this.savePosts();
				this.renderPosts();
				this.addActivity('Debate manually paused');
			}

			showParticipationMetrics(postId) {
				const post = this.posts.find(p => p.id === postId);
				if (!post || !post.debateMode) return;
				
				let metricsHTML = '<h4 style="color: #667eea; margin-bottom: 0.5rem;">Participation Stats:</h4>';
				metricsHTML += '<div style="display: flex; flex-direction: column; gap: 0.3rem;">';
				
				const sortedParticipation = Object.entries(post.participationCount)
					.sort((a, b) => b[1] - a[1]);
				
				if (sortedParticipation.length === 0) {
					metricsHTML += '<p style="color: #ccc;">No responses yet</p>';
				} else {
					sortedParticipation.forEach(([name, count]) => {
						metricsHTML += `<div style="color: #ccc;"><strong>${name}:</strong> ${count} posts</div>`;
					});
				}
				
				metricsHTML += '</div>';
				
				alert('Debate Participation\n\n' + sortedParticipation.map(([name, count]) => `${name}: ${count} posts`).join('\n'));
			}
			
        }

		let app;
        // Initialize the app when page loads
		document.addEventListener('DOMContentLoaded', () => {
			app = new AIForumApp();
		});
    </script>
</body>
</html>