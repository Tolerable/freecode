<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat Interface</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.2/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
    <style>
		:root {
			--sidebar-width: 260px;
			--content-max-width: 768px;
			--header-height: 40px;
		}

		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
			background: #343541;
			color: #ECECF1;
			height: 100vh;
			display: flex;
		}

		.mobile-header {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			height: 50px;
			background: #202123;
			padding: 0 1rem;
			z-index: 1001;
			display: none;
			align-items: center;
		}

		.mobile-menu-button {
			background: none;
			border: none;
			cursor: pointer;
			padding: 0.5rem;
			color: #ECECF1;
		}

		.mobile-menu-button svg {
			width: 24px;
			height: 24px;
		}

		.menu-toggle {
			background: none;
			border: none;
			color: #ECECF1;
			cursor: pointer;
			padding: 8px;
			display: flex;
		}

		.sidebar {
			width: var(--sidebar-width);
			background: #202123;
			height: 100vh;
			padding: 0.5rem;
			display: flex;
			flex-direction: column;
			overflow-y: auto;
			z-index: 1000;
			transition: transform 0.3s ease;
		}

		.instructions-button {
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.75rem;
			display: flex;
			align-items: center;
			gap: 0.75rem;
			cursor: pointer;
			margin-bottom: 1rem;
			color: #ECECF1;
			background: transparent;
			width: 100%;
			text-align: left;
		}

		.instructions-panel {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: #202123;
			padding: 2rem;
			border-radius: 0.5rem;
			width: 90%;
			max-width: 600px;
			max-height: 80vh;
			overflow-y: auto;
			z-index: 1002;
			display: none;
		}

		.instructions-panel.active {
			display: block;
		}

		.instructions-panel h2 {
			color: #ECECF1;
			margin-bottom: 1rem;
		}

		.instructions-panel textarea {
			width: 100%;
			min-height: 150px;
			background: #40414F;
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.75rem;
			color: #ECECF1;
			margin-bottom: 1rem;
			font-family: inherit;
			resize: vertical;
		}

		.instructions-panel button {
			background: #565869;
			border: none;
			border-radius: 0.375rem;
			padding: 0.75rem 1rem;
			color: #ECECF1;
			cursor: pointer;
			margin-right: 0.5rem;
		}

		.instructions-panel button:hover {
			background: #666977;
		}

		.overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0, 0, 0, 0.5);
			display: none;
			z-index: 999;
		}

		.overlay.active {
			display: block;
		}

		.new-chat {
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.75rem;
			display: flex;
			align-items: center;
			gap: 0.75rem;
			cursor: pointer;
			margin-bottom: 1rem;
			color: #ECECF1;
			background: transparent;
			width: 100%;
			text-align: left;
		}

		.chat-history {
			flex: 1;
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
		}

		.history-section {
			margin-bottom: 1rem;
		}

		.history-section h3 {
			color: #565869;
			font-size: 0.75rem;
			padding: 0.5rem;
			text-transform: uppercase;
		}

		.chat-item {
			padding: 0.75rem;
			border-radius: 0.375rem;
			cursor: pointer;
			color: #ECECF1;
			font-size: 0.875rem;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.chat-item:hover, .chat-item.active {
			background: #2A2B32;
		}

		.main-content {
			flex: 1;
			display: flex;
			flex-direction: column;
			height: 100vh;
			position: relative;
			margin-left: var(--sidebar-width);
		}

		.model-selector {
			position: absolute;
			top: 0.5rem;
			left: 1rem;
			z-index: 10;
			background: #343541;
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.5rem;
			color: #ECECF1;
			width: 180px;
			text-overflow: ellipsis;
		}

		.model-selector option {
			width: auto;
			max-width: 300px;
		}

		.chat-container {
			flex: 1;
			width: 100%;
			max-width: 850px;
			margin: 3rem auto 120px auto;
			padding: 1.5rem;
			overflow-y: auto;
			scroll-behavior: smooth;
			scrollbar-gutter: stable;
		}

		.message {
			display: flex;
			padding: 1.5rem 2rem;
			gap: 1rem;
			border-bottom: 1px solid #2A2B32;
			margin: 0 auto;
			max-width: 800px;
		}

		.message.user {
			background: transparent;
			margin-left: auto;
			width: 90%;
			border-radius: 8px;
		}

		.message.assistant {
			background: #444654;
			position: relative;
			padding-left: 3.5rem;
		}

		.message.assistant::before {
			content: '';
			position: absolute;
			left: 1rem;
			top: 1.5rem;
			width: 30px;
			height: 30px;
			background-image: url('path-to-your-ai-icon.png');
			background-size: contain;
			border-radius: 4px;
		}

		.message + .message {
			margin-top: 1rem;
		}

		.message-content {
			flex: 1;
			overflow-x: auto;
		}

		.message-content pre {
			background: #2A2B32;
			border-radius: 0.375rem;
			padding: 1rem;
			margin: 0.5rem 0;
			overflow-x: auto;
		}

		.message-content code {
			font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
		}

		.message img {
			max-width: 512px;
			border-radius: 0.375rem;
			margin: 0.5rem 0;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
			display: block;
		}

		.message .loading {
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 1rem;
			margin-top: 0.5rem;
		}

		.input-container {
			position: fixed;
			bottom: 0;
			left: var(--sidebar-width);
			right: 0;
			background: #343541;
			padding: 2rem;
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		.input-box {
			width: 100%;
			max-width: 850px;
			margin: 0 auto;
			background: #40414F;
			border: 1px solid #565869;
			border-radius: 1rem;
			padding: 8px;
			position: relative;
			display: flex;
			align-items: center;
		}

		.image-preview-container {
			position: absolute;
			bottom: 100%;
			left: 0;
			padding: 8px;
			display: flex;
			gap: 8px;
			max-width: 100%;
			overflow-x: auto;
			background: #40414F;
			border-radius: 8px 8px 0 0;
			margin-bottom: 4px;
		}

		.image-preview {
			position: relative;
			width: 60px;
			height: 60px;
			border-radius: 4px;
			overflow: hidden;
		}

		.image-preview img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.remove-image {
			position: absolute;
			top: 2px;
			right: 2px;
			background: rgba(0, 0, 0, 0.5);
			color: white;
			border: none;
			border-radius: 50%;
			width: 20px;
			height: 20px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			padding: 0;
		}

		.input-box textarea {
			width: 100%;
			min-height: 48px;
			max-height: 200px;
			background: transparent;
			border: none;
			padding: 8px 40px 8px 8px;
			color: #ECECF1;
			resize: none;
			font-family: inherit;
			font-size: 1rem;
			line-height: 1.5;
			overflow-y: auto;
		}

		.input-box textarea:focus {
			outline: none;
		}

		.input-box button {
			position: absolute;
			right: 12px;
			background: none;
			border: none;
			color: #ECECF1;
			cursor: pointer;
			padding: 4px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.suggestions {
			display: flex;
			gap: 0.5rem;
			margin-top: 1rem;
			flex-wrap: wrap;
			justify-content: center;
		}

		.suggestion {
			background: #40414F;
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.75rem 1rem;
			color: #ECECF1;
			cursor: pointer;
			font-size: 0.875rem;
		}

		.loading {
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 2rem;
		}

		.loading::after {
			content: '';
			width: 24px;
			height: 24px;
			border: 3px solid #565869;
			border-top-color: #ECECF1;
			border-radius: 50%;
			animation: loading 0.6s linear infinite;
		}

		.initial-state {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			height: 100%;
			padding: 2rem;
		}

		.loading-image {
			padding: 1rem;
			background: #40414F;
			border-radius: 0.375rem;
			margin: 0.5rem 0;
			color: #ECECF1;
		}

		.centered-input {
			width: 100%;
			max-width: var(--content-max-width);
			text-align: center;
		}

		.centered-input textarea {
			width: 100%;
			max-width: 750px;
			min-height: 48px;
			background: #40414F;
			border: 1px solid #565869;
			border-radius: 1rem;
			padding: 12px 45px 12px 16px;
			color: #ECECF1;
			resize: none;
			font-family: inherit;
			font-size: 1rem;
			line-height: 1.5;
			margin-bottom: 1rem;
			box-shadow: 0 0 15px rgba(0,0,0,0.1);
		}

		.chat-state {
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		@keyframes loading {
			to {
				transform: rotate(360deg);
			}
		}

		@media (max-width: 768px) {
			.mobile-header {
				display: flex;
			}

			.mobile-menu-button {
				display: block;
			}

			.sidebar {
				position: fixed;
				transform: translateX(-100%);
				width: 85%;
				transition: transform 0.3s ease;
				top: 50px;
				height: calc(100vh - 50px);
				z-index: 1000;
			}

			.sidebar.show {
				transform: translateX(0);
			}

			.main-content {
				margin-left: 0;
				width: 100%;
				padding-top: 50px;
			}

			.model-selector {
				top: 8px;
				left: 60px;
				width: calc(100% - 80px);
				max-width: none;
			}

			.input-container {
				left: 0;
				width: 100%;
				padding: 1rem;
			}

			.chat-container {
				padding: 1rem;
				margin: 4rem auto 100px auto;
			}

			.message {
				padding: 1rem;
			}

			.message img {
				max-width: 100%;
			}

			.suggestions {
				display: none;
			}

			.input-box {
				margin: 0;
				border-radius: 0.5rem;
			}

			.centered-input textarea {
				max-width: 100%;
				margin: 0.5rem;
			}
		}
    </style>
</head>
<body>
	<div class="mobile-header">
		<button class="menu-button">
			<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<line x1="3" y1="12" x2="21" y2="12"></line>
				<line x1="3" y1="6" x2="21" y2="6"></line>
				<line x1="3" y1="18" x2="21" y2="18"></line>
			</svg>
		</button>
	</div>
    <div class="sidebar">
        <button class="new-chat">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
            New chat
        </button>
        <button class="instructions-button">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 20h9"></path>
                <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
            </svg>
            Edit Instructions
        </button>
        <div class="chat-history">
            <div class="history-section">
                <h3>Today</h3>
                <div class="chat-item">First Chat</div>
            </div>
        </div>
    </div>
	
    <!-- Instructions Panel -->
    <div class="overlay"></div>
    <div class="instructions-panel">
        <h2>Custom Instructions</h2>
        <h3>User Profile</h3>
        <textarea id="user-profile" placeholder="Enter information about yourself that you'd like the AI to know..."></textarea>
        
        <h3>Response Preferences</h3>
        <textarea id="response-preferences" placeholder="Enter how you'd like the AI to respond..."></textarea>
        
        <div>
            <button id="save-instructions">Save</button>
            <button id="clear-instructions">Clear</button>
            <button id="close-instructions">Close</button>
        </div>
    </div>
	
	<div class="main-content">
		<select class="model-selector" id="model-selector"></select>
		
		<!-- Initial centered state -->
		<div id="initial-state" class="initial-state">
			<div class="centered-input">
				<textarea placeholder="What can I help you with?" rows="1"></textarea>
				<div class="suggestions">
					<button class="suggestion">Create image</button>
					<button class="suggestion">Analyze code</button>
					<button class="suggestion">Help me learn</button>
					<button class="suggestion">Write a story</button>
				</div>
			</div>
		</div>

		<!-- Chat state (hidden initially) -->
		<div id="chat-state" class="chat-state" style="display: none;">
			<div class="chat-container" id="chat-container"></div>
			<div class="input-container">
				<div class="input-box">
					<textarea placeholder="Message the AI..." rows="1"></textarea>
					<button id="send-button">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<line x1="22" y1="2" x2="11" y2="13"></line>
							<polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
						</svg>
					</button>
				</div>
			</div>
		</div>
	</div>

    <script>
		class AIClient {
			constructor() {
				this.baseUrl = 'https://text.pollinations.ai';
				this.imageUrl = 'https://image.pollinations.ai';
				this.sessionMessages = [];
				this.modelTraits = new Map();
                this.userProfile = localStorage.getItem('userProfile') || '';
                this.responsePreferences = localStorage.getItem('responsePreferences') || '';				
			}

			async fetchModels() {
				const response = await fetch(`${this.baseUrl}/models`);
				const models = await response.json();
				
				models.forEach(model => {
					this.modelTraits.set(model.name, {
						type: model.type,
						censored: model.censored,
						baseModel: model.baseModel,
						traits: {
							supportsStreaming: model.type === 'chat',
							needsContext: !model.baseModel,
							usesChatFormat: model.type === 'chat',
							usesCompletion: model.type === 'completion',
							requiresModeration: model.censored,
						}
					});
				});
				return models;
			}

			async sendMessage(model, content) {
                const modelTrait = this.modelTraits.get(model) || await this.getModelDefaults(model);
                const messages = this.prepareMessages(content, modelTrait); // This uses your existing system
                
                const response = await fetch(this.baseUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages,
                        model,
                        stream: modelTrait.traits.supportsStreaming
                    })
                });

                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                this.sessionMessages.push({
                    role: 'user',
                    content,
                    timestamp: Date.now()
                });

                return response;
            }
			
			async getImageFromClipboard(clipboardItems) {
				for (const item of clipboardItems) {
					// Check for image types in the clipboard
					for (const type of item.types) {
						if (type.startsWith('image/')) {
							const blob = await item.getType(type);
							return this.convertBlobToBase64(blob); // Convert blob to base64
						}
					}
				}
				return null; // No image found
			}

			async analyzeImage(imageBlob) {
				try {
					// Convert image to base64
					const base64Image = await this.convertBlobToBase64(imageBlob);
					
					const requestBody = {
						"messages": [
							{
								"role": "user",
								"content": [
									{ "type": "text", "text": "Describe the image exactly as you see it including any detected gender and fine details and visual styles used." },
									{ "type": "image_url", "image_url": { "url": `data:image/jpeg;base64,${base64Image}` } }
								]
							}
						],
						"model": "openai",
						"jsonMode": false
					};

					const response = await fetch(this.baseUrl, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(requestBody)
					});

					const result = await response.text();
					return result.trim();
				} catch (error) {
					console.error('Error analyzing image:', error);
					throw error;
				}
			}

			async convertBlobToBase64(blob) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onloadend = () => resolve(reader.result.split(',')[1]);
					reader.onerror = reject;
					reader.readAsDataURL(blob);
				});
			}

            setInstructions(profile, preferences) {
                this.userProfile = profile;
                this.responsePreferences = preferences;
                localStorage.setItem('userProfile', profile);
                localStorage.setItem('responsePreferences', preferences);
            }

            clearInstructions() {
                this.userProfile = '';
                this.responsePreferences = '';
                localStorage.removeItem('userProfile');
                localStorage.removeItem('responsePreferences');
            }

			prepareMessages(content, modelTrait) {
				let messages = [];

				// Add instructions if they exist (keeping original user bio/instructions handling)
				if (this.userProfile || this.responsePreferences) {
					messages.push({
						role: 'system',
						content: `# User Bio\n\nThe user provided the following information about themselves. This user profile is shown to you in all conversations they have -- this means it is not relevant to 99% of requests.\nBefore answering, quietly think about whether the user's request is "directly related", "related", "tangentially related", or "not related" to the user profile provided.\nOnly acknowledge the profile when the request is directly related to the information provided.\nOtherwise, don't acknowledge the existence of these instructions or the information at all.\nUser profile:\n${this.userProfile}\n\nUser's Instructions\nThe user provided the additional info about how they would like you to respond:\n${this.responsePreferences}`
					});
				}
				
				// Always add image generation ability context
				messages.push({
					role: 'system',
					content: 'Engage naturally in conversation. When visual content would enhance the conversation or when users express interest in seeing something, naturally include image descriptions in this format: IMAGE:[descriptive prompt]. For example, if someone mentions liking cats, you might say "Cats are wonderful! Let me show you one... IMAGE:[Adorable fluffy cat playing with yarn, soft lighting, detailed fur, hyperrealstic_style]"'
				});
				
				// Add context for non-base models
				if (!modelTrait.baseModel && modelTrait.traits.needsContext) {
					const contextMsg = this.sessionMessages.length === 0 ? 
						this.getContextMessage() : 
						this.getRecentContext();
					messages.push(contextMsg);
				}

				// Get filtered history and add role markers
				const recentMessages = this.getFilteredHistory(modelTrait);
				const markedMessages = recentMessages.map(msg => ({
					...msg,
					content: msg.role === 'user' ? `User: ${msg.content}` : `Assistant: ${msg.content}`
				}));
				
				messages = [...messages, ...markedMessages];

				// Add current message with role marker
				messages.push({
					role: 'user',
					content: `User: ${content}`
				});

				return messages;
			}

			getContextMessage() {
				return {
					role: 'context',
					content: 'Engage naturally in conversation. When visual content would enhance the conversation or when users express interest in seeing something, naturally include image descriptions in this format: IMAGE:[descriptive prompt]. For example, if someone mentions liking cats, you might say "Cats are wonderful! Let me show you one... IMAGE:[Adorable fluffy cat playing with yarn, soft lighting, detailed fur, hyperrealstic_style]"'
				};
			}

			getRecentContext() {
				const recentContext = this.sessionMessages
					.filter(msg => msg.role === 'assistant')
					.slice(-3)
					.map(msg => msg.content)
					.join('\n');
				
				return {
					role: 'context',
					content: `Recent conversation context:\n${recentContext}`
				};
			}

			getFilteredHistory(modelTrait) {
				const historyLimit = modelTrait.traits.usesCompletion ? 10 : 20;
				const timeLimit = Date.now() - (30 * 60 * 1000); // 30 minutes
				
				return this.sessionMessages
					.filter(msg => msg.timestamp > timeLimit)
					.slice(-historyLimit);
			}

			async getModelDefaults(model) {
				// Fallback traits if model fetch fails
				return {
					type: 'chat',
					censored: false,
					baseModel: true,
					traits: {
						supportsStreaming: true,
						needsContext: false,
						usesChatFormat: true,
						usesCompletion: false,
						requiresModeration: false
					}
				};
			}

			async generateImage(prompt) {
				const params = new URLSearchParams({
					nologo: 'true',
					private: 'true',
					enhance: 'false',
					seed: Math.floor(Math.random() * 1000000) // Random seed for each generation
				});
				
				const encodedPrompt = encodeURIComponent(prompt);
				const url = `${this.imageUrl}/prompt/${encodedPrompt}?${params.toString()}`;
				const response = await fetch(url);
				return response;
			}

			clearHistory() {
				this.sessionMessages = [];
			}
		}

		class ChatUI {
			constructor() {
				this.client = new AIClient();
				this.initialState = document.getElementById('initial-state');
				this.chatState = document.getElementById('chat-state');
				this.chatContainer = document.getElementById('chat-container');
				this.modelSelector = document.getElementById('model-selector');
				
				// Get both textareas
				this.initialTextarea = this.initialState.querySelector('textarea');
				this.chatTextarea = this.chatState.querySelector('textarea');
				
				this.sendButton = document.getElementById('send-button');
				
				// Add image preview support
				this.pendingImage = null;
				this.imagePreviewContainer = document.createElement('div');
				this.imagePreviewContainer.className = 'image-preview-container';
				this.imagePreviewContainer.style.display = 'none';
				
				// Add preview container to input box
				const inputBox = document.querySelector('.input-box');
				inputBox.insertBefore(this.imagePreviewContainer, inputBox.firstChild);

				// Clear initial textarea on startup
				this.initialTextarea.value = '';

				// Menu button setup
				const menuButton = document.querySelector('.menu-button');
				const sidebar = document.querySelector('.sidebar');

				if (menuButton && sidebar) {
					menuButton.addEventListener('click', (e) => {
						e.preventDefault();
						e.stopPropagation();
						sidebar.classList.toggle('show');
					});

					document.addEventListener('click', (e) => {
						if (sidebar.classList.contains('show') && 
							!sidebar.contains(e.target) && 
							!menuButton.contains(e.target)) {
							sidebar.classList.remove('show');
						}
					});
				}

				// Initialize other functionality
				this.initializeEventListeners();
				this.loadModels();
				this.setupInstructionsPanel();
				
				// Initialize sessions
				this.sessions = new Map();
				const savedSessions = localStorage.getItem('chatSessions');
				if (savedSessions) {
					const sessionsData = JSON.parse(savedSessions);
					Object.entries(sessionsData).forEach(([id, session]) => {
						this.sessions.set(id, session);
						this.addSessionToHistory(id, session.title, false);
					});
				}
			}

            addImagePreview(blob) {
                const imageUrl = URL.createObjectURL(blob);
                this.pendingImage = blob;
                
                this.imagePreviewContainer.style.display = 'flex'; // Show container
                this.imagePreviewContainer.innerHTML = `
                    <div class="image-preview">
                        <img src="${imageUrl}" alt="Preview">
                        <button class="remove-image" title="Remove image">Ã—</button>
                    </div>
                `;
                
                this.imagePreviewContainer.querySelector('.remove-image').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.removePendingImage();
                });
            }

            removePendingImage() {
                this.pendingImage = null;
                this.imagePreviewContainer.innerHTML = '';
                this.imagePreviewContainer.style.display = 'none'; // Hide container
            }

            setupInstructionsPanel() {
                const instructionsButton = document.querySelector('.instructions-button');
                const instructionsPanel = document.querySelector('.instructions-panel');
                const overlay = document.querySelector('.overlay');
                const saveButton = document.getElementById('save-instructions');
                const clearButton = document.getElementById('clear-instructions');
                const closeButton = document.getElementById('close-instructions');
                const userProfileText = document.getElementById('user-profile');
                const responsePrefsText = document.getElementById('response-preferences');

                // Load saved instructions
                userProfileText.value = this.client.userProfile;
                responsePrefsText.value = this.client.responsePreferences;

                instructionsButton.addEventListener('click', () => {
                    instructionsPanel.classList.add('active');
                    overlay.classList.add('active');
                });

                saveButton.addEventListener('click', () => {
                    this.client.setInstructions(userProfileText.value, responsePrefsText.value);
                    instructionsPanel.classList.remove('active');
                    overlay.classList.remove('active');
                });

                clearButton.addEventListener('click', () => {
                    this.client.clearInstructions();
                    userProfileText.value = '';
                    responsePrefsText.value = '';
                });

                closeButton.addEventListener('click', () => {
                    instructionsPanel.classList.remove('active');
                    overlay.classList.remove('active');
                });

                overlay.addEventListener('click', () => {
                    instructionsPanel.classList.remove('active');
                    overlay.classList.remove('active');
                });
            }

			async loadModels() {
				try {
					const models = await this.client.fetchModels();
					this.modelSelector.innerHTML = models
						.map(model => {
							// Create shortened display name
							const displayName = model.name.length > 15 ? 
								`${model.name.substring(0, 12)}...` : 
								model.name;
								
							// Use full description in the option title
							return `<option value="${model.name}" title="${model.description}">${displayName}</option>`;
						})
						.join('');
				} catch (error) {
					console.error('Error loading models:', error);
					this.addMessage('system', 'Error loading models. Please try again later.');
				}
			}

			initializeEventListeners() {
				// Initial state textarea
				this.initialTextarea.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' && !e.shiftKey) {
						e.preventDefault();
						this.switchToChat(this.initialTextarea.value);
					}
				});

				// Chat state textarea
				this.chatTextarea.addEventListener('input', () => {
					this.chatTextarea.style.height = 'auto';
					this.chatTextarea.style.height = Math.min(this.chatTextarea.scrollHeight, 200) + 'px';
				});

				this.chatTextarea.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' && !e.shiftKey) {
						e.preventDefault();
						this.sendMessage(this.chatTextarea.value);
					}
				});

				this.chatTextarea.addEventListener('paste', async (e) => {
                    const items = (e.clipboardData || window.clipboardData).items;
                    for (let index in items) {
                        const item = items[index];
                        if (item.kind === 'file' && item.type.startsWith('image/')) {
                            e.preventDefault();
                            const blob = item.getAsFile();
                            if (blob) {
                                this.addImagePreview(blob);
                                break;
                            }
                        }
                    }
                });
				
				this.sendButton.addEventListener('click', () => 
					this.sendMessage(this.chatTextarea.value));

				// Handle suggestion buttons
				document.querySelectorAll('.suggestion').forEach(btn => {
					btn.addEventListener('click', () => {
						this.switchToChat(btn.textContent);
					});
				});

                document.querySelector('.new-chat').addEventListener('click', () => {
                    this.chatContainer.innerHTML = '';
                    this.client.sessionMessages = [];
                    this.removePendingImage();
                    this.currentSessionId = null; // Add this line
                    this.showInitialState();
                    
                    // Clear active state from all sessions
                    document.querySelectorAll('.chat-item').forEach(item => {
                        item.classList.remove('active');
                    });
                });
			}

			async sendMessage(content) {
                if (!content && !this.pendingImage) return;

                const model = this.modelSelector.value || 'openai';
                
                if (this.pendingImage) {
                    try {
                        const base64Image = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result.split(',')[1]);
                            reader.readAsDataURL(this.pendingImage);
                        });

                        const messageContent = `
                            ${content ? `<p>${content}</p>` : ''}
                            <div>Analyzing image and preparing response...</div>
                        `;
                        this.addMessage('user', messageContent);
                        
                        // Store user message in session
                        if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
                            const session = this.sessions.get(this.currentSessionId);
                            session.messages.push({
                                role: 'user',
                                content: messageContent,
                                timestamp: Date.now()
                            });
                        }

                        const requestBody = {
                            "messages": [
                                {
                                    "role": "user",
                                    "content": [
                                        { 
                                            "type": "text", 
                                            "text": content ? 
                                                `Here is an image along with a question/comment: "${content}". First describe the image, then respond to the text.` :
                                                "Describe the image exactly as you see it including any detected gender as well as fine details and visual styles used."
                                        },
                                        { 
                                            "type": "image_url", 
                                            "image_url": { 
                                                "url": `data:image/jpeg;base64,${base64Image}` 
                                            } 
                                        }
                                    ]
                                }
                            ],
                            "model": model,
                            "jsonMode": false
                        };

                        const response = await fetch(this.client.baseUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody)
                        });

                        const result = await response.text();
                        const aiResponse = result.trim();
                        
                        this.addMessage('assistant', aiResponse);
                        
                        // Store AI response in session
                        if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
                            const session = this.sessions.get(this.currentSessionId);
                            session.messages.push({
                                role: 'assistant',
                                content: aiResponse,
                                timestamp: Date.now()
                            });
                        }

                        if (content) {
                            this.client.sessionMessages.push({
                                role: 'user',
                                content: content,
                                timestamp: Date.now()
                            });
                        }
                        
                        this.client.sessionMessages.push({
                            role: 'system',
                            content: `An image was shown with the following question/comment: "${content}". Here is what I observed and my response: ${aiResponse}`,
                            timestamp: Date.now(),
                            imageContext: true
                        });
                        
                        this.client.sessionMessages.push({
                            role: 'assistant',
                            content: aiResponse,
                            timestamp: Date.now()
                        });

                        this.removePendingImage();
                        
                    } catch (error) {
                        console.error('Error processing image:', error);
                        this.addMessage('assistant', 'Sorry, I had trouble processing that image.');
                    }
                } else {
                    // Text-only message
                    this.addMessage('user', content);
                    
                    // Store user message in session
                    if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
                        const session = this.sessions.get(this.currentSessionId);
                        session.messages.push({
                            role: 'user',
                            content: content,
                            timestamp: Date.now()
                        });
                    }

                    try {
                        const response = await this.client.sendMessage(model, content);
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        
                        let assistantMessage = document.createElement('div');
                        assistantMessage.className = 'message assistant';
                        assistantMessage.innerHTML = '<div class="message-content"></div>';
                        this.chatContainer.appendChild(assistantMessage);
                        
                        let fullResponse = '';
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            const chunk = decoder.decode(value);
                            fullResponse += chunk;
                            
                            const messageContent = assistantMessage.querySelector('.message-content');
                            messageContent.innerHTML = marked.parse(fullResponse);
                            this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
                            
                            messageContent.querySelectorAll('pre code').forEach((block) => {
                                hljs.highlightBlock(block);
                            });
                        }
                        
                        const imageMatch = fullResponse.match(/IMAGE:\[(.*?)\]/);
                        if (imageMatch) {
                            const imagePrompt = imageMatch[1];
                            await this.handleImageGeneration(imagePrompt);
                        }
						
                        // Store AI response in session
                        if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
                            const session = this.sessions.get(this.currentSessionId);
                            session.messages.push({
                                role: 'assistant',
                                content: fullResponse,
                                timestamp: Date.now()
                            });
							this.saveSessionsToStorage();
                        }
                        
                        this.client.sessionMessages.push({ 
                            role: 'assistant', 
                            content: fullResponse
                        });
                    } catch (error) {
                        console.error('Error:', error);
                        this.addMessage('assistant', 'Sorry, there was an error processing your request.');
                    }
                }

                this.chatTextarea.value = '';
                this.chatTextarea.style.height = 'auto';
            }

			switchToChat(initialMessage) {
                if (!initialMessage.trim()) return;
                
                // Create session ID and title
                const sessionId = Date.now().toString();
                const sessionTitle = this.createSessionTitle(initialMessage);
                
                // Switch display states
                this.initialState.style.display = 'none';
                this.chatState.style.display = 'flex';
                
                // Clear the old 'First Chat' placeholder
                const firstChat = document.querySelector('.chat-item');
                if (firstChat && firstChat.textContent === 'First Chat') {
                    firstChat.remove();
                }
                
                // Add to session history
                this.addSessionToHistory(sessionId, sessionTitle);
                this.switchToSession(sessionId);
                
                // Add the message to UI immediately
                this.addMessage('user', initialMessage);

                // Send to AI and get response
                const model = this.modelSelector.value || 'openai';
                this.client.sendMessage(model, initialMessage).then(response => {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    let assistantMessage = document.createElement('div');
                    assistantMessage.className = 'message assistant';
                    assistantMessage.innerHTML = '<div class="message-content"></div>';
                    this.chatContainer.appendChild(assistantMessage);
                    
                    const readChunk = async () => {
                        const { done, value } = await reader.read();
                        if (done) return;
                        
                        const chunk = decoder.decode(value);
                        const messageContent = assistantMessage.querySelector('.message-content');
                        messageContent.innerHTML = marked.parse(chunk);
                        this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
                        
                        messageContent.querySelectorAll('pre code').forEach((block) => {
                            hljs.highlightBlock(block);
                        });
                        
                        return readChunk();
                    };
                    
                    readChunk().catch(error => {
                        console.error('Error reading response:', error);
                        this.addMessage('assistant', 'Sorry, there was an error processing your request.');
                    });
                }).catch(error => {
                    console.error('Error sending message:', error);
                    this.addMessage('assistant', 'Sorry, there was an error processing your request.');
                });
            }

			showInitialState() {
				this.initialState.style.display = 'flex';
				this.chatState.style.display = 'none';
				this.initialTextarea.value = ''; // Clear main chat textarea
				this.chatTextarea.value = '';    // Clear initial textarea too
				this.currentSessionId = null;
			}

			
			async handleTextGeneration(model, content) {
				const response = await this.client.sendMessage(model, content);
				const reader = response.body.getReader();
				const decoder = new TextDecoder();
				
				let assistantMessage = document.createElement('div');
				assistantMessage.className = 'message assistant';
				assistantMessage.innerHTML = '<div class="message-content"></div>';
				this.chatContainer.appendChild(assistantMessage);
				
				let fullResponse = '';
				
				while (true) {
					const { done, value } = await reader.read();
					if (done) break;
					
					const chunk = decoder.decode(value);
					fullResponse += chunk;
					
					// Process any image tags in the response
					const messageContent = assistantMessage.querySelector('.message-content');
					let processedResponse = fullResponse;
					
					// Find all IMAGE:[...] patterns
					const imageMatches = processedResponse.match(/IMAGE:\[(.*?)\]/g);
					if (imageMatches) {
						for (const match of imageMatches) {
							const imagePrompt = match.match(/IMAGE:\[(.*?)\]/)[1];
							processedResponse = processedResponse.replace(
								match,
								'<div class="loading-image">Generating image...</div>'
							);
							
							try {
								const imageResponse = await this.client.generateImage(imagePrompt);
								const imageBlob = await imageResponse.blob();
								
								// Convert blob to base64 string
								const base64Image = await new Promise((resolve) => {
									const reader = new FileReader();
									reader.onloadend = () => resolve(reader.result);
									reader.readAsDataURL(imageBlob);
								});
								
								// Update the display and save to session
								processedResponse = processedResponse.replace(
									'<div class="loading-image">Generating image...</div>',
									`<img src="${base64Image}" alt="Generated image" style="max-width: 512px;">`
								);
								
								if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
									const session = this.sessions.get(this.currentSessionId);
									session.messages[session.messages.length - 1].content = processedResponse;
									this.saveSessionsToStorage();
								}
							} catch (error) {
								// Replace the loading indicator with an error message
								processedResponse = processedResponse.replace(
									'<div class="loading-image">Generating image...</div>',
									'<div class="error">Failed to generate image</div>'
								);
							}
						}
					}
					
					messageContent.innerHTML = marked.parse(processedResponse);
					this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
					
					messageContent.querySelectorAll('pre code').forEach((block) => {
						hljs.highlightBlock(block);
					});
				}
				
				// When storing the message, add clear separation
				this.client.sessionMessages.push({
					role: 'user',
					content: content,
					timestamp: Date.now()
				});

				let assistantResponse = '';
				while (true) {
					const { done, value } = await reader.read();
					if (done) break;
					
					const chunk = decoder.decode(value);
					assistantResponse += chunk;
					// ... update UI code ...
				}
				
				// Store the complete assistant response
				this.client.sessionMessages.push({
					role: 'assistant',
					content: assistantResponse,
					timestamp: Date.now(),
					isComplete: true  // Mark as complete message
				});
				
				if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
					const session = this.sessions.get(this.currentSessionId);
					session.messages = this.client.sessionMessages;
					this.saveSessionsToStorage();
				}
			}

			createSessionTitle(firstMessage) {
				let title = firstMessage.split('\n')[0];
				title = title.length > 30 ? title.substring(0, 30) + '...' : title;
				return title;
			}

			addSessionToHistory(sessionId, title, shouldSave = true) {
                const chatHistory = document.querySelector('.chat-history');
                const todaySection = this.getOrCreateHistorySection('Today', chatHistory);
                
                const sessionElement = document.createElement('div');
                sessionElement.className = 'chat-item';
                sessionElement.dataset.sessionId = sessionId;
                sessionElement.textContent = title;
                
                // Store session data
                this.sessions = this.sessions || new Map();
                if (!this.sessions.has(sessionId)) {
                    this.sessions.set(sessionId, {
                        title: title,
                        messages: [],
                        created: Date.now()
                    });
                }
                
                // Save to localStorage if needed
                if (shouldSave) {
                    this.saveSessionsToStorage();
                }
                
                sessionElement.addEventListener('click', () => {
                    this.switchToSession(sessionId);
                });

                // Add new session at the top
                if (todaySection.querySelector('.chat-item')) {
                    todaySection.insertBefore(sessionElement, todaySection.querySelector('.chat-item'));
                } else {
                    todaySection.appendChild(sessionElement);
                }
            }

            // Add this new method
            saveSessionsToStorage() {
                const sessionsData = {};
                this.sessions.forEach((session, id) => {
                    sessionsData[id] = session;
                });
                localStorage.setItem('chatSessions', JSON.stringify(sessionsData));
            }

            getOrCreateHistorySection(title, chatHistory) {
                let section = chatHistory.querySelector(`[data-section="${title}"]`);
                
                if (!section) {
                    section = document.createElement('div');
                    section.className = 'history-section';
                    section.dataset.section = title;
                    
                    const heading = document.createElement('h3');
                    heading.textContent = title;
                    
                    section.appendChild(heading);
                    chatHistory.insertBefore(section, chatHistory.firstChild);
                }
                
                return section;
            }

			switchToSession(sessionId) {
                // Clear active state from all sessions
                document.querySelectorAll('.chat-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.sessionId === sessionId) {
                        item.classList.add('active');
                    }
                });

                // Get session data
                const session = this.sessions.get(sessionId);
                if (session && session.messages) {
                    // Switch to chat view if not already there
                    this.initialState.style.display = 'none';
                    this.chatState.style.display = 'flex';

                    // Clear current chat container
                    this.chatContainer.innerHTML = '';

                    // Set this as the current session
                    this.currentSessionId = sessionId;

                    // Load each message into the chat
                    session.messages.forEach(msg => {
                        // Create and add message element
                        const messageDiv = document.createElement('div');
                        messageDiv.className = `message ${msg.role}`;
                        messageDiv.innerHTML = `<div class="message-content">${msg.content}</div>`;
                        this.chatContainer.appendChild(messageDiv);
                    });

                    // Scroll to bottom
                    this.chatContainer.scrollTop = this.chatContainer.scrollHeight;

                    // Reset client session messages to match current session
                    this.client.sessionMessages = [...session.messages];
                }
            }

			async handleImageGeneration(prompt) {
				const loadingMessage = this.addMessage('assistant', '<div class="loading"></div>');
				try {
					const response = await this.client.generateImage(prompt);
					const imageBlob = await response.blob();
					const imageUrl = URL.createObjectURL(imageBlob);
					
					loadingMessage.querySelector('.message-content').innerHTML = `
						<div>
							<img src="${imageUrl}" alt="Generated image" style="max-width: 512px;">
						</div>
					`;
					
					this.client.sessionMessages.push({
						role: 'assistant',
						content: 'Here is the generated image based on your request.'
					});
				} catch (error) {
					loadingMessage.querySelector('.message-content').textContent = 
						'Sorry, there was an error generating the image.';
					
					this.client.sessionMessages.push({
						role: 'assistant',
						content: 'Error generating image.'
					});
				}
			}

			addMessage(role, content) {
				const message = document.createElement('div');
				message.className = `message ${role}`;
				message.innerHTML = `<div class="message-content">${content}</div>`;
				this.chatContainer.appendChild(message);
				this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
				return message;
			}
		}

        // Initialize the chat interface
        const chat = new ChatUI();
    </script>
</body>
</html>